var Ox = Object.defineProperty;
var Fx = (t, e, n) => e in t ? Ox(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Ue = (t, e, n) => Fx(t, typeof e != "symbol" ? e + "" : e, n);
const Bx = "124", vp = { LEFT: 0, RIGHT: 2 }, zx = 0, yp = 1, Ux = 2, sy = 1, Hx = 2, Aa = 3, Pl = 0, Ut = 1, Zo = 2, oy = 1, Ia = 0, Da = 1, xp = 2, _p = 3, bp = 4, Gx = 5, oo = 100, Vx = 101, kx = 102, wp = 103, Mp = 104, Wx = 200, $x = 201, jx = 202, qx = 203, ay = 204, ly = 205, Xx = 206, Yx = 207, Zx = 208, Jx = 209, Kx = 210, Qx = 0, e0 = 1, t0 = 2, Md = 3, n0 = 4, i0 = 5, r0 = 6, s0 = 7, Zh = 0, o0 = 1, a0 = 2, Na = 0, l0 = 1, c0 = 2, h0 = 3, u0 = 4, d0 = 5, cy = 300, Gf = 301, Vf = 302, Sp = 303, Ep = 304, kf = 306, Wf = 307, uh = 1e3, an = 1001, dh = 1002, qt = 1003, Sd = 1004, Ed = 1005, Ht = 1006, hy = 1007, Il = 1008, $f = 1009, f0 = 1010, p0 = 1011, fh = 1012, m0 = 1013, oh = 1014, Cr = 1015, ph = 1016, g0 = 1017, v0 = 1018, y0 = 1019, Oa = 1020, x0 = 1021, Dr = 1022, ri = 1023, _0 = 1024, b0 = 1025, Mo = 1026, Ya = 1027, w0 = 1028, M0 = 1029, S0 = 1030, E0 = 1031, T0 = 1032, A0 = 1033, Tp = 33776, Ap = 33777, Lp = 33778, Cp = 33779, Rp = 35840, Pp = 35841, Ip = 35842, Dp = 35843, L0 = 36196, Np = 37492, Op = 37496, C0 = 37808, R0 = 37809, P0 = 37810, I0 = 37811, D0 = 37812, N0 = 37813, O0 = 37814, F0 = 37815, B0 = 37816, z0 = 37817, U0 = 37818, H0 = 37819, G0 = 37820, V0 = 37821, k0 = 36492, W0 = 37840, $0 = 37841, j0 = 37842, q0 = 37843, X0 = 37844, Y0 = 37845, Z0 = 37846, J0 = 37847, K0 = 37848, Q0 = 37849, e_ = 37850, t_ = 37851, n_ = 37852, i_ = 37853, r_ = 2200, s_ = 2201, o_ = 2202, Za = 2300, Fa = 2301, fu = 2302, co = 2400, ho = 2401, mh = 2402, jf = 2500, uy = 2501, a_ = 0, l_ = 1, c_ = 2, Dl = 3e3, qf = 3001, h_ = 3007, u_ = 3002, d_ = 3003, f_ = 3004, p_ = 3005, m_ = 3006, g_ = 3200, v_ = 3201, As = 0, y_ = 1, pu = 7680, x_ = 519, Jh = 35044, Ja = 35048, Fp = "300 es";
function ar() {
}
Object.assign(ar.prototype, {
  addEventListener: function(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  },
  hasEventListener: function(t, e) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  },
  removeEventListener: function(t, e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[t];
    if (r !== void 0) {
      const s = r.indexOf(e);
      s !== -1 && r.splice(s, 1);
    }
  },
  dispatchEvent: function(t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[t.type];
    if (n !== void 0) {
      t.target = this;
      const r = n.slice(0);
      for (let s = 0, o = r.length; s < o; s++)
        r[s].call(this, t);
    }
  }
});
const Bt = [];
for (let t = 0; t < 256; t++)
  Bt[t] = (t < 16 ? "0" : "") + t.toString(16);
let Ul = 1234567;
const $e = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
    return (Bt[t & 255] + Bt[t >> 8 & 255] + Bt[t >> 16 & 255] + Bt[t >> 24 & 255] + "-" + Bt[e & 255] + Bt[e >> 8 & 255] + "-" + Bt[e >> 16 & 15 | 64] + Bt[e >> 24 & 255] + "-" + Bt[n & 63 | 128] + Bt[n >> 8 & 255] + "-" + Bt[n >> 16 & 255] + Bt[n >> 24 & 255] + Bt[r & 255] + Bt[r >> 8 & 255] + Bt[r >> 16 & 255] + Bt[r >> 24 & 255]).toUpperCase();
  },
  clamp: function(t, e, n) {
    return Math.max(e, Math.min(n, t));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function(t, e) {
    return (t % e + e) % e;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function(t, e, n, r, s) {
    return r + (t - e) * (s - r) / (n - e);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function(t, e, n) {
    return (1 - n) * t + n * e;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t));
  },
  smootherstep: function(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (t * 6 - 15) + 10));
  },
  // Random integer from <low, high> interval
  randInt: function(t, e) {
    return t + Math.floor(Math.random() * (e - t + 1));
  },
  // Random float from <low, high> interval
  randFloat: function(t, e) {
    return t + Math.random() * (e - t);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function(t) {
    return t * (0.5 - Math.random());
  },
  // Deterministic pseudo-random float in the interval [ 0, 1 ]
  seededRandom: function(t) {
    return t !== void 0 && (Ul = t % 2147483647), Ul = Ul * 16807 % 2147483647, (Ul - 1) / 2147483646;
  },
  degToRad: function(t) {
    return t * $e.DEG2RAD;
  },
  radToDeg: function(t) {
    return t * $e.RAD2DEG;
  },
  isPowerOfTwo: function(t) {
    return (t & t - 1) === 0 && t !== 0;
  },
  ceilPowerOfTwo: function(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  },
  floorPowerOfTwo: function(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(t, e, n, r, s) {
    const o = Math.cos, a = Math.sin, l = o(n / 2), c = a(n / 2), h = o((e + r) / 2), d = a((e + r) / 2), u = o((e - r) / 2), p = a((e - r) / 2), f = o((r - e) / 2), m = a((r - e) / 2);
    switch (s) {
      case "XYX":
        t.set(l * d, c * u, c * p, l * h);
        break;
      case "YZY":
        t.set(c * p, l * d, c * u, l * h);
        break;
      case "ZXZ":
        t.set(c * u, c * p, l * d, l * h);
        break;
      case "XZX":
        t.set(l * d, c * m, c * f, l * h);
        break;
      case "YXY":
        t.set(c * f, l * d, c * m, l * h);
        break;
      case "ZYZ":
        t.set(c * m, c * f, l * d, l * h);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
    }
  }
};
let ye = class {
  constructor(e = 0, n = 0) {
    Object.defineProperty(this, "isVector2", { value: !0 }), this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, n)) : (this.x += e.x, this.y += e.y, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, n)) : (this.x -= e.x, this.y -= e.y, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, r = this.y, s = e.elements;
    return this.x = s[0] * n + s[3] * r + s[6], this.y = s[1] * n + s[4] * r + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, r = this.y - e.y;
    return n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, r) {
    return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n, r) {
    return r !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const r = Math.cos(n), s = Math.sin(n), o = this.x - e.x, a = this.y - e.y;
    return this.x = o * r - a * s + e.x, this.y = o * s + a * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
}, ln = class {
  constructor() {
    Object.defineProperty(this, "isMatrix3", { value: !0 }), this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e, n, r, s, o, a, l, c, h) {
    const d = this.elements;
    return d[0] = e, d[1] = s, d[2] = l, d[3] = n, d[4] = o, d[5] = c, d[6] = r, d[7] = a, d[8] = h, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, r = e.elements;
    return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], this;
  }
  extractBasis(e, n, r) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements, s = n.elements, o = this.elements, a = r[0], l = r[3], c = r[6], h = r[1], d = r[4], u = r[7], p = r[2], f = r[5], m = r[8], y = s[0], x = s[3], v = s[6], g = s[1], S = s[4], T = s[7], E = s[2], w = s[5], C = s[8];
    return o[0] = a * y + l * g + c * E, o[3] = a * x + l * S + c * w, o[6] = a * v + l * T + c * C, o[1] = h * y + d * g + u * E, o[4] = h * x + d * S + u * w, o[7] = h * v + d * T + u * C, o[2] = p * y + f * g + m * E, o[5] = p * x + f * S + m * w, o[8] = p * v + f * T + m * C, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], h = e[7], d = e[8];
    return n * a * d - n * l * h - r * o * d + r * l * c + s * o * h - s * a * c;
  }
  invert() {
    const e = this.elements, n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], h = e[7], d = e[8], u = d * a - l * h, p = l * c - d * o, f = h * o - a * c, m = n * u + r * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / m;
    return e[0] = u * y, e[1] = (s * h - d * r) * y, e[2] = (l * r - s * a) * y, e[3] = p * y, e[4] = (d * n - s * c) * y, e[5] = (s * o - l * n) * y, e[6] = f * y, e[7] = (r * c - h * n) * y, e[8] = (a * n - r * o) * y, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).copy(this).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, r, s, o, a, l) {
    const c = Math.cos(o), h = Math.sin(o);
    return this.set(
      r * c,
      r * h,
      -r * (c * a + h * l) + a + e,
      -s * h,
      s * c,
      -s * (-h * a + c * l) + l + n,
      0,
      0,
      1
    ), this;
  }
  scale(e, n) {
    const r = this.elements;
    return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= n, r[4] *= n, r[7] *= n, this;
  }
  rotate(e) {
    const n = Math.cos(e), r = Math.sin(e), s = this.elements, o = s[0], a = s[3], l = s[6], c = s[1], h = s[4], d = s[7];
    return s[0] = n * o + r * c, s[3] = n * a + r * h, s[6] = n * l + r * d, s[1] = -r * o + n * c, s[4] = -r * a + n * h, s[7] = -r * l + n * d, this;
  }
  translate(e, n) {
    const r = this.elements;
    return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += n * r[2], r[4] += n * r[5], r[7] += n * r[8], this;
  }
  equals(e) {
    const n = this.elements, r = e.elements;
    for (let s = 0; s < 9; s++)
      if (n[s] !== r[s]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e;
  }
}, Ls;
const Jo = {
  getDataURL: function(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement)
      e = t;
    else {
      Ls === void 0 && (Ls = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Ls.width = t.width, Ls.height = t.height;
      const n = Ls.getContext("2d");
      t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Ls;
    }
    return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", 0.6) : e.toDataURL("image/png");
  }
};
let __ = 0;
function ft(t = ft.DEFAULT_IMAGE, e = ft.DEFAULT_MAPPING, n = an, r = an, s = Ht, o = Il, a = ri, l = $f, c = 1, h = Dl) {
  Object.defineProperty(this, "id", { value: __++ }), this.uuid = $e.generateUUID(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new ye(0, 0), this.repeat = new ye(1, 1), this.center = new ye(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ln(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.version = 0, this.onUpdate = null;
}
ft.DEFAULT_IMAGE = void 0;
ft.DEFAULT_MAPPING = cy;
ft.prototype = Object.assign(Object.create(ar.prototype), {
  constructor: ft,
  isTexture: !0,
  updateMatrix: function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const r = this.image;
      if (r.uuid === void 0 && (r.uuid = $e.generateUUID()), !e && t.images[r.uuid] === void 0) {
        let s;
        if (Array.isArray(r)) {
          s = [];
          for (let o = 0, a = r.length; o < a; o++)
            r[o].isDataTexture ? s.push(mu(r[o].image)) : s.push(mu(r[o]));
        } else
          s = mu(r);
        t.images[r.uuid] = {
          uuid: r.uuid,
          url: s
        };
      }
      n.image = r.uuid;
    }
    return e || (t.textures[this.uuid] = n), n;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function(t) {
    if (this.mapping !== cy) return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case uh:
          t.x = t.x - Math.floor(t.x);
          break;
        case an:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case dh:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case uh:
          t.y = t.y - Math.floor(t.y);
          break;
        case an:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case dh:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
});
Object.defineProperty(ft.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
function mu(t) {
  return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? Jo.getDataURL(t) : t.data ? {
    data: Array.prototype.slice.call(t.data),
    width: t.width,
    height: t.height,
    type: t.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let ht = class {
  constructor(e = 0, n = 0, r = 0, s = 1) {
    Object.defineProperty(this, "isVector4", { value: !0 }), this.x = e, this.y = n, this.z = r, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, r, s) {
    return this.x = e, this.y = n, this.z = r, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, n)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, n)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, r = this.y, s = this.z, o = this.w, a = e.elements;
    return this.x = a[0] * n + a[4] * r + a[8] * s + a[12] * o, this.y = a[1] * n + a[5] * r + a[9] * s + a[13] * o, this.z = a[2] * n + a[6] * r + a[10] * s + a[14] * o, this.w = a[3] * n + a[7] * r + a[11] * s + a[15] * o, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, r, s, o;
    const c = e.elements, h = c[0], d = c[4], u = c[8], p = c[1], f = c[5], m = c[9], y = c[2], x = c[6], v = c[10];
    if (Math.abs(d - p) < 0.01 && Math.abs(u - y) < 0.01 && Math.abs(m - x) < 0.01) {
      if (Math.abs(d + p) < 0.1 && Math.abs(u + y) < 0.1 && Math.abs(m + x) < 0.1 && Math.abs(h + f + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const S = (h + 1) / 2, T = (f + 1) / 2, E = (v + 1) / 2, w = (d + p) / 4, C = (u + y) / 4, ee = (m + x) / 4;
      return S > T && S > E ? S < 0.01 ? (r = 0, s = 0.707106781, o = 0.707106781) : (r = Math.sqrt(S), s = w / r, o = C / r) : T > E ? T < 0.01 ? (r = 0.707106781, s = 0, o = 0.707106781) : (s = Math.sqrt(T), r = w / s, o = ee / s) : E < 0.01 ? (r = 0.707106781, s = 0.707106781, o = 0) : (o = Math.sqrt(E), r = C / o, s = ee / o), this.set(r, s, o, n), this;
    }
    let g = Math.sqrt((x - m) * (x - m) + (u - y) * (u - y) + (p - d) * (p - d));
    return Math.abs(g) < 1e-3 && (g = 1), this.x = (x - m) / g, this.y = (u - y) / g, this.z = (p - d) / g, this.w = Math.acos((h + f + v - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, r) {
    return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this.w = e.w + (n.w - e.w) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n, r) {
    return r !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
};
function si(t, e, n) {
  this.width = t, this.height = e, this.scissor = new ht(0, 0, t, e), this.scissorTest = !1, this.viewport = new ht(0, 0, t, e), n = n || {}, this.texture = new ft(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Ht, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null;
}
si.prototype = Object.assign(Object.create(ar.prototype), {
  constructor: si,
  isWebGLRenderTarget: !0,
  setSize: function(t, e) {
    (this.width !== t || this.height !== e) && (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function Bp(t, e, n) {
  si.call(this, t, e, n), this.samples = 4;
}
Bp.prototype = Object.assign(Object.create(si.prototype), {
  constructor: Bp,
  isWebGLMultisampleRenderTarget: !0,
  copy: function(t) {
    return si.prototype.copy.call(this, t), this.samples = t.samples, this;
  }
});
let bn = class {
  constructor(e = 0, n = 0, r = 0, s = 1) {
    Object.defineProperty(this, "isQuaternion", { value: !0 }), this._x = e, this._y = n, this._z = r, this._w = s;
  }
  static slerp(e, n, r, s) {
    return r.copy(e).slerp(n, s);
  }
  static slerpFlat(e, n, r, s, o, a, l) {
    let c = r[s + 0], h = r[s + 1], d = r[s + 2], u = r[s + 3];
    const p = o[a + 0], f = o[a + 1], m = o[a + 2], y = o[a + 3];
    if (u !== y || c !== p || h !== f || d !== m) {
      let x = 1 - l;
      const v = c * p + h * f + d * m + u * y, g = v >= 0 ? 1 : -1, S = 1 - v * v;
      if (S > Number.EPSILON) {
        const E = Math.sqrt(S), w = Math.atan2(E, v * g);
        x = Math.sin(x * w) / E, l = Math.sin(l * w) / E;
      }
      const T = l * g;
      if (c = c * x + p * T, h = h * x + f * T, d = d * x + m * T, u = u * x + y * T, x === 1 - l) {
        const E = 1 / Math.sqrt(c * c + h * h + d * d + u * u);
        c *= E, h *= E, d *= E, u *= E;
      }
    }
    e[n] = c, e[n + 1] = h, e[n + 2] = d, e[n + 3] = u;
  }
  static multiplyQuaternionsFlat(e, n, r, s, o, a) {
    const l = r[s], c = r[s + 1], h = r[s + 2], d = r[s + 3], u = o[a], p = o[a + 1], f = o[a + 2], m = o[a + 3];
    return e[n] = l * m + d * u + c * f - h * p, e[n + 1] = c * m + d * p + h * u - l * f, e[n + 2] = h * m + d * f + l * p - c * u, e[n + 3] = d * m - l * u - c * p - h * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, r, s) {
    return this._x = e, this._y = n, this._z = r, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const r = e._x, s = e._y, o = e._z, a = e._order, l = Math.cos, c = Math.sin, h = l(r / 2), d = l(s / 2), u = l(o / 2), p = c(r / 2), f = c(s / 2), m = c(o / 2);
    switch (a) {
      case "XYZ":
        this._x = p * d * u + h * f * m, this._y = h * f * u - p * d * m, this._z = h * d * m + p * f * u, this._w = h * d * u - p * f * m;
        break;
      case "YXZ":
        this._x = p * d * u + h * f * m, this._y = h * f * u - p * d * m, this._z = h * d * m - p * f * u, this._w = h * d * u + p * f * m;
        break;
      case "ZXY":
        this._x = p * d * u - h * f * m, this._y = h * f * u + p * d * m, this._z = h * d * m + p * f * u, this._w = h * d * u - p * f * m;
        break;
      case "ZYX":
        this._x = p * d * u - h * f * m, this._y = h * f * u + p * d * m, this._z = h * d * m - p * f * u, this._w = h * d * u + p * f * m;
        break;
      case "YZX":
        this._x = p * d * u + h * f * m, this._y = h * f * u + p * d * m, this._z = h * d * m - p * f * u, this._w = h * d * u - p * f * m;
        break;
      case "XZY":
        this._x = p * d * u - h * f * m, this._y = h * f * u - p * d * m, this._z = h * d * m + p * f * u, this._w = h * d * u + p * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return n !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const r = n / 2, s = Math.sin(r);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, r = n[0], s = n[4], o = n[8], a = n[1], l = n[5], c = n[9], h = n[2], d = n[6], u = n[10], p = r + l + u;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (d - c) * f, this._y = (o - h) * f, this._z = (a - s) * f;
    } else if (r > l && r > u) {
      const f = 2 * Math.sqrt(1 + r - l - u);
      this._w = (d - c) / f, this._x = 0.25 * f, this._y = (s + a) / f, this._z = (o + h) / f;
    } else if (l > u) {
      const f = 2 * Math.sqrt(1 + l - r - u);
      this._w = (o - h) / f, this._x = (s + a) / f, this._y = 0.25 * f, this._z = (c + d) / f;
    } else {
      const f = 2 * Math.sqrt(1 + u - r - l);
      this._w = (a - s) / f, this._x = (o + h) / f, this._y = (c + d) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let s = e.dot(n) + 1;
    return s < 1e-6 ? (s = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = s) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = s)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = s), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs($e.clamp(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const s = Math.min(1, n / r);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e, n) {
    return n !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, n)) : this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const r = e._x, s = e._y, o = e._z, a = e._w, l = n._x, c = n._y, h = n._z, d = n._w;
    return this._x = r * d + a * l + s * h - o * c, this._y = s * d + a * c + o * l - r * h, this._z = o * d + a * h + r * c - s * l, this._w = a * d - r * l - s * c - o * h, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const r = this._x, s = this._y, o = this._z, a = this._w;
    let l = a * e._w + r * e._x + s * e._y + o * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = a, this._x = r, this._y = s, this._z = o, this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const f = 1 - n;
      return this._w = f * a + n * this._w, this._x = f * r + n * this._x, this._y = f * s + n * this._y, this._z = f * o + n * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const h = Math.sqrt(c), d = Math.atan2(h, l), u = Math.sin((1 - n) * d) / h, p = Math.sin(n * d) / h;
    return this._w = a * u + this._w * p, this._x = r * u + this._x * p, this._y = s * u + this._y * p, this._z = o * u + this._z * p, this._onChangeCallback(), this;
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
}, z = class {
  constructor(e = 0, n = 0, r = 0) {
    Object.defineProperty(this, "isVector3", { value: !0 }), this.x = e, this.y = n, this.z = r;
  }
  set(e, n, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = n, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, n)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, n)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, n)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(zp.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(zp.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, r = this.y, s = this.z, o = e.elements;
    return this.x = o[0] * n + o[3] * r + o[6] * s, this.y = o[1] * n + o[4] * r + o[7] * s, this.z = o[2] * n + o[5] * r + o[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, r = this.y, s = this.z, o = e.elements, a = 1 / (o[3] * n + o[7] * r + o[11] * s + o[15]);
    return this.x = (o[0] * n + o[4] * r + o[8] * s + o[12]) * a, this.y = (o[1] * n + o[5] * r + o[9] * s + o[13]) * a, this.z = (o[2] * n + o[6] * r + o[10] * s + o[14]) * a, this;
  }
  applyQuaternion(e) {
    const n = this.x, r = this.y, s = this.z, o = e.x, a = e.y, l = e.z, c = e.w, h = c * n + a * s - l * r, d = c * r + l * n - o * s, u = c * s + o * r - a * n, p = -o * n - a * r - l * s;
    return this.x = h * c + p * -o + d * -l - u * -a, this.y = d * c + p * -a + u * -o - h * -l, this.z = u * c + p * -l + h * -a - d * -o, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, r = this.y, s = this.z, o = e.elements;
    return this.x = o[0] * n + o[4] * r + o[8] * s, this.y = o[1] * n + o[5] * r + o[9] * s, this.z = o[2] * n + o[6] * r + o[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, r) {
    return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this;
  }
  cross(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, n)) : this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const r = e.x, s = e.y, o = e.z, a = n.x, l = n.y, c = n.z;
    return this.x = s * c - o * l, this.y = o * a - r * c, this.z = r * l - s * a, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / n;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return gu.copy(this).projectOnVector(e), this.sub(gu);
  }
  reflect(e) {
    return this.sub(gu.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const r = this.dot(e) / n;
    return Math.acos($e.clamp(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, r = this.y - e.y, s = this.z - e.z;
    return n * n + r * r + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, r) {
    const s = Math.sin(n) * e;
    return this.x = s * Math.sin(r), this.y = Math.cos(n) * e, this.z = s * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, r) {
    return this.x = e * Math.sin(n), this.y = r, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = r, this.z = s, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n, r) {
    return r !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
};
const gu = /* @__PURE__ */ new z(), zp = /* @__PURE__ */ new bn();
let kt = class {
  constructor(e, n) {
    Object.defineProperty(this, "isBox3", { value: !0 }), this.min = e !== void 0 ? e : new z(1 / 0, 1 / 0, 1 / 0), this.max = n !== void 0 ? n : new z(-1 / 0, -1 / 0, -1 / 0);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    let n = 1 / 0, r = 1 / 0, s = 1 / 0, o = -1 / 0, a = -1 / 0, l = -1 / 0;
    for (let c = 0, h = e.length; c < h; c += 3) {
      const d = e[c], u = e[c + 1], p = e[c + 2];
      d < n && (n = d), u < r && (r = u), p < s && (s = p), d > o && (o = d), u > a && (a = u), p > l && (l = p);
    }
    return this.min.set(n, r, s), this.max.set(o, a, l), this;
  }
  setFromBufferAttribute(e) {
    let n = 1 / 0, r = 1 / 0, s = 1 / 0, o = -1 / 0, a = -1 / 0, l = -1 / 0;
    for (let c = 0, h = e.count; c < h; c++) {
      const d = e.getX(c), u = e.getY(c), p = e.getZ(c);
      d < n && (n = d), u < r && (r = u), p < s && (s = p), d > o && (o = d), u > a && (a = u), p > l && (l = p);
    }
    return this.min.set(n, r, s), this.max.set(o, a, l), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = oa.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e) {
    return this.makeEmpty(), this.expandByObject(e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new z()), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), e = new z()), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    n !== void 0 && (n.boundingBox === null && n.computeBoundingBox(), yu.copy(n.boundingBox), yu.applyMatrix4(e.matrixWorld), this.union(yu));
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++)
      this.expandByObject(r[s]);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), n = new z()), n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, oa), oa.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, r;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, r += e.normal.z * this.min.z), n <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(aa), Hl.subVectors(this.max, aa), Cs.subVectors(e.a, aa), Rs.subVectors(e.b, aa), Ps.subVectors(e.c, aa), ur.subVectors(Rs, Cs), dr.subVectors(Ps, Rs), is.subVectors(Cs, Ps);
    let n = [
      0,
      -ur.z,
      ur.y,
      0,
      -dr.z,
      dr.y,
      0,
      -is.z,
      is.y,
      ur.z,
      0,
      -ur.x,
      dr.z,
      0,
      -dr.x,
      is.z,
      0,
      -is.x,
      -ur.y,
      ur.x,
      0,
      -dr.y,
      dr.x,
      0,
      -is.y,
      is.x,
      0
    ];
    return !vu(n, Cs, Rs, Ps, Hl) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !vu(n, Cs, Rs, Ps, Hl)) ? !1 : (Gl.crossVectors(ur, dr), n = [Gl.x, Gl.y, Gl.z], vu(n, Cs, Rs, Ps, Hl));
  }
  clampPoint(e, n) {
    return n === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), n = new z()), n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return oa.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return e === void 0 && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = this.getSize(oa).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ui[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ui[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ui[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ui[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ui[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ui[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ui[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ui[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ui), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
};
function vu(t, e, n, r, s) {
  for (let o = 0, a = t.length - 3; o <= a; o += 3) {
    rs.fromArray(t, o);
    const l = s.x * Math.abs(rs.x) + s.y * Math.abs(rs.y) + s.z * Math.abs(rs.z), c = e.dot(rs), h = n.dot(rs), d = r.dot(rs);
    if (Math.max(-Math.max(c, h, d), Math.min(c, h, d)) > l)
      return !1;
  }
  return !0;
}
const Ui = [
  /* @__PURE__ */ new z(),
  /* @__PURE__ */ new z(),
  /* @__PURE__ */ new z(),
  /* @__PURE__ */ new z(),
  /* @__PURE__ */ new z(),
  /* @__PURE__ */ new z(),
  /* @__PURE__ */ new z(),
  /* @__PURE__ */ new z()
], oa = /* @__PURE__ */ new z(), yu = /* @__PURE__ */ new kt(), Cs = /* @__PURE__ */ new z(), Rs = /* @__PURE__ */ new z(), Ps = /* @__PURE__ */ new z(), ur = /* @__PURE__ */ new z(), dr = /* @__PURE__ */ new z(), is = /* @__PURE__ */ new z(), aa = /* @__PURE__ */ new z(), Hl = /* @__PURE__ */ new z(), Gl = /* @__PURE__ */ new z(), rs = /* @__PURE__ */ new z(), b_ = /* @__PURE__ */ new kt();
let hi = class {
  constructor(e, n) {
    this.center = e !== void 0 ? e : new z(), this.radius = n !== void 0 ? n : -1;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const r = this.center;
    n !== void 0 ? r.copy(n) : b_.setFromPoints(e).getCenter(r);
    let s = 0;
    for (let o = 0, a = e.length; o < a; o++)
      s = Math.max(s, r.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const r = this.center.distanceToSquared(e);
    return n === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), n = new z()), n.copy(e), r > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return e === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new kt()), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
};
const Hi = /* @__PURE__ */ new z(), xu = /* @__PURE__ */ new z(), Vl = /* @__PURE__ */ new z(), fr = /* @__PURE__ */ new z(), _u = /* @__PURE__ */ new z(), kl = /* @__PURE__ */ new z(), bu = /* @__PURE__ */ new z();
let Nl = class {
  constructor(e, n) {
    this.origin = e !== void 0 ? e : new z(), this.direction = n !== void 0 ? n : new z(0, 0, -1);
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n === void 0 && (console.warn("THREE.Ray: .at() target is now required"), n = new z()), n.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Hi)), this;
  }
  closestPointToPoint(e, n) {
    n === void 0 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), n = new z()), n.subVectors(e, this.origin);
    const r = n.dot(this.direction);
    return r < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = Hi.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (Hi.copy(this.direction).multiplyScalar(n).add(this.origin), Hi.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, r, s) {
    xu.copy(e).add(n).multiplyScalar(0.5), Vl.copy(n).sub(e).normalize(), fr.copy(this.origin).sub(xu);
    const o = e.distanceTo(n) * 0.5, a = -this.direction.dot(Vl), l = fr.dot(this.direction), c = -fr.dot(Vl), h = fr.lengthSq(), d = Math.abs(1 - a * a);
    let u, p, f, m;
    if (d > 0)
      if (u = a * c - l, p = a * l - c, m = o * d, u >= 0)
        if (p >= -m)
          if (p <= m) {
            const y = 1 / d;
            u *= y, p *= y, f = u * (u + a * p + 2 * l) + p * (a * u + p + 2 * c) + h;
          } else
            p = o, u = Math.max(0, -(a * p + l)), f = -u * u + p * (p + 2 * c) + h;
        else
          p = -o, u = Math.max(0, -(a * p + l)), f = -u * u + p * (p + 2 * c) + h;
      else
        p <= -m ? (u = Math.max(0, -(-a * o + l)), p = u > 0 ? -o : Math.min(Math.max(-o, -c), o), f = -u * u + p * (p + 2 * c) + h) : p <= m ? (u = 0, p = Math.min(Math.max(-o, -c), o), f = p * (p + 2 * c) + h) : (u = Math.max(0, -(a * o + l)), p = u > 0 ? o : Math.min(Math.max(-o, -c), o), f = -u * u + p * (p + 2 * c) + h);
    else
      p = a > 0 ? -o : o, u = Math.max(0, -(a * p + l)), f = -u * u + p * (p + 2 * c) + h;
    return r && r.copy(this.direction).multiplyScalar(u).add(this.origin), s && s.copy(Vl).multiplyScalar(p).add(xu), f;
  }
  intersectSphere(e, n) {
    Hi.subVectors(e.center, this.origin);
    const r = Hi.dot(this.direction), s = Hi.dot(Hi) - r * r, o = e.radius * e.radius;
    if (s > o) return null;
    const a = Math.sqrt(o - s), l = r - a, c = r + a;
    return l < 0 && c < 0 ? null : l < 0 ? this.at(c, n) : this.at(l, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / n;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, n) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let r, s, o, a, l, c;
    const h = 1 / this.direction.x, d = 1 / this.direction.y, u = 1 / this.direction.z, p = this.origin;
    return h >= 0 ? (r = (e.min.x - p.x) * h, s = (e.max.x - p.x) * h) : (r = (e.max.x - p.x) * h, s = (e.min.x - p.x) * h), d >= 0 ? (o = (e.min.y - p.y) * d, a = (e.max.y - p.y) * d) : (o = (e.max.y - p.y) * d, a = (e.min.y - p.y) * d), r > a || o > s || ((o > r || r !== r) && (r = o), (a < s || s !== s) && (s = a), u >= 0 ? (l = (e.min.z - p.z) * u, c = (e.max.z - p.z) * u) : (l = (e.max.z - p.z) * u, c = (e.min.z - p.z) * u), r > c || l > s) || ((l > r || r !== r) && (r = l), (c < s || s !== s) && (s = c), s < 0) ? null : this.at(r >= 0 ? r : s, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Hi) !== null;
  }
  intersectTriangle(e, n, r, s, o) {
    _u.subVectors(n, e), kl.subVectors(r, e), bu.crossVectors(_u, kl);
    let a = this.direction.dot(bu), l;
    if (a > 0) {
      if (s) return null;
      l = 1;
    } else if (a < 0)
      l = -1, a = -a;
    else
      return null;
    fr.subVectors(this.origin, e);
    const c = l * this.direction.dot(kl.crossVectors(fr, kl));
    if (c < 0)
      return null;
    const h = l * this.direction.dot(_u.cross(fr));
    if (h < 0 || c + h > a)
      return null;
    const d = -l * fr.dot(bu);
    return d < 0 ? null : this.at(d / a, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
}, Je = class dy {
  constructor() {
    Object.defineProperty(this, "isMatrix4", { value: !0 }), this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e, n, r, s, o, a, l, c, h, d, u, p, f, m, y, x) {
    const v = this.elements;
    return v[0] = e, v[4] = n, v[8] = r, v[12] = s, v[1] = o, v[5] = a, v[9] = l, v[13] = c, v[2] = h, v[6] = d, v[10] = u, v[14] = p, v[3] = f, v[7] = m, v[11] = y, v[15] = x, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new dy().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, r = e.elements;
    return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this;
  }
  copyPosition(e) {
    const n = this.elements, r = e.elements;
    return n[12] = r[12], n[13] = r[13], n[14] = r[14], this;
  }
  extractBasis(e, n, r) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, r) {
    return this.set(
      e.x,
      n.x,
      r.x,
      0,
      e.y,
      n.y,
      r.y,
      0,
      e.z,
      n.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const n = this.elements, r = e.elements, s = 1 / Is.setFromMatrixColumn(e, 0).length(), o = 1 / Is.setFromMatrixColumn(e, 1).length(), a = 1 / Is.setFromMatrixColumn(e, 2).length();
    return n[0] = r[0] * s, n[1] = r[1] * s, n[2] = r[2] * s, n[3] = 0, n[4] = r[4] * o, n[5] = r[5] * o, n[6] = r[6] * o, n[7] = 0, n[8] = r[8] * a, n[9] = r[9] * a, n[10] = r[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    const n = this.elements, r = e.x, s = e.y, o = e.z, a = Math.cos(r), l = Math.sin(r), c = Math.cos(s), h = Math.sin(s), d = Math.cos(o), u = Math.sin(o);
    if (e.order === "XYZ") {
      const p = a * d, f = a * u, m = l * d, y = l * u;
      n[0] = c * d, n[4] = -c * u, n[8] = h, n[1] = f + m * h, n[5] = p - y * h, n[9] = -l * c, n[2] = y - p * h, n[6] = m + f * h, n[10] = a * c;
    } else if (e.order === "YXZ") {
      const p = c * d, f = c * u, m = h * d, y = h * u;
      n[0] = p + y * l, n[4] = m * l - f, n[8] = a * h, n[1] = a * u, n[5] = a * d, n[9] = -l, n[2] = f * l - m, n[6] = y + p * l, n[10] = a * c;
    } else if (e.order === "ZXY") {
      const p = c * d, f = c * u, m = h * d, y = h * u;
      n[0] = p - y * l, n[4] = -a * u, n[8] = m + f * l, n[1] = f + m * l, n[5] = a * d, n[9] = y - p * l, n[2] = -a * h, n[6] = l, n[10] = a * c;
    } else if (e.order === "ZYX") {
      const p = a * d, f = a * u, m = l * d, y = l * u;
      n[0] = c * d, n[4] = m * h - f, n[8] = p * h + y, n[1] = c * u, n[5] = y * h + p, n[9] = f * h - m, n[2] = -h, n[6] = l * c, n[10] = a * c;
    } else if (e.order === "YZX") {
      const p = a * c, f = a * h, m = l * c, y = l * h;
      n[0] = c * d, n[4] = y - p * u, n[8] = m * u + f, n[1] = u, n[5] = a * d, n[9] = -l * d, n[2] = -h * d, n[6] = f * u + m, n[10] = p - y * u;
    } else if (e.order === "XZY") {
      const p = a * c, f = a * h, m = l * c, y = l * h;
      n[0] = c * d, n[4] = -u, n[8] = h * d, n[1] = p * u + y, n[5] = a * d, n[9] = f * u - m, n[2] = m * u - f, n[6] = l * d, n[10] = y * u + p;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(w_, e, M_);
  }
  lookAt(e, n, r) {
    const s = this.elements;
    return pn.subVectors(e, n), pn.lengthSq() === 0 && (pn.z = 1), pn.normalize(), pr.crossVectors(r, pn), pr.lengthSq() === 0 && (Math.abs(r.z) === 1 ? pn.x += 1e-4 : pn.z += 1e-4, pn.normalize(), pr.crossVectors(r, pn)), pr.normalize(), Wl.crossVectors(pn, pr), s[0] = pr.x, s[4] = Wl.x, s[8] = pn.x, s[1] = pr.y, s[5] = Wl.y, s[9] = pn.y, s[2] = pr.z, s[6] = Wl.z, s[10] = pn.z, this;
  }
  multiply(e, n) {
    return n !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, n)) : this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements, s = n.elements, o = this.elements, a = r[0], l = r[4], c = r[8], h = r[12], d = r[1], u = r[5], p = r[9], f = r[13], m = r[2], y = r[6], x = r[10], v = r[14], g = r[3], S = r[7], T = r[11], E = r[15], w = s[0], C = s[4], ee = s[8], Y = s[12], le = s[1], B = s[5], Z = s[9], k = s[13], O = s[2], P = s[6], j = s[10], re = s[14], ae = s[3], ce = s[7], pe = s[11], de = s[15];
    return o[0] = a * w + l * le + c * O + h * ae, o[4] = a * C + l * B + c * P + h * ce, o[8] = a * ee + l * Z + c * j + h * pe, o[12] = a * Y + l * k + c * re + h * de, o[1] = d * w + u * le + p * O + f * ae, o[5] = d * C + u * B + p * P + f * ce, o[9] = d * ee + u * Z + p * j + f * pe, o[13] = d * Y + u * k + p * re + f * de, o[2] = m * w + y * le + x * O + v * ae, o[6] = m * C + y * B + x * P + v * ce, o[10] = m * ee + y * Z + x * j + v * pe, o[14] = m * Y + y * k + x * re + v * de, o[3] = g * w + S * le + T * O + E * ae, o[7] = g * C + S * B + T * P + E * ce, o[11] = g * ee + S * Z + T * j + E * pe, o[15] = g * Y + S * k + T * re + E * de, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], r = e[4], s = e[8], o = e[12], a = e[1], l = e[5], c = e[9], h = e[13], d = e[2], u = e[6], p = e[10], f = e[14], m = e[3], y = e[7], x = e[11], v = e[15];
    return m * (+o * c * u - s * h * u - o * l * p + r * h * p + s * l * f - r * c * f) + y * (+n * c * f - n * h * p + o * a * p - s * a * f + s * h * d - o * c * d) + x * (+n * h * u - n * l * f - o * a * u + r * a * f + o * l * d - r * h * d) + v * (-s * l * d - n * c * u + n * l * p + s * a * u - r * a * p + r * c * d);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, r) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = n, s[14] = r), this;
  }
  invert() {
    const e = this.elements, n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], h = e[7], d = e[8], u = e[9], p = e[10], f = e[11], m = e[12], y = e[13], x = e[14], v = e[15], g = u * x * h - y * p * h + y * c * f - l * x * f - u * c * v + l * p * v, S = m * p * h - d * x * h - m * c * f + a * x * f + d * c * v - a * p * v, T = d * y * h - m * u * h + m * l * f - a * y * f - d * l * v + a * u * v, E = m * u * c - d * y * c - m * l * p + a * y * p + d * l * x - a * u * x, w = n * g + r * S + s * T + o * E;
    if (w === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const C = 1 / w;
    return e[0] = g * C, e[1] = (y * p * o - u * x * o - y * s * f + r * x * f + u * s * v - r * p * v) * C, e[2] = (l * x * o - y * c * o + y * s * h - r * x * h - l * s * v + r * c * v) * C, e[3] = (u * c * o - l * p * o - u * s * h + r * p * h + l * s * f - r * c * f) * C, e[4] = S * C, e[5] = (d * x * o - m * p * o + m * s * f - n * x * f - d * s * v + n * p * v) * C, e[6] = (m * c * o - a * x * o - m * s * h + n * x * h + a * s * v - n * c * v) * C, e[7] = (a * p * o - d * c * o + d * s * h - n * p * h - a * s * f + n * c * f) * C, e[8] = T * C, e[9] = (m * u * o - d * y * o - m * r * f + n * y * f + d * r * v - n * u * v) * C, e[10] = (a * y * o - m * l * o + m * r * h - n * y * h - a * r * v + n * l * v) * C, e[11] = (d * l * o - a * u * o - d * r * h + n * u * h + a * r * f - n * l * f) * C, e[12] = E * C, e[13] = (d * y * s - m * u * s + m * r * p - n * y * p - d * r * x + n * u * x) * C, e[14] = (m * l * s - a * y * s - m * r * c + n * y * c + a * r * x - n * l * x) * C, e[15] = (a * u * s - d * l * s + d * r * c - n * u * c - a * r * p + n * l * p) * C, this;
  }
  scale(e) {
    const n = this.elements, r = e.x, s = e.y, o = e.z;
    return n[0] *= r, n[4] *= s, n[8] *= o, n[1] *= r, n[5] *= s, n[9] *= o, n[2] *= r, n[6] *= s, n[10] *= o, n[3] *= r, n[7] *= s, n[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, r, s));
  }
  makeTranslation(e, n, r) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -r,
      0,
      0,
      r,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), r = Math.sin(e);
    return this.set(
      n,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), r = Math.sin(e);
    return this.set(
      n,
      -r,
      0,
      0,
      r,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, n) {
    const r = Math.cos(n), s = Math.sin(n), o = 1 - r, a = e.x, l = e.y, c = e.z, h = o * a, d = o * l;
    return this.set(
      h * a + r,
      h * l - s * c,
      h * c + s * l,
      0,
      h * l + s * c,
      d * l + r,
      d * c - s * a,
      0,
      h * c - s * l,
      d * c + s * a,
      o * c * c + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, n, r) {
    return this.set(
      1,
      n,
      r,
      0,
      e,
      1,
      r,
      0,
      e,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, n, r) {
    const s = this.elements, o = n._x, a = n._y, l = n._z, c = n._w, h = o + o, d = a + a, u = l + l, p = o * h, f = o * d, m = o * u, y = a * d, x = a * u, v = l * u, g = c * h, S = c * d, T = c * u, E = r.x, w = r.y, C = r.z;
    return s[0] = (1 - (y + v)) * E, s[1] = (f + T) * E, s[2] = (m - S) * E, s[3] = 0, s[4] = (f - T) * w, s[5] = (1 - (p + v)) * w, s[6] = (x + g) * w, s[7] = 0, s[8] = (m + S) * C, s[9] = (x - g) * C, s[10] = (1 - (p + y)) * C, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, n, r) {
    const s = this.elements;
    let o = Is.set(s[0], s[1], s[2]).length();
    const a = Is.set(s[4], s[5], s[6]).length(), l = Is.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (o = -o), e.x = s[12], e.y = s[13], e.z = s[14], jn.copy(this);
    const h = 1 / o, d = 1 / a, u = 1 / l;
    return jn.elements[0] *= h, jn.elements[1] *= h, jn.elements[2] *= h, jn.elements[4] *= d, jn.elements[5] *= d, jn.elements[6] *= d, jn.elements[8] *= u, jn.elements[9] *= u, jn.elements[10] *= u, n.setFromRotationMatrix(jn), r.x = o, r.y = a, r.z = l, this;
  }
  makePerspective(e, n, r, s, o, a) {
    a === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    const l = this.elements, c = 2 * o / (n - e), h = 2 * o / (r - s), d = (n + e) / (n - e), u = (r + s) / (r - s), p = -(a + o) / (a - o), f = -2 * a * o / (a - o);
    return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = h, l[9] = u, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = f, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, n, r, s, o, a) {
    const l = this.elements, c = 1 / (n - e), h = 1 / (r - s), d = 1 / (a - o), u = (n + e) * c, p = (r + s) * h, f = (a + o) * d;
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -u, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = -2 * d, l[14] = -f, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, r = e.elements;
    for (let s = 0; s < 16; s++)
      if (n[s] !== r[s]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e[n + 9] = r[9], e[n + 10] = r[10], e[n + 11] = r[11], e[n + 12] = r[12], e[n + 13] = r[13], e[n + 14] = r[14], e[n + 15] = r[15], e;
  }
};
const Is = /* @__PURE__ */ new z(), jn = /* @__PURE__ */ new Je(), w_ = /* @__PURE__ */ new z(0, 0, 0), M_ = /* @__PURE__ */ new z(1, 1, 1), pr = /* @__PURE__ */ new z(), Wl = /* @__PURE__ */ new z(), pn = /* @__PURE__ */ new z();
let Xf = class fy {
  constructor(e = 0, n = 0, r = 0, s = fy.DefaultOrder) {
    Object.defineProperty(this, "isEuler", { value: !0 }), this._x = e, this._y = n, this._z = r, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, r, s) {
    return this._x = e, this._y = n, this._z = r, this._order = s || this._order, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n, r) {
    const s = $e.clamp, o = e.elements, a = o[0], l = o[4], c = o[8], h = o[1], d = o[5], u = o[9], p = o[2], f = o[6], m = o[10];
    switch (n = n || this._order, n) {
      case "XYZ":
        this._y = Math.asin(s(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-u, m), this._z = Math.atan2(-l, a)) : (this._x = Math.atan2(f, d), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-s(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(c, m), this._z = Math.atan2(h, d)) : (this._y = Math.atan2(-p, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(s(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(-p, m), this._z = Math.atan2(-l, d)) : (this._y = 0, this._z = Math.atan2(h, a));
        break;
      case "ZYX":
        this._y = Math.asin(-s(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(f, m), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-l, d));
        break;
      case "YZX":
        this._z = Math.asin(s(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-u, d), this._y = Math.atan2(-p, a)) : (this._x = 0, this._y = Math.atan2(c, m));
        break;
      case "XZY":
        this._z = Math.asin(-s(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(f, d), this._y = Math.atan2(c, a)) : (this._x = Math.atan2(-u, m), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, r !== !1 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, r) {
    return Up.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Up, n, r);
  }
  setFromVector3(e, n) {
    return this.set(e.x, e.y, e.z, n || this._order);
  }
  reorder(e) {
    return Hp.setFromEuler(this), this.setFromQuaternion(Hp, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  toVector3(e) {
    return e ? e.set(this._x, this._y, this._z) : new z(this._x, this._y, this._z);
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
};
Xf.DefaultOrder = "XYZ";
Xf.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
const Up = /* @__PURE__ */ new Je(), Hp = /* @__PURE__ */ new bn();
let py = class {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = 1 << e | 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
}, S_ = 0;
const Gp = new z(), Ds = new bn(), Gi = new Je(), $l = new z(), la = new z(), E_ = new z(), T_ = new bn(), Vp = new z(1, 0, 0), kp = new z(0, 1, 0), Wp = new z(0, 0, 1), A_ = { type: "added" }, $p = { type: "removed" };
function He() {
  Object.defineProperty(this, "id", { value: S_++ }), this.uuid = $e.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = He.DefaultUp.clone();
  const t = new z(), e = new Xf(), n = new bn(), r = new z(1, 1, 1);
  function s() {
    n.setFromEuler(e, !1);
  }
  function o() {
    e.setFromQuaternion(n, void 0, !1);
  }
  e._onChange(s), n._onChange(o), Object.defineProperties(this, {
    position: {
      configurable: !0,
      enumerable: !0,
      value: t
    },
    rotation: {
      configurable: !0,
      enumerable: !0,
      value: e
    },
    quaternion: {
      configurable: !0,
      enumerable: !0,
      value: n
    },
    scale: {
      configurable: !0,
      enumerable: !0,
      value: r
    },
    modelViewMatrix: {
      value: new Je()
    },
    normalMatrix: {
      value: new ln()
    }
  }), this.matrix = new Je(), this.matrixWorld = new Je(), this.matrixAutoUpdate = He.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new py(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
}
He.DefaultUp = new z(0, 1, 0);
He.DefaultMatrixAutoUpdate = !0;
He.prototype = Object.assign(Object.create(ar.prototype), {
  constructor: He,
  isObject3D: !0,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(t) {
    return this.quaternion.premultiply(t), this;
  },
  setRotationFromAxisAngle: function(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  },
  setRotationFromEuler: function(t) {
    this.quaternion.setFromEuler(t, !0);
  },
  setRotationFromMatrix: function(t) {
    this.quaternion.setFromRotationMatrix(t);
  },
  setRotationFromQuaternion: function(t) {
    this.quaternion.copy(t);
  },
  rotateOnAxis: function(t, e) {
    return Ds.setFromAxisAngle(t, e), this.quaternion.multiply(Ds), this;
  },
  rotateOnWorldAxis: function(t, e) {
    return Ds.setFromAxisAngle(t, e), this.quaternion.premultiply(Ds), this;
  },
  rotateX: function(t) {
    return this.rotateOnAxis(Vp, t);
  },
  rotateY: function(t) {
    return this.rotateOnAxis(kp, t);
  },
  rotateZ: function(t) {
    return this.rotateOnAxis(Wp, t);
  },
  translateOnAxis: function(t, e) {
    return Gp.copy(t).applyQuaternion(this.quaternion), this.position.add(Gp.multiplyScalar(e)), this;
  },
  translateX: function(t) {
    return this.translateOnAxis(Vp, t);
  },
  translateY: function(t) {
    return this.translateOnAxis(kp, t);
  },
  translateZ: function(t) {
    return this.translateOnAxis(Wp, t);
  },
  localToWorld: function(t) {
    return t.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(t) {
    return t.applyMatrix4(Gi.copy(this.matrixWorld).invert());
  },
  lookAt: function(t, e, n) {
    t.isVector3 ? $l.copy(t) : $l.set(t, e, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), la.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Gi.lookAt(la, $l, this.up) : Gi.lookAt($l, la, this.up), this.quaternion.setFromRotationMatrix(Gi), r && (Gi.extractRotation(r.matrixWorld), Ds.setFromRotationMatrix(Gi), this.quaternion.premultiply(Ds.invert()));
  },
  add: function(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(A_)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  },
  remove: function(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent($p)), this;
  },
  clear: function() {
    for (let t = 0; t < this.children.length; t++) {
      const e = this.children[t];
      e.parent = null, e.dispatchEvent($p);
    }
    return this.children.length = 0, this;
  },
  attach: function(t) {
    return this.updateWorldMatrix(!0, !1), Gi.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), Gi.multiply(t.parent.matrixWorld)), t.applyMatrix4(Gi), t.updateWorldMatrix(!1, !1), this.add(t), this;
  },
  getObjectById: function(t) {
    return this.getObjectByProperty("id", t);
  },
  getObjectByName: function(t) {
    return this.getObjectByProperty("name", t);
  },
  getObjectByProperty: function(t, e) {
    if (this[t] === e) return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const o = this.children[n].getObjectByProperty(t, e);
      if (o !== void 0)
        return o;
    }
  },
  getWorldPosition: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new z()), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new bn()), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(la, t, E_), t;
  },
  getWorldScale: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new z()), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(la, T_, t), t;
  },
  getWorldDirection: function(t) {
    t === void 0 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new z()), this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(t) {
    t(this);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++)
      e[n].traverse(t);
  },
  traverseVisible: function(t) {
    if (this.visible === !1) return;
    t(this);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++)
      e[n].traverseVisible(t);
  },
  traverseAncestors: function(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++)
      e[n].updateMatrixWorld(t);
  },
  updateWorldMatrix: function(t, e) {
    const n = this.parent;
    if (t === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++)
        r[s].updateWorldMatrix(!1, !0);
    }
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string", n = {};
    e && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {}
    }, n.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON());
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(t)), l.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(t.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const d = l[c];
            s(t.shapes, d);
          }
        else
          s(t.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(t.materials, this.material[l]));
        r.material = a;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(t.animations, l));
      }
    }
    if (e) {
      const a = o(t.geometries), l = o(t.materials), c = o(t.textures), h = o(t.images), d = o(t.shapes), u = o(t.skeletons), p = o(t.animations);
      a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), u.length > 0 && (n.skeletons = u), p.length > 0 && (n.animations = p);
    }
    return n.object = r, n;
    function o(a) {
      const l = [];
      for (const c in a) {
        const h = a[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  },
  clone: function(t) {
    return new this.constructor().copy(this, t);
  },
  copy: function(t, e = !0) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
      for (let n = 0; n < t.children.length; n++) {
        const r = t.children[n];
        this.add(r.clone());
      }
    return this;
  }
});
const wu = /* @__PURE__ */ new z(), L_ = /* @__PURE__ */ new z(), C_ = /* @__PURE__ */ new ln();
let ti = class {
  constructor(e, n) {
    Object.defineProperty(this, "isPlane", { value: !0 }), this.normal = e !== void 0 ? e : new z(1, 0, 0), this.constant = n !== void 0 ? n : 0;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, r, s) {
    return this.normal.set(e, n, r), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, r) {
    const s = wu.subVectors(r, n).cross(L_.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), n = new z()), n.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, n) {
    n === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new z());
    const r = e.delta(wu), s = this.normal.dot(r);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : void 0;
    const o = -(e.start.dot(this.normal) + this.constant) / s;
    if (!(o < 0 || o > 1))
      return n.copy(r).multiplyScalar(o).add(e.start);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return n < 0 && r > 0 || r < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new z()), e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const r = n || C_.getNormalMatrix(e), s = this.coplanarPoint(wu).applyMatrix4(e), o = this.normal.applyMatrix3(r).normalize();
    return this.constant = -s.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
};
const qn = /* @__PURE__ */ new z(), Vi = /* @__PURE__ */ new z(), Mu = /* @__PURE__ */ new z(), ki = /* @__PURE__ */ new z(), Ns = /* @__PURE__ */ new z(), Os = /* @__PURE__ */ new z(), jp = /* @__PURE__ */ new z(), Su = /* @__PURE__ */ new z(), Eu = /* @__PURE__ */ new z(), Tu = /* @__PURE__ */ new z();
let oi = class ao {
  constructor(e, n, r) {
    this.a = e !== void 0 ? e : new z(), this.b = n !== void 0 ? n : new z(), this.c = r !== void 0 ? r : new z();
  }
  static getNormal(e, n, r, s) {
    s === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), s = new z()), s.subVectors(r, n), qn.subVectors(e, n), s.cross(qn);
    const o = s.lengthSq();
    return o > 0 ? s.multiplyScalar(1 / Math.sqrt(o)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, n, r, s, o) {
    qn.subVectors(s, n), Vi.subVectors(r, n), Mu.subVectors(e, n);
    const a = qn.dot(qn), l = qn.dot(Vi), c = qn.dot(Mu), h = Vi.dot(Vi), d = Vi.dot(Mu), u = a * h - l * l;
    if (o === void 0 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), o = new z()), u === 0)
      return o.set(-2, -1, -1);
    const p = 1 / u, f = (h * c - l * d) * p, m = (a * d - l * c) * p;
    return o.set(1 - f - m, m, f);
  }
  static containsPoint(e, n, r, s) {
    return this.getBarycoord(e, n, r, s, ki), ki.x >= 0 && ki.y >= 0 && ki.x + ki.y <= 1;
  }
  static getUV(e, n, r, s, o, a, l, c) {
    return this.getBarycoord(e, n, r, s, ki), c.set(0, 0), c.addScaledVector(o, ki.x), c.addScaledVector(a, ki.y), c.addScaledVector(l, ki.z), c;
  }
  static isFrontFacing(e, n, r, s) {
    return qn.subVectors(r, n), Vi.subVectors(e, n), qn.cross(Vi).dot(s) < 0;
  }
  set(e, n, r) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, n, r, s) {
    return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[s]), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return qn.subVectors(this.c, this.b), Vi.subVectors(this.a, this.b), qn.cross(Vi).length() * 0.5;
  }
  getMidpoint(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new z()), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ao.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new ti()), e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return ao.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getUV(e, n, r, s, o) {
    return ao.getUV(e, this.a, this.b, this.c, n, r, s, o);
  }
  containsPoint(e) {
    return ao.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ao.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    n === void 0 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), n = new z());
    const r = this.a, s = this.b, o = this.c;
    let a, l;
    Ns.subVectors(s, r), Os.subVectors(o, r), Su.subVectors(e, r);
    const c = Ns.dot(Su), h = Os.dot(Su);
    if (c <= 0 && h <= 0)
      return n.copy(r);
    Eu.subVectors(e, s);
    const d = Ns.dot(Eu), u = Os.dot(Eu);
    if (d >= 0 && u <= d)
      return n.copy(s);
    const p = c * u - d * h;
    if (p <= 0 && c >= 0 && d <= 0)
      return a = c / (c - d), n.copy(r).addScaledVector(Ns, a);
    Tu.subVectors(e, o);
    const f = Ns.dot(Tu), m = Os.dot(Tu);
    if (m >= 0 && f <= m)
      return n.copy(o);
    const y = f * h - c * m;
    if (y <= 0 && h >= 0 && m <= 0)
      return l = h / (h - m), n.copy(r).addScaledVector(Os, l);
    const x = d * m - f * u;
    if (x <= 0 && u - d >= 0 && f - m >= 0)
      return jp.subVectors(o, s), l = (u - d) / (u - d + (f - m)), n.copy(s).addScaledVector(jp, l);
    const v = 1 / (x + y + p);
    return a = y * v, l = p * v, n.copy(r).addScaledVector(Ns, a).addScaledVector(Os, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
};
const my = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Xn = { h: 0, s: 0, l: 0 }, jl = { h: 0, s: 0, l: 0 };
function Au(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t;
}
function Lu(t) {
  return t < 0.04045 ? t * 0.0773993808 : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function Cu(t) {
  return t < 31308e-7 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
let Ne = class {
  constructor(e, n, r) {
    return Object.defineProperty(this, "isColor", { value: !0 }), n === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, n, r);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  }
  setRGB(e, n, r) {
    return this.r = e, this.g = n, this.b = r, this;
  }
  setHSL(e, n, r) {
    if (e = $e.euclideanModulo(e, 1), n = $e.clamp(n, 0, 1), r = $e.clamp(r, 0, 1), n === 0)
      this.r = this.g = this.b = r;
    else {
      const s = r <= 0.5 ? r * (1 + n) : r + n - r * n, o = 2 * r - s;
      this.r = Au(o, s, e + 1 / 3), this.g = Au(o, s, e), this.b = Au(o, s, e - 1 / 3);
    }
    return this;
  }
  setStyle(e) {
    function n(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
      let s;
      const o = r[1], a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (s = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, n(s[4]), this;
          if (s = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, n(s[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
            const l = parseFloat(s[1]) / 360, c = parseInt(s[2], 10) / 100, h = parseInt(s[3], 10) / 100;
            return n(s[4]), this.setHSL(l, c, h);
          }
          break;
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = r[1], o = s.length;
      if (o === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, this;
      if (o === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, this;
    }
    return e && e.length > 0 ? this.setColorName(e) : this;
  }
  setColorName(e) {
    const n = my[e];
    return n !== void 0 ? this.setHex(n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copyGammaToLinear(e, n = 2) {
    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this;
  }
  copyLinearToGamma(e, n = 2) {
    const r = n > 0 ? 1 / n : 1;
    return this.r = Math.pow(e.r, r), this.g = Math.pow(e.g, r), this.b = Math.pow(e.b, r), this;
  }
  convertGammaToLinear(e) {
    return this.copyGammaToLinear(this, e), this;
  }
  convertLinearToGamma(e) {
    return this.copyLinearToGamma(this, e), this;
  }
  copySRGBToLinear(e) {
    return this.r = Lu(e.r), this.g = Lu(e.g), this.b = Lu(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Cu(e.r), this.g = Cu(e.g), this.b = Cu(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(e) {
    e === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 });
    const n = this.r, r = this.g, s = this.b, o = Math.max(n, r, s), a = Math.min(n, r, s);
    let l, c;
    const h = (a + o) / 2;
    if (a === o)
      l = 0, c = 0;
    else {
      const d = o - a;
      switch (c = h <= 0.5 ? d / (o + a) : d / (2 - o - a), o) {
        case n:
          l = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - n) / d + 2;
          break;
        case s:
          l = (n - r) / d + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = h, e;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(e, n, r) {
    return this.getHSL(Xn), Xn.h += e, Xn.s += n, Xn.l += r, this.setHSL(Xn.h, Xn.s, Xn.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpHSL(e, n) {
    this.getHSL(Xn), e.getHSL(jl);
    const r = $e.lerp(Xn.h, jl.h, n), s = $e.lerp(Xn.s, jl.s, n), o = $e.lerp(Xn.l, jl.l, n);
    return this.setHSL(r, s, o), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
};
Ne.NAMES = my;
Ne.prototype.r = 1;
Ne.prototype.g = 1;
Ne.prototype.b = 1;
let gh = class {
  constructor(e, n, r, s, o, a = 0) {
    this.a = e, this.b = n, this.c = r, this.normal = s && s.isVector3 ? s : new z(), this.vertexNormals = Array.isArray(s) ? s : [], this.color = o && o.isColor ? o : new Ne(), this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = a;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
    for (let n = 0, r = e.vertexNormals.length; n < r; n++)
      this.vertexNormals[n] = e.vertexNormals[n].clone();
    for (let n = 0, r = e.vertexColors.length; n < r; n++)
      this.vertexColors[n] = e.vertexColors[n].clone();
    return this;
  }
}, R_ = 0;
function Ve() {
  Object.defineProperty(this, "id", { value: R_++ }), this.uuid = $e.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = Da, this.side = Pl, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = ay, this.blendDst = ly, this.blendEquation = oo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Md, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = x_, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = pu, this.stencilZFail = pu, this.stencilZPass = pu, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
}
Ve.prototype = Object.assign(Object.create(ar.prototype), {
  constructor: Ve,
  isMaterial: !0,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue;
        }
        if (e === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === oy;
          continue;
        }
        const r = this[e];
        if (r === void 0) {
          console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
          continue;
        }
        r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n;
      }
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, this.combine !== void 0 && (n.combine = this.combine), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.size !== void 0 && (n.size = this.size), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Da && (n.blending = this.blending), this.flatShading === !0 && (n.flatShading = this.flatShading), this.side !== Pl && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (n.morphTargets = !0), this.morphNormals === !0 && (n.morphNormals = !0), this.skinning === !0 && (n.skinning = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (e) {
      const s = r(t.textures), o = r(t.images);
      s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o);
    }
    return n;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const r = e.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s)
        n[s] = e[s].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
Object.defineProperty(Ve.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
function Fn(t) {
  Ve.call(this), this.type = "MeshBasicMaterial", this.color = new Ne(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Zh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t);
}
Fn.prototype = Object.create(Ve.prototype);
Fn.prototype.constructor = Fn;
Fn.prototype.isMeshBasicMaterial = !0;
Fn.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
};
const mt = new z(), ql = new ye();
function We(t, e, n) {
  if (Array.isArray(t))
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n === !0, this.usage = Jh, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(We.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
Object.assign(We.prototype, {
  isBufferAttribute: !0,
  onUploadCallback: function() {
  },
  setUsage: function(t) {
    return this.usage = t, this;
  },
  copy: function(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
  },
  copyAt: function(t, e, n) {
    t *= this.itemSize, n *= e.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[t + r] = e.array[n + r];
    return this;
  },
  copyArray: function(t) {
    return this.array.set(t), this;
  },
  copyColorsArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      let o = t[r];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new Ne()), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b;
    }
    return this;
  },
  copyVector2sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      let o = t[r];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new ye()), e[n++] = o.x, e[n++] = o.y;
    }
    return this;
  },
  copyVector3sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      let o = t[r];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new z()), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z;
    }
    return this;
  },
  copyVector4sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      let o = t[r];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new ht()), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w;
    }
    return this;
  },
  applyMatrix3: function(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        ql.fromBufferAttribute(this, e), ql.applyMatrix3(t), this.setXY(e, ql.x, ql.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        mt.fromBufferAttribute(this, e), mt.applyMatrix3(t), this.setXYZ(e, mt.x, mt.y, mt.z);
    return this;
  },
  applyMatrix4: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      mt.x = this.getX(e), mt.y = this.getY(e), mt.z = this.getZ(e), mt.applyMatrix4(t), this.setXYZ(e, mt.x, mt.y, mt.z);
    return this;
  },
  applyNormalMatrix: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      mt.x = this.getX(e), mt.y = this.getY(e), mt.z = this.getZ(e), mt.applyNormalMatrix(t), this.setXYZ(e, mt.x, mt.y, mt.z);
    return this;
  },
  transformDirection: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      mt.x = this.getX(e), mt.y = this.getY(e), mt.z = this.getZ(e), mt.transformDirection(t), this.setXYZ(e, mt.x, mt.y, mt.z);
    return this;
  },
  set: function(t, e = 0) {
    return this.array.set(t, e), this;
  },
  getX: function(t) {
    return this.array[t * this.itemSize];
  },
  setX: function(t, e) {
    return this.array[t * this.itemSize] = e, this;
  },
  getY: function(t) {
    return this.array[t * this.itemSize + 1];
  },
  setY: function(t, e) {
    return this.array[t * this.itemSize + 1] = e, this;
  },
  getZ: function(t) {
    return this.array[t * this.itemSize + 2];
  },
  setZ: function(t, e) {
    return this.array[t * this.itemSize + 2] = e, this;
  },
  getW: function(t) {
    return this.array[t * this.itemSize + 3];
  },
  setW: function(t, e) {
    return this.array[t * this.itemSize + 3] = e, this;
  },
  setXY: function(t, e, n) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this;
  },
  setXYZ: function(t, e, n, r) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this;
  },
  setXYZW: function(t, e, n, r, s) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = s, this;
  },
  onUpload: function(t) {
    return this.onUploadCallback = t, this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function Td(t, e, n) {
  We.call(this, new Int8Array(t), e, n);
}
Td.prototype = Object.create(We.prototype);
Td.prototype.constructor = Td;
function Ad(t, e, n) {
  We.call(this, new Uint8Array(t), e, n);
}
Ad.prototype = Object.create(We.prototype);
Ad.prototype.constructor = Ad;
function Ld(t, e, n) {
  We.call(this, new Uint8ClampedArray(t), e, n);
}
Ld.prototype = Object.create(We.prototype);
Ld.prototype.constructor = Ld;
function Cd(t, e, n) {
  We.call(this, new Int16Array(t), e, n);
}
Cd.prototype = Object.create(We.prototype);
Cd.prototype.constructor = Cd;
function Ka(t, e, n) {
  We.call(this, new Uint16Array(t), e, n);
}
Ka.prototype = Object.create(We.prototype);
Ka.prototype.constructor = Ka;
function Rd(t, e, n) {
  We.call(this, new Int32Array(t), e, n);
}
Rd.prototype = Object.create(We.prototype);
Rd.prototype.constructor = Rd;
function Qa(t, e, n) {
  We.call(this, new Uint32Array(t), e, n);
}
Qa.prototype = Object.create(We.prototype);
Qa.prototype.constructor = Qa;
function vh(t, e, n) {
  We.call(this, new Uint16Array(t), e, n);
}
vh.prototype = Object.create(We.prototype);
vh.prototype.constructor = vh;
vh.prototype.isFloat16BufferAttribute = !0;
function Ke(t, e, n) {
  We.call(this, new Float32Array(t), e, n);
}
Ke.prototype = Object.create(We.prototype);
Ke.prototype.constructor = Ke;
function Pd(t, e, n) {
  We.call(this, new Float64Array(t), e, n);
}
Pd.prototype = Object.create(We.prototype);
Pd.prototype.constructor = Pd;
let P_ = class {
  constructor() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
  }
  computeGroups(e) {
    const n = [];
    let r, s, o;
    const a = e.faces;
    for (s = 0; s < a.length; s++) {
      const l = a[s];
      l.materialIndex !== o && (o = l.materialIndex, r !== void 0 && (r.count = s * 3 - r.start, n.push(r)), r = {
        start: s * 3,
        materialIndex: o
      });
    }
    r !== void 0 && (r.count = s * 3 - r.start, n.push(r)), this.groups = n;
  }
  fromGeometry(e) {
    const n = e.faces, r = e.vertices, s = e.faceVertexUvs, o = s[0] && s[0].length > 0, a = s[1] && s[1].length > 0, l = e.morphTargets, c = l.length;
    let h;
    if (c > 0) {
      h = [];
      for (let v = 0; v < c; v++)
        h[v] = {
          name: l[v].name,
          data: []
        };
      this.morphTargets.position = h;
    }
    const d = e.morphNormals, u = d.length;
    let p;
    if (u > 0) {
      p = [];
      for (let v = 0; v < u; v++)
        p[v] = {
          name: d[v].name,
          data: []
        };
      this.morphTargets.normal = p;
    }
    const f = e.skinIndices, m = e.skinWeights, y = f.length === r.length, x = m.length === r.length;
    r.length > 0 && n.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (let v = 0; v < n.length; v++) {
      const g = n[v];
      this.vertices.push(r[g.a], r[g.b], r[g.c]);
      const S = g.vertexNormals;
      if (S.length === 3)
        this.normals.push(S[0], S[1], S[2]);
      else {
        const E = g.normal;
        this.normals.push(E, E, E);
      }
      const T = g.vertexColors;
      if (T.length === 3)
        this.colors.push(T[0], T[1], T[2]);
      else {
        const E = g.color;
        this.colors.push(E, E, E);
      }
      if (o === !0) {
        const E = s[0][v];
        E !== void 0 ? this.uvs.push(E[0], E[1], E[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", v), this.uvs.push(new ye(), new ye(), new ye()));
      }
      if (a === !0) {
        const E = s[1][v];
        E !== void 0 ? this.uvs2.push(E[0], E[1], E[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", v), this.uvs2.push(new ye(), new ye(), new ye()));
      }
      for (let E = 0; E < c; E++) {
        const w = l[E].vertices;
        h[E].data.push(w[g.a], w[g.b], w[g.c]);
      }
      for (let E = 0; E < u; E++) {
        const w = d[E].vertexNormals[v];
        p[E].data.push(w.a, w.b, w.c);
      }
      y && this.skinIndices.push(f[g.a], f[g.b], f[g.c]), x && this.skinWeights.push(m[g.a], m[g.b], m[g.c]);
    }
    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), this;
  }
};
function gy(t) {
  if (t.length === 0) return -1 / 0;
  let e = t[0];
  for (let n = 1, r = t.length; n < r; ++n)
    t[n] > e && (e = t[n]);
  return e;
}
const I_ = {
  Int8Array,
  Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Xl(t, e) {
  return new I_[t](e);
}
let D_ = 1;
const ui = new Je(), Ru = new He(), Fs = new z(), mn = new kt(), ca = new kt(), It = new z();
function it() {
  Object.defineProperty(this, "id", { value: D_ += 2 }), this.uuid = $e.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
}
it.prototype = Object.assign(Object.create(ar.prototype), {
  constructor: it,
  isBufferGeometry: !0,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(t) {
    return Array.isArray(t) ? this.index = new (gy(t) > 65535 ? Qa : Ka)(t, 1) : this.index = t, this;
  },
  getAttribute: function(t) {
    return this.attributes[t];
  },
  setAttribute: function(t, e) {
    return this.attributes[t] = e, this;
  },
  deleteAttribute: function(t) {
    return delete this.attributes[t], this;
  },
  hasAttribute: function(t) {
    return this.attributes[t] !== void 0;
  },
  addGroup: function(t, e, n = 0) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: n
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  },
  applyMatrix4: function(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new ln().getNormalMatrix(t);
      n.applyNormalMatrix(s), n.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(t), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  },
  rotateX: function(t) {
    return ui.makeRotationX(t), this.applyMatrix4(ui), this;
  },
  rotateY: function(t) {
    return ui.makeRotationY(t), this.applyMatrix4(ui), this;
  },
  rotateZ: function(t) {
    return ui.makeRotationZ(t), this.applyMatrix4(ui), this;
  },
  translate: function(t, e, n) {
    return ui.makeTranslation(t, e, n), this.applyMatrix4(ui), this;
  },
  scale: function(t, e, n) {
    return ui.makeScale(t, e, n), this.applyMatrix4(ui), this;
  },
  lookAt: function(t) {
    return Ru.lookAt(t), Ru.updateMatrix(), this.applyMatrix4(Ru.matrix), this;
  },
  center: function() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Fs).negate(), this.translate(Fs.x, Fs.y, Fs.z), this;
  },
  setFromObject: function(t) {
    const e = t.geometry;
    if (t.isPoints || t.isLine) {
      const n = new Ke(e.vertices.length * 3, 3), r = new Ke(e.colors.length * 3, 3);
      if (this.setAttribute("position", n.copyVector3sArray(e.vertices)), this.setAttribute("color", r.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
        const s = new Ke(e.lineDistances.length, 1);
        this.setAttribute("lineDistance", s.copyArray(e.lineDistances));
      }
      e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone());
    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
    return this;
  },
  setFromPoints: function(t) {
    const e = [];
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ke(e, 3)), this;
  },
  updateFromObject: function(t) {
    let e = t.geometry;
    if (t.isMesh) {
      let n = e.__directGeometry;
      if (e.elementsNeedUpdate === !0 && (n = void 0, e.elementsNeedUpdate = !1), n === void 0)
        return this.fromGeometry(e);
      n.verticesNeedUpdate = e.verticesNeedUpdate, n.normalsNeedUpdate = e.normalsNeedUpdate, n.colorsNeedUpdate = e.colorsNeedUpdate, n.uvsNeedUpdate = e.uvsNeedUpdate, n.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = n;
    }
    if (e.verticesNeedUpdate === !0) {
      const n = this.attributes.position;
      n !== void 0 && (n.copyVector3sArray(e.vertices), n.needsUpdate = !0), e.verticesNeedUpdate = !1;
    }
    if (e.normalsNeedUpdate === !0) {
      const n = this.attributes.normal;
      n !== void 0 && (n.copyVector3sArray(e.normals), n.needsUpdate = !0), e.normalsNeedUpdate = !1;
    }
    if (e.colorsNeedUpdate === !0) {
      const n = this.attributes.color;
      n !== void 0 && (n.copyColorsArray(e.colors), n.needsUpdate = !0), e.colorsNeedUpdate = !1;
    }
    if (e.uvsNeedUpdate) {
      const n = this.attributes.uv;
      n !== void 0 && (n.copyVector2sArray(e.uvs), n.needsUpdate = !0), e.uvsNeedUpdate = !1;
    }
    if (e.lineDistancesNeedUpdate) {
      const n = this.attributes.lineDistance;
      n !== void 0 && (n.copyArray(e.lineDistances), n.needsUpdate = !0), e.lineDistancesNeedUpdate = !1;
    }
    return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
  },
  fromGeometry: function(t) {
    return t.__directGeometry = new P_().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
  },
  fromDirectGeometry: function(t) {
    const e = new Float32Array(t.vertices.length * 3);
    if (this.setAttribute("position", new We(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
      const n = new Float32Array(t.normals.length * 3);
      this.setAttribute("normal", new We(n, 3).copyVector3sArray(t.normals));
    }
    if (t.colors.length > 0) {
      const n = new Float32Array(t.colors.length * 3);
      this.setAttribute("color", new We(n, 3).copyColorsArray(t.colors));
    }
    if (t.uvs.length > 0) {
      const n = new Float32Array(t.uvs.length * 2);
      this.setAttribute("uv", new We(n, 2).copyVector2sArray(t.uvs));
    }
    if (t.uvs2.length > 0) {
      const n = new Float32Array(t.uvs2.length * 2);
      this.setAttribute("uv2", new We(n, 2).copyVector2sArray(t.uvs2));
    }
    this.groups = t.groups;
    for (const n in t.morphTargets) {
      const r = [], s = t.morphTargets[n];
      for (let o = 0, a = s.length; o < a; o++) {
        const l = s[o], c = new Ke(l.data.length * 3, 3);
        c.name = l.name, r.push(c.copyVector3sArray(l.data));
      }
      this.morphAttributes[n] = r;
    }
    if (t.skinIndices.length > 0) {
      const n = new Ke(t.skinIndices.length * 4, 4);
      this.setAttribute("skinIndex", n.copyVector4sArray(t.skinIndices));
    }
    if (t.skinWeights.length > 0) {
      const n = new Ke(t.skinWeights.length * 4, 4);
      this.setAttribute("skinWeight", n.copyVector4sArray(t.skinWeights));
    }
    return t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new kt());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new z(-1 / 0, -1 / 0, -1 / 0),
        new z(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e)
        for (let n = 0, r = e.length; n < r; n++) {
          const s = e[n];
          mn.setFromBufferAttribute(s), this.morphTargetsRelative ? (It.addVectors(this.boundingBox.min, mn.min), this.boundingBox.expandByPoint(It), It.addVectors(this.boundingBox.max, mn.max), this.boundingBox.expandByPoint(It)) : (this.boundingBox.expandByPoint(mn.min), this.boundingBox.expandByPoint(mn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new hi());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new z(), 1 / 0);
      return;
    }
    if (t) {
      const n = this.boundingSphere.center;
      if (mn.setFromBufferAttribute(t), e)
        for (let s = 0, o = e.length; s < o; s++) {
          const a = e[s];
          ca.setFromBufferAttribute(a), this.morphTargetsRelative ? (It.addVectors(mn.min, ca.min), mn.expandByPoint(It), It.addVectors(mn.max, ca.max), mn.expandByPoint(It)) : (mn.expandByPoint(ca.min), mn.expandByPoint(ca.max));
        }
      mn.getCenter(n);
      let r = 0;
      for (let s = 0, o = t.count; s < o; s++)
        It.fromBufferAttribute(t, s), r = Math.max(r, n.distanceToSquared(It));
      if (e)
        for (let s = 0, o = e.length; s < o; s++) {
          const a = e[s], l = this.morphTargetsRelative;
          for (let c = 0, h = a.count; c < h; c++)
            It.fromBufferAttribute(a, c), l && (Fs.fromBufferAttribute(t, c), It.add(Fs)), r = Math.max(r, n.distanceToSquared(It));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    const t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new We(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let u = 0, p = n.count; u < p; u++)
          n.setXYZ(u, 0, 0, 0);
      const r = new z(), s = new z(), o = new z(), a = new z(), l = new z(), c = new z(), h = new z(), d = new z();
      if (t)
        for (let u = 0, p = t.count; u < p; u += 3) {
          const f = t.getX(u + 0), m = t.getX(u + 1), y = t.getX(u + 2);
          r.fromBufferAttribute(e, f), s.fromBufferAttribute(e, m), o.fromBufferAttribute(e, y), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), a.fromBufferAttribute(n, f), l.fromBufferAttribute(n, m), c.fromBufferAttribute(n, y), a.add(h), l.add(h), c.add(h), n.setXYZ(f, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let u = 0, p = e.count; u < p; u += 3)
          r.fromBufferAttribute(e, u + 0), s.fromBufferAttribute(e, u + 1), o.fromBufferAttribute(e, u + 2), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), n.setXYZ(u + 0, h.x, h.y, h.z), n.setXYZ(u + 1, h.x, h.y, h.z), n.setXYZ(u + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  },
  merge: function(t, e) {
    if (!(t && t.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
      return;
    }
    e === void 0 && (e = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    const n = this.attributes;
    for (const r in n) {
      if (t.attributes[r] === void 0) continue;
      const o = n[r].array, a = t.attributes[r], l = a.array, c = a.itemSize * e, h = Math.min(l.length, o.length - c);
      for (let d = 0, u = c; d < h; d++, u++)
        o[u] = l[d];
    }
    return this;
  },
  normalizeNormals: function() {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      It.fromBufferAttribute(t, e), It.normalize(), t.setXYZ(e, It.x, It.y, It.z);
  },
  toNonIndexed: function() {
    function t(a, l) {
      const c = a.array, h = a.itemSize, d = a.normalized, u = new c.constructor(l.length * h);
      let p = 0, f = 0;
      for (let m = 0, y = l.length; m < y; m++) {
        p = l[m] * h;
        for (let x = 0; x < h; x++)
          u[f++] = c[p++];
      }
      return new We(u, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    const e = new it(), n = this.index.array, r = this.attributes;
    for (const a in r) {
      const l = r[a], c = t(l, n);
      e.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [], c = s[a];
      for (let h = 0, d = c.length; h < d; h++) {
        const u = c[h], p = t(u, n);
        l.push(p);
      }
      e.morphAttributes[a] = l;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      e.addGroup(c.start, c.count, c.materialIndex);
    }
    return e;
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (t[c] = l[c]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null && (t.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l], h = c.toJSON(t.data);
      c.name !== "" && (h.name = c.name), t.data.attributes[l] = h;
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], h = [];
      for (let d = 0, u = c.length; d < u; d++) {
        const p = c[d], f = p.toJSON(t.data);
        p.name !== "" && (f.name = p.name), h.push(f);
      }
      h.length > 0 && (r[l] = h, s = !0);
    }
    s && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (t.data.boundingSphere = {
      center: a.center.toArray(),
      radius: a.radius
    }), t;
  },
  clone: function() {
    return new it().copy(this);
  },
  copy: function(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone(e));
    const r = t.attributes;
    for (const c in r) {
      const h = r[c];
      this.setAttribute(c, h.clone(e));
    }
    const s = t.morphAttributes;
    for (const c in s) {
      const h = [], d = s[c];
      for (let u = 0, p = d.length; u < p; u++)
        h.push(d[u].clone(e));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const o = t.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = t.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = t.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
const qp = new Je(), ss = new Nl(), Pu = new hi(), mr = new z(), gr = new z(), vr = new z(), Iu = new z(), Du = new z(), Nu = new z(), Yl = new z(), Zl = new z(), Jl = new z(), uo = new ye(), fo = new ye(), po = new ye(), Ba = new z(), Kl = new z();
function Tt(t = new it(), e = new Fn()) {
  He.call(this), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
}
Tt.prototype = Object.assign(Object.create(He.prototype), {
  constructor: Tt,
  isMesh: !0,
  copy: function(t) {
    return He.prototype.copy.call(this, t), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const r = e[n[0]];
        if (r !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  raycast: function(t, e) {
    const n = this.geometry, r = this.material, s = this.matrixWorld;
    if (r === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), Pu.copy(n.boundingSphere), Pu.applyMatrix4(s), t.ray.intersectsSphere(Pu) === !1) || (qp.copy(s).invert(), ss.copy(t.ray).applyMatrix4(qp), n.boundingBox !== null && ss.intersectsBox(n.boundingBox) === !1))
      return;
    let o;
    if (n.isBufferGeometry) {
      const a = n.index, l = n.attributes.position, c = n.morphAttributes.position, h = n.morphTargetsRelative, d = n.attributes.uv, u = n.attributes.uv2, p = n.groups, f = n.drawRange;
      if (a !== null)
        if (Array.isArray(r))
          for (let m = 0, y = p.length; m < y; m++) {
            const x = p[m], v = r[x.materialIndex], g = Math.max(x.start, f.start), S = Math.min(x.start + x.count, f.start + f.count);
            for (let T = g, E = S; T < E; T += 3) {
              const w = a.getX(T), C = a.getX(T + 1), ee = a.getX(T + 2);
              o = Ql(this, v, t, ss, l, c, h, d, u, w, C, ee), o && (o.faceIndex = Math.floor(T / 3), o.face.materialIndex = x.materialIndex, e.push(o));
            }
          }
        else {
          const m = Math.max(0, f.start), y = Math.min(a.count, f.start + f.count);
          for (let x = m, v = y; x < v; x += 3) {
            const g = a.getX(x), S = a.getX(x + 1), T = a.getX(x + 2);
            o = Ql(this, r, t, ss, l, c, h, d, u, g, S, T), o && (o.faceIndex = Math.floor(x / 3), e.push(o));
          }
        }
      else if (l !== void 0)
        if (Array.isArray(r))
          for (let m = 0, y = p.length; m < y; m++) {
            const x = p[m], v = r[x.materialIndex], g = Math.max(x.start, f.start), S = Math.min(x.start + x.count, f.start + f.count);
            for (let T = g, E = S; T < E; T += 3) {
              const w = T, C = T + 1, ee = T + 2;
              o = Ql(this, v, t, ss, l, c, h, d, u, w, C, ee), o && (o.faceIndex = Math.floor(T / 3), o.face.materialIndex = x.materialIndex, e.push(o));
            }
          }
        else {
          const m = Math.max(0, f.start), y = Math.min(l.count, f.start + f.count);
          for (let x = m, v = y; x < v; x += 3) {
            const g = x, S = x + 1, T = x + 2;
            o = Ql(this, r, t, ss, l, c, h, d, u, g, S, T), o && (o.faceIndex = Math.floor(x / 3), e.push(o));
          }
        }
    } else if (n.isGeometry) {
      const a = Array.isArray(r), l = n.vertices, c = n.faces;
      let h;
      const d = n.faceVertexUvs[0];
      d.length > 0 && (h = d);
      for (let u = 0, p = c.length; u < p; u++) {
        const f = c[u], m = a ? r[f.materialIndex] : r;
        if (m === void 0) continue;
        const y = l[f.a], x = l[f.b], v = l[f.c];
        if (o = vy(this, m, t, ss, y, x, v, Ba), o) {
          if (h && h[u]) {
            const g = h[u];
            uo.copy(g[0]), fo.copy(g[1]), po.copy(g[2]), o.uv = oi.getUV(Ba, y, x, v, uo, fo, po, new ye());
          }
          o.face = f, o.faceIndex = u, e.push(o);
        }
      }
    }
  }
});
function vy(t, e, n, r, s, o, a, l) {
  let c;
  if (e.side === Ut ? c = r.intersectTriangle(a, o, s, !0, l) : c = r.intersectTriangle(s, o, a, e.side !== Zo, l), c === null) return null;
  Kl.copy(l), Kl.applyMatrix4(t.matrixWorld);
  const h = n.ray.origin.distanceTo(Kl);
  return h < n.near || h > n.far ? null : {
    distance: h,
    point: Kl.clone(),
    object: t
  };
}
function Ql(t, e, n, r, s, o, a, l, c, h, d, u) {
  mr.fromBufferAttribute(s, h), gr.fromBufferAttribute(s, d), vr.fromBufferAttribute(s, u);
  const p = t.morphTargetInfluences;
  if (e.morphTargets && o && p) {
    Yl.set(0, 0, 0), Zl.set(0, 0, 0), Jl.set(0, 0, 0);
    for (let m = 0, y = o.length; m < y; m++) {
      const x = p[m], v = o[m];
      x !== 0 && (Iu.fromBufferAttribute(v, h), Du.fromBufferAttribute(v, d), Nu.fromBufferAttribute(v, u), a ? (Yl.addScaledVector(Iu, x), Zl.addScaledVector(Du, x), Jl.addScaledVector(Nu, x)) : (Yl.addScaledVector(Iu.sub(mr), x), Zl.addScaledVector(Du.sub(gr), x), Jl.addScaledVector(Nu.sub(vr), x)));
    }
    mr.add(Yl), gr.add(Zl), vr.add(Jl);
  }
  t.isSkinnedMesh && (t.boneTransform(h, mr), t.boneTransform(d, gr), t.boneTransform(u, vr));
  const f = vy(t, e, n, r, mr, gr, vr, Ba);
  if (f) {
    l && (uo.fromBufferAttribute(l, h), fo.fromBufferAttribute(l, d), po.fromBufferAttribute(l, u), f.uv = oi.getUV(Ba, mr, gr, vr, uo, fo, po, new ye())), c && (uo.fromBufferAttribute(c, h), fo.fromBufferAttribute(c, d), po.fromBufferAttribute(c, u), f.uv2 = oi.getUV(Ba, mr, gr, vr, uo, fo, po, new ye()));
    const m = new gh(h, d, u);
    oi.getNormal(mr, gr, vr, m.normal), f.face = m;
  }
  return f;
}
let Yf = class extends it {
  constructor(e = 1, n = 1, r = 1, s = 1, o = 1, a = 1) {
    super(), this.type = "BoxBufferGeometry", this.parameters = {
      width: e,
      height: n,
      depth: r,
      widthSegments: s,
      heightSegments: o,
      depthSegments: a
    };
    const l = this;
    s = Math.floor(s), o = Math.floor(o), a = Math.floor(a);
    const c = [], h = [], d = [], u = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, r, n, e, a, o, 0), m("z", "y", "x", 1, -1, r, n, -e, a, o, 1), m("x", "z", "y", 1, 1, e, r, n, s, a, 2), m("x", "z", "y", 1, -1, e, r, -n, s, a, 3), m("x", "y", "z", 1, -1, e, n, r, s, o, 4), m("x", "y", "z", -1, -1, e, n, -r, s, o, 5), this.setIndex(c), this.setAttribute("position", new Ke(h, 3)), this.setAttribute("normal", new Ke(d, 3)), this.setAttribute("uv", new Ke(u, 2));
    function m(y, x, v, g, S, T, E, w, C, ee, Y) {
      const le = T / C, B = E / ee, Z = T / 2, k = E / 2, O = w / 2, P = C + 1, j = ee + 1;
      let re = 0, ae = 0;
      const ce = new z();
      for (let pe = 0; pe < j; pe++) {
        const de = pe * B - k;
        for (let ge = 0; ge < P; ge++) {
          const we = ge * le - Z;
          ce[y] = we * g, ce[x] = de * S, ce[v] = O, h.push(ce.x, ce.y, ce.z), ce[y] = 0, ce[x] = 0, ce[v] = w > 0 ? 1 : -1, d.push(ce.x, ce.y, ce.z), u.push(ge / C), u.push(1 - pe / ee), re += 1;
        }
      }
      for (let pe = 0; pe < ee; pe++)
        for (let de = 0; de < C; de++) {
          const ge = p + de + P * pe, we = p + de + P * (pe + 1), Ge = p + (de + 1) + P * (pe + 1), te = p + (de + 1) + P * pe;
          c.push(ge, we, te), c.push(we, Ge, te), ae += 6;
        }
      l.addGroup(f, ae, Y), f += ae, p += re;
    }
  }
};
function Ao(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const r in t[n]) {
      const s = t[n][r];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture) ? e[n][r] = s.clone() : Array.isArray(s) ? e[n][r] = s.slice() : e[n][r] = s;
    }
  }
  return e;
}
function $t(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const r = Ao(t[n]);
    for (const s in r)
      e[s] = r[s];
  }
  return e;
}
const yy = { clone: Ao, merge: $t };
var N_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, O_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
function rn(t) {
  Ve.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = N_, this.fragmentShader = O_, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
    derivatives: !1,
    // set to use derivatives
    fragDepth: !1,
    // set to use fragment depth values
    drawBuffers: !1,
    // set to use draw buffers
    shaderTextureLOD: !1
    // set to use shader texture LOD
  }, this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && (t.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
}
rn.prototype = Object.create(Ve.prototype);
rn.prototype.constructor = rn;
rn.prototype.isShaderMaterial = !0;
rn.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ao(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
};
rn.prototype.toJSON = function(t) {
  const e = Ve.prototype.toJSON.call(this, t);
  e.glslVersion = this.glslVersion, e.uniforms = {};
  for (const r in this.uniforms) {
    const o = this.uniforms[r].value;
    o && o.isTexture ? e.uniforms[r] = {
      type: "t",
      value: o.toJSON(t).uuid
    } : o && o.isColor ? e.uniforms[r] = {
      type: "c",
      value: o.getHex()
    } : o && o.isVector2 ? e.uniforms[r] = {
      type: "v2",
      value: o.toArray()
    } : o && o.isVector3 ? e.uniforms[r] = {
      type: "v3",
      value: o.toArray()
    } : o && o.isVector4 ? e.uniforms[r] = {
      type: "v4",
      value: o.toArray()
    } : o && o.isMatrix3 ? e.uniforms[r] = {
      type: "m3",
      value: o.toArray()
    } : o && o.isMatrix4 ? e.uniforms[r] = {
      type: "m4",
      value: o.toArray()
    } : e.uniforms[r] = {
      value: o
    };
  }
  Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
  const n = {};
  for (const r in this.extensions)
    this.extensions[r] === !0 && (n[r] = !0);
  return Object.keys(n).length > 0 && (e.extensions = n), e;
};
function Gr() {
  He.call(this), this.type = "Camera", this.matrixWorldInverse = new Je(), this.projectionMatrix = new Je(), this.projectionMatrixInverse = new Je();
}
Gr.prototype = Object.assign(Object.create(He.prototype), {
  constructor: Gr,
  isCamera: !0,
  copy: function(t, e) {
    return He.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
  },
  getWorldDirection: function(t) {
    t === void 0 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new z()), this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function(t) {
    He.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function(t, e) {
    He.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function Nt(t = 50, e = 1, n = 0.1, r = 2e3) {
  Gr.call(this), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
}
Nt.prototype = Object.assign(Object.create(Gr.prototype), {
  constructor: Nt,
  isPerspectiveCamera: !0,
  copy: function(t, e) {
    return Gr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  },
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function(t) {
    const e = 0.5 * this.getFilmHeight() / t;
    this.fov = $e.RAD2DEG * 2 * Math.atan(e), this.updateProjectionMatrix();
  },
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function() {
    const t = Math.tan($e.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  },
  getEffectiveFOV: function() {
    return $e.RAD2DEG * 2 * Math.atan(
      Math.tan($e.DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function(t, e, n, r, s, o) {
    this.aspect = t / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const t = this.near;
    let e = t * Math.tan($e.DEG2RAD * 0.5 * this.fov) / this.zoom, n = 2 * e, r = this.aspect * n, s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, c = o.fullHeight;
      s += o.offsetX * r / l, e -= o.offsetY * n / c, r *= o.width / l, n *= o.height / c;
    }
    const a = this.filmOffset;
    a !== 0 && (s += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(t) {
    const e = He.prototype.toJSON.call(this, t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
});
const Bs = 90, zs = 1;
function Lo(t, e, n) {
  if (He.call(this), this.type = "CubeCamera", n.isWebGLCubeRenderTarget !== !0) {
    console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    return;
  }
  this.renderTarget = n;
  const r = new Nt(Bs, zs, t, e);
  r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new z(1, 0, 0)), this.add(r);
  const s = new Nt(Bs, zs, t, e);
  s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new z(-1, 0, 0)), this.add(s);
  const o = new Nt(Bs, zs, t, e);
  o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new z(0, 1, 0)), this.add(o);
  const a = new Nt(Bs, zs, t, e);
  a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new z(0, -1, 0)), this.add(a);
  const l = new Nt(Bs, zs, t, e);
  l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new z(0, 0, 1)), this.add(l);
  const c = new Nt(Bs, zs, t, e);
  c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new z(0, 0, -1)), this.add(c), this.update = function(h, d) {
    this.parent === null && this.updateMatrixWorld();
    const u = h.xr.enabled, p = h.getRenderTarget();
    h.xr.enabled = !1;
    const f = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, h.setRenderTarget(n, 0), h.render(d, r), h.setRenderTarget(n, 1), h.render(d, s), h.setRenderTarget(n, 2), h.render(d, o), h.setRenderTarget(n, 3), h.render(d, a), h.setRenderTarget(n, 4), h.render(d, l), n.texture.generateMipmaps = f, h.setRenderTarget(n, 5), h.render(d, c), h.setRenderTarget(p), h.xr.enabled = u;
  };
}
Lo.prototype = Object.create(He.prototype);
Lo.prototype.constructor = Lo;
function Vr(t, e, n, r, s, o, a, l, c, h) {
  t = t !== void 0 ? t : [], e = e !== void 0 ? e : Gf, a = a !== void 0 ? a : Dr, ft.call(this, t, e, n, r, s, o, a, l, c, h), this.flipY = !1, this._needsFlipEnvMap = !0;
}
Vr.prototype = Object.create(ft.prototype);
Vr.prototype.constructor = Vr;
Vr.prototype.isCubeTexture = !0;
Object.defineProperty(Vr.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(t) {
    this.image = t;
  }
});
function ms(t, e, n) {
  Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), si.call(this, t, t, e), e = e || {}, this.texture = new Vr(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture._needsFlipEnvMap = !1;
}
ms.prototype = Object.create(si.prototype);
ms.prototype.constructor = ms;
ms.prototype.isWebGLCubeRenderTarget = !0;
ms.prototype.fromEquirectangularTexture = function(t, e) {
  this.texture.type = e.type, this.texture.format = ri, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
  const n = {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: (
      /* glsl */
      `

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`
    ),
    fragmentShader: (
      /* glsl */
      `

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
    )
  }, r = new Yf(5, 5, 5), s = new rn({
    name: "CubemapFromEquirect",
    uniforms: Ao(n.uniforms),
    vertexShader: n.vertexShader,
    fragmentShader: n.fragmentShader,
    side: Ut,
    blending: Ia
  });
  s.uniforms.tEquirect.value = e;
  const o = new Tt(r, s), a = e.minFilter;
  return e.minFilter === Il && (e.minFilter = Ht), new Lo(1, 10, this).update(t, o), e.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
};
ms.prototype.clear = function(t, e, n, r) {
  const s = t.getRenderTarget();
  for (let o = 0; o < 6; o++)
    t.setRenderTarget(this, o), t.clear(e, n, r);
  t.setRenderTarget(s);
};
function Co(t, e, n, r, s, o, a, l, c, h, d, u) {
  ft.call(this, null, o, a, l, c, h, r, s, d, u), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = c !== void 0 ? c : qt, this.minFilter = h !== void 0 ? h : qt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
}
Co.prototype = Object.create(ft.prototype);
Co.prototype.constructor = Co;
Co.prototype.isDataTexture = !0;
const Us = /* @__PURE__ */ new hi(), ec = /* @__PURE__ */ new z();
let Kh = class {
  constructor(e, n, r, s, o, a) {
    this.planes = [
      e !== void 0 ? e : new ti(),
      n !== void 0 ? n : new ti(),
      r !== void 0 ? r : new ti(),
      s !== void 0 ? s : new ti(),
      o !== void 0 ? o : new ti(),
      a !== void 0 ? a : new ti()
    ];
  }
  set(e, n, r, s, o, a) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(n), l[2].copy(r), l[3].copy(s), l[4].copy(o), l[5].copy(a), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++)
      n[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const n = this.planes, r = e.elements, s = r[0], o = r[1], a = r[2], l = r[3], c = r[4], h = r[5], d = r[6], u = r[7], p = r[8], f = r[9], m = r[10], y = r[11], x = r[12], v = r[13], g = r[14], S = r[15];
    return n[0].setComponents(l - s, u - c, y - p, S - x).normalize(), n[1].setComponents(l + s, u + c, y + p, S + x).normalize(), n[2].setComponents(l + o, u + h, y + f, S + v).normalize(), n[3].setComponents(l - o, u - h, y - f, S - v).normalize(), n[4].setComponents(l - a, u - d, y - m, S - g).normalize(), n[5].setComponents(l + a, u + d, y + m, S + g).normalize(), this;
  }
  intersectsObject(e) {
    const n = e.geometry;
    return n.boundingSphere === null && n.computeBoundingSphere(), Us.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Us);
  }
  intersectsSprite(e) {
    return Us.center.set(0, 0, 0), Us.radius = 0.7071067811865476, Us.applyMatrix4(e.matrixWorld), this.intersectsSphere(Us);
  }
  intersectsSphere(e) {
    const n = this.planes, r = e.center, s = -e.radius;
    for (let o = 0; o < 6; o++)
      if (n[o].distanceToPoint(r) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) {
      const s = n[r];
      if (ec.x = s.normal.x > 0 ? e.max.x : e.min.x, ec.y = s.normal.y > 0 ? e.max.y : e.min.y, ec.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(ec) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++)
      if (n[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
};
function xy() {
  let t = null, e = !1, n = null, r = null;
  function s(o, a) {
    n(o, a), r = t.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (r = t.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      t.cancelAnimationFrame(r), e = !1;
    },
    setAnimationLoop: function(o) {
      n = o;
    },
    setContext: function(o) {
      t = o;
    }
  };
}
function F_(t, e) {
  const n = e.isWebGL2, r = /* @__PURE__ */ new WeakMap();
  function s(h, d) {
    const u = h.array, p = h.usage, f = t.createBuffer();
    t.bindBuffer(d, f), t.bufferData(d, u, p), h.onUploadCallback();
    let m = 5126;
    return u instanceof Float32Array ? m = 5126 : u instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : u instanceof Uint16Array ? h.isFloat16BufferAttribute ? n ? m = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : m = 5123 : u instanceof Int16Array ? m = 5122 : u instanceof Uint32Array ? m = 5125 : u instanceof Int32Array ? m = 5124 : u instanceof Int8Array ? m = 5120 : u instanceof Uint8Array && (m = 5121), {
      buffer: f,
      type: m,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: h.version
    };
  }
  function o(h, d, u) {
    const p = d.array, f = d.updateRange;
    t.bindBuffer(u, h), f.count === -1 ? t.bufferSubData(u, 0, p) : (n ? t.bufferSubData(
      u,
      f.offset * p.BYTES_PER_ELEMENT,
      p,
      f.offset,
      f.count
    ) : t.bufferSubData(
      u,
      f.offset * p.BYTES_PER_ELEMENT,
      p.subarray(f.offset, f.offset + f.count)
    ), f.count = -1);
  }
  function a(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), r.get(h);
  }
  function l(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    const d = r.get(h);
    d && (t.deleteBuffer(d.buffer), r.delete(h));
  }
  function c(h, d) {
    if (h.isGLBufferAttribute) {
      const p = r.get(h);
      (!p || p.version < h.version) && r.set(h, {
        buffer: h.buffer,
        type: h.type,
        bytesPerElement: h.elementSize,
        version: h.version
      });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    const u = r.get(h);
    u === void 0 ? r.set(h, s(h, d)) : u.version < h.version && (o(u.buffer, h, d), u.version = h.version);
  }
  return {
    get: a,
    remove: l,
    update: c
  };
}
let B_ = class extends it {
  constructor(e = 1, n = 1, r = 1, s = 1) {
    super(), this.type = "PlaneBufferGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: r,
      heightSegments: s
    };
    const o = e / 2, a = n / 2, l = Math.floor(r), c = Math.floor(s), h = l + 1, d = c + 1, u = e / l, p = n / c, f = [], m = [], y = [], x = [];
    for (let v = 0; v < d; v++) {
      const g = v * p - a;
      for (let S = 0; S < h; S++) {
        const T = S * u - o;
        m.push(T, -g, 0), y.push(0, 0, 1), x.push(S / l), x.push(1 - v / c);
      }
    }
    for (let v = 0; v < c; v++)
      for (let g = 0; g < l; g++) {
        const S = g + h * v, T = g + h * (v + 1), E = g + 1 + h * (v + 1), w = g + 1 + h * v;
        f.push(S, T, w), f.push(T, E, w);
      }
    this.setIndex(f), this.setAttribute("position", new Ke(m, 3)), this.setAttribute("normal", new Ke(y, 3)), this.setAttribute("uv", new Ke(x, 2));
  }
};
var z_ = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, U_ = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, H_ = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`, G_ = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`, V_ = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, k_ = "vec3 transformed = vec3( position );", W_ = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, $_ = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`, j_ = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, q_ = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, X_ = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Y_ = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Z_ = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, J_ = `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`, K_ = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`, Q_ = `#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, eb = `#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, tb = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, nb = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, ib = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, rb = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, sb = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, ob = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, ab = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, lb = "gl_FragColor = linearToOutputTexel( gl_FragColor );", cb = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`, hb = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, ub = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, db = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, fb = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, pb = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, mb = `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`, gb = `#ifdef USE_FOG
	varying float fogDepth;
#endif`, vb = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, yb = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, xb = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, _b = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`, bb = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, wb = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`, Mb = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`, Sb = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`, Eb = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Tb = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, Ab = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Lb = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, Cb = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`, Rb = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Pb = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Ib = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`, Db = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, Nb = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Ob = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Fb = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, Bb = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, zb = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`, Ub = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Hb = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Gb = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Vb = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, kb = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Wb = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`, $b = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`, jb = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`, qb = `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, Xb = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`, Yb = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`, Zb = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, Jb = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`, Kb = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, Qb = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, ew = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, tw = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, nw = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, iw = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, rw = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, sw = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, ow = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, aw = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, lw = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, cw = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, hw = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, uw = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`, dw = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, fw = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, pw = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, mw = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, gw = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, vw = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, yw = `#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`, xw = `#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`, _w = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, bw = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, ww = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, Mw = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, Sw = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, Ew = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, Tw = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, Aw = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Lw = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Cw = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Rw = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Pw = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, Iw = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Dw = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Nw = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Ow = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Fw = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Bw = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, zw = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Uw = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Hw = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Gw = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Vw = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, kw = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ww = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, $w = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, jw = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, qw = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Xw = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Yw = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Zw = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Jw = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`, Kw = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Qw = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, eM = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, tM = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, nM = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, iM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, rM = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
const tt = {
  alphamap_fragment: z_,
  alphamap_pars_fragment: U_,
  alphatest_fragment: H_,
  aomap_fragment: G_,
  aomap_pars_fragment: V_,
  begin_vertex: k_,
  beginnormal_vertex: W_,
  bsdfs: $_,
  bumpmap_pars_fragment: j_,
  clipping_planes_fragment: q_,
  clipping_planes_pars_fragment: X_,
  clipping_planes_pars_vertex: Y_,
  clipping_planes_vertex: Z_,
  color_fragment: J_,
  color_pars_fragment: K_,
  color_pars_vertex: Q_,
  color_vertex: eb,
  common: tb,
  cube_uv_reflection_fragment: nb,
  defaultnormal_vertex: ib,
  displacementmap_pars_vertex: rb,
  displacementmap_vertex: sb,
  emissivemap_fragment: ob,
  emissivemap_pars_fragment: ab,
  encodings_fragment: lb,
  encodings_pars_fragment: cb,
  envmap_fragment: hb,
  envmap_common_pars_fragment: ub,
  envmap_pars_fragment: db,
  envmap_pars_vertex: fb,
  envmap_physical_pars_fragment: Sb,
  envmap_vertex: pb,
  fog_vertex: mb,
  fog_pars_vertex: gb,
  fog_fragment: vb,
  fog_pars_fragment: yb,
  gradientmap_pars_fragment: xb,
  lightmap_fragment: _b,
  lightmap_pars_fragment: bb,
  lights_lambert_vertex: wb,
  lights_pars_begin: Mb,
  lights_toon_fragment: Eb,
  lights_toon_pars_fragment: Tb,
  lights_phong_fragment: Ab,
  lights_phong_pars_fragment: Lb,
  lights_physical_fragment: Cb,
  lights_physical_pars_fragment: Rb,
  lights_fragment_begin: Pb,
  lights_fragment_maps: Ib,
  lights_fragment_end: Db,
  logdepthbuf_fragment: Nb,
  logdepthbuf_pars_fragment: Ob,
  logdepthbuf_pars_vertex: Fb,
  logdepthbuf_vertex: Bb,
  map_fragment: zb,
  map_pars_fragment: Ub,
  map_particle_fragment: Hb,
  map_particle_pars_fragment: Gb,
  metalnessmap_fragment: Vb,
  metalnessmap_pars_fragment: kb,
  morphnormal_vertex: Wb,
  morphtarget_pars_vertex: $b,
  morphtarget_vertex: jb,
  normal_fragment_begin: qb,
  normal_fragment_maps: Xb,
  normalmap_pars_fragment: Yb,
  clearcoat_normal_fragment_begin: Zb,
  clearcoat_normal_fragment_maps: Jb,
  clearcoat_pars_fragment: Kb,
  packing: Qb,
  premultiplied_alpha_fragment: ew,
  project_vertex: tw,
  dithering_fragment: nw,
  dithering_pars_fragment: iw,
  roughnessmap_fragment: rw,
  roughnessmap_pars_fragment: sw,
  shadowmap_pars_fragment: ow,
  shadowmap_pars_vertex: aw,
  shadowmap_vertex: lw,
  shadowmask_pars_fragment: cw,
  skinbase_vertex: hw,
  skinning_pars_vertex: uw,
  skinning_vertex: dw,
  skinnormal_vertex: fw,
  specularmap_fragment: pw,
  specularmap_pars_fragment: mw,
  tonemapping_fragment: gw,
  tonemapping_pars_fragment: vw,
  transmissionmap_fragment: yw,
  transmissionmap_pars_fragment: xw,
  uv_pars_fragment: _w,
  uv_pars_vertex: bw,
  uv_vertex: ww,
  uv2_pars_fragment: Mw,
  uv2_pars_vertex: Sw,
  uv2_vertex: Ew,
  worldpos_vertex: Tw,
  background_frag: Aw,
  background_vert: Lw,
  cube_frag: Cw,
  cube_vert: Rw,
  depth_frag: Pw,
  depth_vert: Iw,
  distanceRGBA_frag: Dw,
  distanceRGBA_vert: Nw,
  equirect_frag: Ow,
  equirect_vert: Fw,
  linedashed_frag: Bw,
  linedashed_vert: zw,
  meshbasic_frag: Uw,
  meshbasic_vert: Hw,
  meshlambert_frag: Gw,
  meshlambert_vert: Vw,
  meshmatcap_frag: kw,
  meshmatcap_vert: Ww,
  meshtoon_frag: $w,
  meshtoon_vert: jw,
  meshphong_frag: qw,
  meshphong_vert: Xw,
  meshphysical_frag: Yw,
  meshphysical_vert: Zw,
  normal_frag: Jw,
  normal_vert: Kw,
  points_frag: Qw,
  points_vert: eM,
  shadow_frag: tM,
  shadow_vert: nM,
  sprite_frag: iM,
  sprite_vert: rM
}, Ae = {
  common: {
    diffuse: { value: new Ne(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new ln() },
    uv2Transform: { value: new ln() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new ye(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Ne(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Ne(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new ln() }
  },
  sprite: {
    diffuse: { value: new Ne(15658734) },
    opacity: { value: 1 },
    center: { value: new ye(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new ln() }
  }
}, ni = {
  basic: {
    uniforms: $t([
      Ae.common,
      Ae.specularmap,
      Ae.envmap,
      Ae.aomap,
      Ae.lightmap,
      Ae.fog
    ]),
    vertexShader: tt.meshbasic_vert,
    fragmentShader: tt.meshbasic_frag
  },
  lambert: {
    uniforms: $t([
      Ae.common,
      Ae.specularmap,
      Ae.envmap,
      Ae.aomap,
      Ae.lightmap,
      Ae.emissivemap,
      Ae.fog,
      Ae.lights,
      {
        emissive: { value: new Ne(0) }
      }
    ]),
    vertexShader: tt.meshlambert_vert,
    fragmentShader: tt.meshlambert_frag
  },
  phong: {
    uniforms: $t([
      Ae.common,
      Ae.specularmap,
      Ae.envmap,
      Ae.aomap,
      Ae.lightmap,
      Ae.emissivemap,
      Ae.bumpmap,
      Ae.normalmap,
      Ae.displacementmap,
      Ae.fog,
      Ae.lights,
      {
        emissive: { value: new Ne(0) },
        specular: { value: new Ne(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: tt.meshphong_vert,
    fragmentShader: tt.meshphong_frag
  },
  standard: {
    uniforms: $t([
      Ae.common,
      Ae.envmap,
      Ae.aomap,
      Ae.lightmap,
      Ae.emissivemap,
      Ae.bumpmap,
      Ae.normalmap,
      Ae.displacementmap,
      Ae.roughnessmap,
      Ae.metalnessmap,
      Ae.fog,
      Ae.lights,
      {
        emissive: { value: new Ne(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: tt.meshphysical_vert,
    fragmentShader: tt.meshphysical_frag
  },
  toon: {
    uniforms: $t([
      Ae.common,
      Ae.aomap,
      Ae.lightmap,
      Ae.emissivemap,
      Ae.bumpmap,
      Ae.normalmap,
      Ae.displacementmap,
      Ae.gradientmap,
      Ae.fog,
      Ae.lights,
      {
        emissive: { value: new Ne(0) }
      }
    ]),
    vertexShader: tt.meshtoon_vert,
    fragmentShader: tt.meshtoon_frag
  },
  matcap: {
    uniforms: $t([
      Ae.common,
      Ae.bumpmap,
      Ae.normalmap,
      Ae.displacementmap,
      Ae.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: tt.meshmatcap_vert,
    fragmentShader: tt.meshmatcap_frag
  },
  points: {
    uniforms: $t([
      Ae.points,
      Ae.fog
    ]),
    vertexShader: tt.points_vert,
    fragmentShader: tt.points_frag
  },
  dashed: {
    uniforms: $t([
      Ae.common,
      Ae.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: tt.linedashed_vert,
    fragmentShader: tt.linedashed_frag
  },
  depth: {
    uniforms: $t([
      Ae.common,
      Ae.displacementmap
    ]),
    vertexShader: tt.depth_vert,
    fragmentShader: tt.depth_frag
  },
  normal: {
    uniforms: $t([
      Ae.common,
      Ae.bumpmap,
      Ae.normalmap,
      Ae.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: tt.normal_vert,
    fragmentShader: tt.normal_frag
  },
  sprite: {
    uniforms: $t([
      Ae.sprite,
      Ae.fog
    ]),
    vertexShader: tt.sprite_vert,
    fragmentShader: tt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new ln() },
      t2D: { value: null }
    },
    vertexShader: tt.background_vert,
    fragmentShader: tt.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: $t([
      Ae.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: tt.cube_vert,
    fragmentShader: tt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: tt.equirect_vert,
    fragmentShader: tt.equirect_frag
  },
  distanceRGBA: {
    uniforms: $t([
      Ae.common,
      Ae.displacementmap,
      {
        referencePosition: { value: new z() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: tt.distanceRGBA_vert,
    fragmentShader: tt.distanceRGBA_frag
  },
  shadow: {
    uniforms: $t([
      Ae.lights,
      Ae.fog,
      {
        color: { value: new Ne(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: tt.shadow_vert,
    fragmentShader: tt.shadow_frag
  }
};
ni.physical = {
  uniforms: $t([
    ni.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new ye(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new Ne(0) },
      transmission: { value: 0 },
      transmissionMap: { value: null }
    }
  ]),
  vertexShader: tt.meshphysical_vert,
  fragmentShader: tt.meshphysical_frag
};
function sM(t, e, n, r, s) {
  const o = new Ne(0);
  let a = 0, l, c, h = null, d = 0, u = null;
  function p(m, y, x, v) {
    let g = y.isScene === !0 ? y.background : null;
    g && g.isTexture && (g = e.get(g));
    const S = t.xr, T = S.getSession && S.getSession();
    T && T.environmentBlendMode === "additive" && (g = null), g === null ? f(o, a) : g && g.isColor && (f(g, 1), v = !0), (t.autoClear || v) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.isWebGLCubeRenderTarget || g.mapping === kf) ? (c === void 0 && (c = new Tt(
      new Yf(1, 1, 1),
      new rn({
        name: "BackgroundCubeMaterial",
        uniforms: Ao(ni.cube.uniforms),
        vertexShader: ni.cube.vertexShader,
        fragmentShader: ni.cube.fragmentShader,
        side: Ut,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(E, w, C) {
      this.matrixWorld.copyPosition(C.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(c)), g.isWebGLCubeRenderTarget && (g = g.texture), c.material.uniforms.envMap.value = g, c.material.uniforms.flipEnvMap.value = g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1, (h !== g || d !== g.version || u !== t.toneMapping) && (c.material.needsUpdate = !0, h = g, d = g.version, u = t.toneMapping), m.unshift(c, c.geometry, c.material, 0, 0, null)) : g && g.isTexture && (l === void 0 && (l = new Tt(
      new B_(2, 2),
      new rn({
        name: "BackgroundMaterial",
        uniforms: Ao(ni.background.uniforms),
        vertexShader: ni.background.vertexShader,
        fragmentShader: ni.background.fragmentShader,
        side: Pl,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(l)), l.material.uniforms.t2D.value = g, g.matrixAutoUpdate === !0 && g.updateMatrix(), l.material.uniforms.uvTransform.value.copy(g.matrix), (h !== g || d !== g.version || u !== t.toneMapping) && (l.material.needsUpdate = !0, h = g, d = g.version, u = t.toneMapping), m.unshift(l, l.geometry, l.material, 0, 0, null));
  }
  function f(m, y) {
    n.buffers.color.setClear(m.r, m.g, m.b, y, s);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(m, y = 1) {
      o.set(m), a = y, f(o, a);
    },
    getClearAlpha: function() {
      return a;
    },
    setClearAlpha: function(m) {
      a = m, f(o, a);
    },
    render: p
  };
}
function oM(t, e, n, r) {
  const s = t.getParameter(34921), o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), a = r.isWebGL2 || o !== null, l = {}, c = y(null);
  let h = c;
  function d(k, O, P, j, re) {
    let ae = !1;
    if (a) {
      const ce = m(j, P, O);
      h !== ce && (h = ce, p(h.object)), ae = x(j, re), ae && v(j, re);
    } else {
      const ce = O.wireframe === !0;
      (h.geometry !== j.id || h.program !== P.id || h.wireframe !== ce) && (h.geometry = j.id, h.program = P.id, h.wireframe = ce, ae = !0);
    }
    k.isInstancedMesh === !0 && (ae = !0), re !== null && n.update(re, 34963), ae && (C(k, O, P, j), re !== null && t.bindBuffer(34963, n.get(re).buffer));
  }
  function u() {
    return r.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES();
  }
  function p(k) {
    return r.isWebGL2 ? t.bindVertexArray(k) : o.bindVertexArrayOES(k);
  }
  function f(k) {
    return r.isWebGL2 ? t.deleteVertexArray(k) : o.deleteVertexArrayOES(k);
  }
  function m(k, O, P) {
    const j = P.wireframe === !0;
    let re = l[k.id];
    re === void 0 && (re = {}, l[k.id] = re);
    let ae = re[O.id];
    ae === void 0 && (ae = {}, re[O.id] = ae);
    let ce = ae[j];
    return ce === void 0 && (ce = y(u()), ae[j] = ce), ce;
  }
  function y(k) {
    const O = [], P = [], j = [];
    for (let re = 0; re < s; re++)
      O[re] = 0, P[re] = 0, j[re] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: O,
      enabledAttributes: P,
      attributeDivisors: j,
      object: k,
      attributes: {},
      index: null
    };
  }
  function x(k, O) {
    const P = h.attributes, j = k.attributes;
    let re = 0;
    for (const ae in j) {
      const ce = P[ae], pe = j[ae];
      if (ce === void 0 || ce.attribute !== pe || ce.data !== pe.data) return !0;
      re++;
    }
    return h.attributesNum !== re || h.index !== O;
  }
  function v(k, O) {
    const P = {}, j = k.attributes;
    let re = 0;
    for (const ae in j) {
      const ce = j[ae], pe = {};
      pe.attribute = ce, ce.data && (pe.data = ce.data), P[ae] = pe, re++;
    }
    h.attributes = P, h.attributesNum = re, h.index = O;
  }
  function g() {
    const k = h.newAttributes;
    for (let O = 0, P = k.length; O < P; O++)
      k[O] = 0;
  }
  function S(k) {
    T(k, 0);
  }
  function T(k, O) {
    const P = h.newAttributes, j = h.enabledAttributes, re = h.attributeDivisors;
    P[k] = 1, j[k] === 0 && (t.enableVertexAttribArray(k), j[k] = 1), re[k] !== O && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](k, O), re[k] = O);
  }
  function E() {
    const k = h.newAttributes, O = h.enabledAttributes;
    for (let P = 0, j = O.length; P < j; P++)
      O[P] !== k[P] && (t.disableVertexAttribArray(P), O[P] = 0);
  }
  function w(k, O, P, j, re, ae) {
    r.isWebGL2 === !0 && (P === 5124 || P === 5125) ? t.vertexAttribIPointer(k, O, P, re, ae) : t.vertexAttribPointer(k, O, P, j, re, ae);
  }
  function C(k, O, P, j) {
    if (r.isWebGL2 === !1 && (k.isInstancedMesh || j.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    g();
    const re = j.attributes, ae = P.getAttributes(), ce = O.defaultAttributeValues;
    for (const pe in ae) {
      const de = ae[pe];
      if (de >= 0) {
        const ge = re[pe];
        if (ge !== void 0) {
          const we = ge.normalized, Ge = ge.itemSize, te = n.get(ge);
          if (te === void 0) continue;
          const I = te.buffer, L = te.type, U = te.bytesPerElement;
          if (ge.isInterleavedBufferAttribute) {
            const N = ge.data, V = N.stride, W = ge.offset;
            N && N.isInstancedInterleavedBuffer ? (T(de, N.meshPerAttribute), j._maxInstanceCount === void 0 && (j._maxInstanceCount = N.meshPerAttribute * N.count)) : S(de), t.bindBuffer(34962, I), w(de, Ge, L, we, V * U, W * U);
          } else
            ge.isInstancedBufferAttribute ? (T(de, ge.meshPerAttribute), j._maxInstanceCount === void 0 && (j._maxInstanceCount = ge.meshPerAttribute * ge.count)) : S(de), t.bindBuffer(34962, I), w(de, Ge, L, we, 0, 0);
        } else if (pe === "instanceMatrix") {
          const we = n.get(k.instanceMatrix);
          if (we === void 0) continue;
          const Ge = we.buffer, te = we.type;
          T(de + 0, 1), T(de + 1, 1), T(de + 2, 1), T(de + 3, 1), t.bindBuffer(34962, Ge), t.vertexAttribPointer(de + 0, 4, te, !1, 64, 0), t.vertexAttribPointer(de + 1, 4, te, !1, 64, 16), t.vertexAttribPointer(de + 2, 4, te, !1, 64, 32), t.vertexAttribPointer(de + 3, 4, te, !1, 64, 48);
        } else if (pe === "instanceColor") {
          const we = n.get(k.instanceColor);
          if (we === void 0) continue;
          const Ge = we.buffer, te = we.type;
          T(de, 1), t.bindBuffer(34962, Ge), t.vertexAttribPointer(de, 3, te, !1, 12, 0);
        } else if (ce !== void 0) {
          const we = ce[pe];
          if (we !== void 0)
            switch (we.length) {
              case 2:
                t.vertexAttrib2fv(de, we);
                break;
              case 3:
                t.vertexAttrib3fv(de, we);
                break;
              case 4:
                t.vertexAttrib4fv(de, we);
                break;
              default:
                t.vertexAttrib1fv(de, we);
            }
        }
      }
    }
    E();
  }
  function ee() {
    B();
    for (const k in l) {
      const O = l[k];
      for (const P in O) {
        const j = O[P];
        for (const re in j)
          f(j[re].object), delete j[re];
        delete O[P];
      }
      delete l[k];
    }
  }
  function Y(k) {
    if (l[k.id] === void 0) return;
    const O = l[k.id];
    for (const P in O) {
      const j = O[P];
      for (const re in j)
        f(j[re].object), delete j[re];
      delete O[P];
    }
    delete l[k.id];
  }
  function le(k) {
    for (const O in l) {
      const P = l[O];
      if (P[k.id] === void 0) continue;
      const j = P[k.id];
      for (const re in j)
        f(j[re].object), delete j[re];
      delete P[k.id];
    }
  }
  function B() {
    Z(), h !== c && (h = c, p(h.object));
  }
  function Z() {
    c.geometry = null, c.program = null, c.wireframe = !1;
  }
  return {
    setup: d,
    reset: B,
    resetDefaultState: Z,
    dispose: ee,
    releaseStatesOfGeometry: Y,
    releaseStatesOfProgram: le,
    initAttributes: g,
    enableAttribute: S,
    disableUnusedAttributes: E
  };
}
function aM(t, e, n, r) {
  const s = r.isWebGL2;
  let o;
  function a(h) {
    o = h;
  }
  function l(h, d) {
    t.drawArrays(o, h, d), n.update(d, o, 1);
  }
  function c(h, d, u) {
    if (u === 0) return;
    let p, f;
    if (s)
      p = t, f = "drawArraysInstanced";
    else if (p = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", p === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    p[f](o, h, d, u), n.update(d, o, u);
  }
  this.setMode = a, this.render = l, this.renderInstances = c;
}
function lM(t, e, n) {
  let r;
  function s() {
    if (r !== void 0) return r;
    const w = e.get("EXT_texture_filter_anisotropic");
    return w !== null ? r = t.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : r = 0, r;
  }
  function o(w) {
    if (w === "highp") {
      if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      w = "mediump";
    }
    return w === "mediump" && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const a = typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && t instanceof WebGL2ComputeRenderingContext;
  let l = n.precision !== void 0 ? n.precision : "highp";
  const c = o(l);
  c !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", c, "instead."), l = c);
  const h = n.logarithmicDepthBuffer === !0, d = t.getParameter(34930), u = t.getParameter(35660), p = t.getParameter(3379), f = t.getParameter(34076), m = t.getParameter(34921), y = t.getParameter(36347), x = t.getParameter(36348), v = t.getParameter(36349), g = u > 0, S = a || !!e.get("OES_texture_float"), T = g && S, E = a ? t.getParameter(36183) : 0;
  return {
    isWebGL2: a,
    getMaxAnisotropy: s,
    getMaxPrecision: o,
    precision: l,
    logarithmicDepthBuffer: h,
    maxTextures: d,
    maxVertexTextures: u,
    maxTextureSize: p,
    maxCubemapSize: f,
    maxAttributes: m,
    maxVertexUniforms: y,
    maxVaryings: x,
    maxFragmentUniforms: v,
    vertexTextures: g,
    floatFragmentTextures: S,
    floatVertexTextures: T,
    maxSamples: E
  };
}
function cM(t) {
  const e = this;
  let n = null, r = 0, s = !1, o = !1;
  const a = new ti(), l = new ln(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, p, f) {
    const m = u.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    r !== 0 || s;
    return s = p, n = d(u, f, 0), r = u.length, m;
  }, this.beginShadows = function() {
    o = !0, d(null);
  }, this.endShadows = function() {
    o = !1, h();
  }, this.setState = function(u, p, f) {
    const m = u.clippingPlanes, y = u.clipIntersection, x = u.clipShadows, v = t.get(u);
    if (!s || m === null || m.length === 0 || o && !x)
      o ? d(null) : h();
    else {
      const g = o ? 0 : r, S = g * 4;
      let T = v.clippingState || null;
      c.value = T, T = d(m, p, S, f);
      for (let E = 0; E !== S; ++E)
        T[E] = n[E];
      v.clippingState = T, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += g;
    }
  };
  function h() {
    c.value !== n && (c.value = n, c.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function d(u, p, f, m) {
    const y = u !== null ? u.length : 0;
    let x = null;
    if (y !== 0) {
      if (x = c.value, m !== !0 || x === null) {
        const v = f + y * 4, g = p.matrixWorldInverse;
        l.getNormalMatrix(g), (x === null || x.length < v) && (x = new Float32Array(v));
        for (let S = 0, T = f; S !== y; ++S, T += 4)
          a.copy(u[S]).applyMatrix4(g, l), a.normal.toArray(x, T), x[T + 3] = a.constant;
      }
      c.value = x, c.needsUpdate = !0;
    }
    return e.numPlanes = y, e.numIntersection = 0, x;
  }
}
function hM(t) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(a, l) {
    return l === Sp ? a.mapping = Gf : l === Ep && (a.mapping = Vf), a;
  }
  function r(a) {
    if (a && a.isTexture) {
      const l = a.mapping;
      if (l === Sp || l === Ep)
        if (e.has(a)) {
          const c = e.get(a).texture;
          return n(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const h = t.getRenderList(), d = t.getRenderTarget(), u = new ms(c.height / 2);
            return u.fromEquirectangularTexture(t, a), e.set(a, u), t.setRenderTarget(d), t.setRenderList(h), a.addEventListener("dispose", s), n(u.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: o
  };
}
function uM(t) {
  const e = {};
  return {
    has: function(n) {
      if (e[n] !== void 0)
        return e[n] !== null;
      let r;
      switch (n) {
        case "WEBGL_depth_texture":
          r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          r = t.getExtension(n);
      }
      return e[n] = r, r !== null;
    },
    get: function(n) {
      return this.has(n) || console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n];
    }
  };
}
function dM(t, e, n, r) {
  const s = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const p = u.target, f = s.get(p);
    f.index !== null && e.remove(f.index);
    for (const y in f.attributes)
      e.remove(f.attributes[y]);
    p.removeEventListener("dispose", a), s.delete(p);
    const m = o.get(f);
    m && (e.remove(m), o.delete(f)), r.releaseStatesOfGeometry(f), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, n.memory.geometries--;
  }
  function l(u, p) {
    let f = s.get(p);
    return f || (p.addEventListener("dispose", a), p.isBufferGeometry ? f = p : p.isGeometry && (p._bufferGeometry === void 0 && (p._bufferGeometry = new it().setFromObject(u)), f = p._bufferGeometry), s.set(p, f), n.memory.geometries++, f);
  }
  function c(u) {
    const p = u.attributes;
    for (const m in p)
      e.update(p[m], 34962);
    const f = u.morphAttributes;
    for (const m in f) {
      const y = f[m];
      for (let x = 0, v = y.length; x < v; x++)
        e.update(y[x], 34962);
    }
  }
  function h(u) {
    const p = [], f = u.index, m = u.attributes.position;
    let y = 0;
    if (f !== null) {
      const g = f.array;
      y = f.version;
      for (let S = 0, T = g.length; S < T; S += 3) {
        const E = g[S + 0], w = g[S + 1], C = g[S + 2];
        p.push(E, w, w, C, C, E);
      }
    } else {
      const g = m.array;
      y = m.version;
      for (let S = 0, T = g.length / 3 - 1; S < T; S += 3) {
        const E = S + 0, w = S + 1, C = S + 2;
        p.push(E, w, w, C, C, E);
      }
    }
    const x = new (gy(p) > 65535 ? Qa : Ka)(p, 1);
    x.version = y;
    const v = o.get(u);
    v && e.remove(v), o.set(u, x);
  }
  function d(u) {
    const p = o.get(u);
    if (p) {
      const f = u.index;
      f !== null && p.version < f.version && h(u);
    } else
      h(u);
    return o.get(u);
  }
  return {
    get: l,
    update: c,
    getWireframeAttribute: d
  };
}
function fM(t, e, n, r) {
  const s = r.isWebGL2;
  let o;
  function a(p) {
    o = p;
  }
  let l, c;
  function h(p) {
    l = p.type, c = p.bytesPerElement;
  }
  function d(p, f) {
    t.drawElements(o, f, l, p * c), n.update(f, o, 1);
  }
  function u(p, f, m) {
    if (m === 0) return;
    let y, x;
    if (s)
      y = t, x = "drawElementsInstanced";
    else if (y = e.get("ANGLE_instanced_arrays"), x = "drawElementsInstancedANGLE", y === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    y[x](o, f, l, p * c, m), n.update(f, o, m);
  }
  this.setMode = a, this.setIndex = h, this.render = d, this.renderInstances = u;
}
function pM(t) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function r(o, a, l) {
    switch (n.calls++, a) {
      case 4:
        n.triangles += l * (o / 3);
        break;
      case 1:
        n.lines += l * (o / 2);
        break;
      case 3:
        n.lines += l * (o - 1);
        break;
      case 2:
        n.lines += l * o;
        break;
      case 0:
        n.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function s() {
    n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: s,
    update: r
  };
}
function mM(t, e) {
  return t[0] - e[0];
}
function gM(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function vM(t) {
  const e = {}, n = new Float32Array(8), r = [];
  for (let o = 0; o < 8; o++)
    r[o] = [o, 0];
  function s(o, a, l, c) {
    const h = o.morphTargetInfluences, d = h === void 0 ? 0 : h.length;
    let u = e[a.id];
    if (u === void 0) {
      u = [];
      for (let x = 0; x < d; x++)
        u[x] = [x, 0];
      e[a.id] = u;
    }
    for (let x = 0; x < d; x++) {
      const v = u[x];
      v[0] = x, v[1] = h[x];
    }
    u.sort(gM);
    for (let x = 0; x < 8; x++)
      x < d && u[x][1] ? (r[x][0] = u[x][0], r[x][1] = u[x][1]) : (r[x][0] = Number.MAX_SAFE_INTEGER, r[x][1] = 0);
    r.sort(mM);
    const p = l.morphTargets && a.morphAttributes.position, f = l.morphNormals && a.morphAttributes.normal;
    let m = 0;
    for (let x = 0; x < 8; x++) {
      const v = r[x], g = v[0], S = v[1];
      g !== Number.MAX_SAFE_INTEGER && S ? (p && a.getAttribute("morphTarget" + x) !== p[g] && a.setAttribute("morphTarget" + x, p[g]), f && a.getAttribute("morphNormal" + x) !== f[g] && a.setAttribute("morphNormal" + x, f[g]), n[x] = S, m += S) : (p && a.hasAttribute("morphTarget" + x) === !0 && a.deleteAttribute("morphTarget" + x), f && a.hasAttribute("morphNormal" + x) === !0 && a.deleteAttribute("morphNormal" + x), n[x] = 0);
    }
    const y = a.morphTargetsRelative ? 1 : 1 - m;
    c.getUniforms().setValue(t, "morphTargetBaseInfluence", y), c.getUniforms().setValue(t, "morphTargetInfluences", n);
  }
  return {
    update: s
  };
}
function yM(t, e, n, r) {
  let s = /* @__PURE__ */ new WeakMap();
  function o(c) {
    const h = r.render.frame, d = c.geometry, u = e.get(c, d);
    return s.get(u) !== h && (d.isGeometry && u.updateFromObject(c), e.update(u), s.set(u, h)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), n.update(c.instanceMatrix, 34962), c.instanceColor !== null && n.update(c.instanceColor, 34962)), u;
  }
  function a() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function l(c) {
    const h = c.target;
    h.removeEventListener("dispose", l), n.remove(h.instanceMatrix), h.instanceColor !== null && n.remove(h.instanceColor);
  }
  return {
    update: o,
    dispose: a
  };
}
function el(t = null, e = 1, n = 1, r = 1) {
  ft.call(this, null), this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = qt, this.minFilter = qt, this.wrapR = an, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}
el.prototype = Object.create(ft.prototype);
el.prototype.constructor = el;
el.prototype.isDataTexture2DArray = !0;
function tl(t = null, e = 1, n = 1, r = 1) {
  ft.call(this, null), this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = qt, this.minFilter = qt, this.wrapR = an, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}
tl.prototype = Object.create(ft.prototype);
tl.prototype.constructor = tl;
tl.prototype.isDataTexture3D = !0;
const _y = new ft(), xM = new el(), _M = new tl(), by = new Vr(), Xp = [], Yp = [], Zp = new Float32Array(16), Jp = new Float32Array(9), Kp = new Float32Array(4);
function Ko(t, e, n) {
  const r = t[0];
  if (r <= 0 || r > 0) return t;
  const s = e * n;
  let o = Xp[s];
  if (o === void 0 && (o = new Float32Array(s), Xp[s] = o), e !== 0) {
    r.toArray(o, 0);
    for (let a = 1, l = 0; a !== e; ++a)
      l += n, t[a].toArray(o, l);
  }
  return o;
}
function Bn(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, r = t.length; n < r; n++)
    if (t[n] !== e[n]) return !1;
  return !0;
}
function Sn(t, e) {
  for (let n = 0, r = e.length; n < r; n++)
    t[n] = e[n];
}
function wy(t, e) {
  let n = Yp[e];
  n === void 0 && (n = new Int32Array(e), Yp[e] = n);
  for (let r = 0; r !== e; ++r)
    n[r] = t.allocateTextureUnit();
  return n;
}
function bM(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e);
}
function wM(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Bn(n, e)) return;
    t.uniform2fv(this.addr, e), Sn(n, e);
  }
}
function MM(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (Bn(n, e)) return;
    t.uniform3fv(this.addr, e), Sn(n, e);
  }
}
function SM(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Bn(n, e)) return;
    t.uniform4fv(this.addr, e), Sn(n, e);
  }
}
function EM(t, e) {
  const n = this.cache, r = e.elements;
  if (r === void 0) {
    if (Bn(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), Sn(n, e);
  } else {
    if (Bn(n, r)) return;
    Kp.set(r), t.uniformMatrix2fv(this.addr, !1, Kp), Sn(n, r);
  }
}
function TM(t, e) {
  const n = this.cache, r = e.elements;
  if (r === void 0) {
    if (Bn(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), Sn(n, e);
  } else {
    if (Bn(n, r)) return;
    Jp.set(r), t.uniformMatrix3fv(this.addr, !1, Jp), Sn(n, r);
  }
}
function AM(t, e) {
  const n = this.cache, r = e.elements;
  if (r === void 0) {
    if (Bn(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), Sn(n, e);
  } else {
    if (Bn(n, r)) return;
    Zp.set(r), t.uniformMatrix4fv(this.addr, !1, Zp), Sn(n, r);
  }
}
function LM(t, e, n) {
  const r = this.cache, s = n.allocateTextureUnit();
  r[0] !== s && (t.uniform1i(this.addr, s), r[0] = s), n.safeSetTexture2D(e || _y, s);
}
function CM(t, e, n) {
  const r = this.cache, s = n.allocateTextureUnit();
  r[0] !== s && (t.uniform1i(this.addr, s), r[0] = s), n.setTexture2DArray(e || xM, s);
}
function RM(t, e, n) {
  const r = this.cache, s = n.allocateTextureUnit();
  r[0] !== s && (t.uniform1i(this.addr, s), r[0] = s), n.setTexture3D(e || _M, s);
}
function PM(t, e, n) {
  const r = this.cache, s = n.allocateTextureUnit();
  r[0] !== s && (t.uniform1i(this.addr, s), r[0] = s), n.safeSetTextureCube(e || by, s);
}
function IM(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e);
}
function DM(t, e) {
  const n = this.cache;
  Bn(n, e) || (t.uniform2iv(this.addr, e), Sn(n, e));
}
function NM(t, e) {
  const n = this.cache;
  Bn(n, e) || (t.uniform3iv(this.addr, e), Sn(n, e));
}
function OM(t, e) {
  const n = this.cache;
  Bn(n, e) || (t.uniform4iv(this.addr, e), Sn(n, e));
}
function FM(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e);
}
function BM(t) {
  switch (t) {
    case 5126:
      return bM;
    // FLOAT
    case 35664:
      return wM;
    // _VEC2
    case 35665:
      return MM;
    // _VEC3
    case 35666:
      return SM;
    // _VEC4
    case 35674:
      return EM;
    // _MAT2
    case 35675:
      return TM;
    // _MAT3
    case 35676:
      return AM;
    // _MAT4
    case 5124:
    case 35670:
      return IM;
    // INT, BOOL
    case 35667:
    case 35671:
      return DM;
    // _VEC2
    case 35668:
    case 35672:
      return NM;
    // _VEC3
    case 35669:
    case 35673:
      return OM;
    // _VEC4
    case 5125:
      return FM;
    // UINT
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return LM;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return RM;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return PM;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return CM;
  }
}
function zM(t, e) {
  t.uniform1fv(this.addr, e);
}
function UM(t, e) {
  t.uniform1iv(this.addr, e);
}
function HM(t, e) {
  t.uniform2iv(this.addr, e);
}
function GM(t, e) {
  t.uniform3iv(this.addr, e);
}
function VM(t, e) {
  t.uniform4iv(this.addr, e);
}
function kM(t, e) {
  const n = Ko(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function WM(t, e) {
  const n = Ko(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function $M(t, e) {
  const n = Ko(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function jM(t, e) {
  const n = Ko(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function qM(t, e) {
  const n = Ko(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function XM(t, e) {
  const n = Ko(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function YM(t, e, n) {
  const r = e.length, s = wy(n, r);
  t.uniform1iv(this.addr, s);
  for (let o = 0; o !== r; ++o)
    n.safeSetTexture2D(e[o] || _y, s[o]);
}
function ZM(t, e, n) {
  const r = e.length, s = wy(n, r);
  t.uniform1iv(this.addr, s);
  for (let o = 0; o !== r; ++o)
    n.safeSetTextureCube(e[o] || by, s[o]);
}
function JM(t) {
  switch (t) {
    case 5126:
      return zM;
    // FLOAT
    case 35664:
      return kM;
    // _VEC2
    case 35665:
      return WM;
    // _VEC3
    case 35666:
      return $M;
    // _VEC4
    case 35674:
      return jM;
    // _MAT2
    case 35675:
      return qM;
    // _MAT3
    case 35676:
      return XM;
    // _MAT4
    case 5124:
    case 35670:
      return UM;
    // INT, BOOL
    case 35667:
    case 35671:
      return HM;
    // _VEC2
    case 35668:
    case 35672:
      return GM;
    // _VEC3
    case 35669:
    case 35673:
      return VM;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return YM;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return ZM;
  }
}
function KM(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.setValue = BM(e.type);
}
function My(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = JM(e.type);
}
My.prototype.updateCache = function(t) {
  const e = this.cache;
  t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Sn(e, t);
};
function Sy(t) {
  this.id = t, this.seq = [], this.map = {};
}
Sy.prototype.setValue = function(t, e, n) {
  const r = this.seq;
  for (let s = 0, o = r.length; s !== o; ++s) {
    const a = r[s];
    a.setValue(t, e[a.id], n);
  }
};
const Ou = /(\w+)(\])?(\[|\.)?/g;
function Qp(t, e) {
  t.seq.push(e), t.map[e.id] = e;
}
function QM(t, e, n) {
  const r = t.name, s = r.length;
  for (Ou.lastIndex = 0; ; ) {
    const o = Ou.exec(r), a = Ou.lastIndex;
    let l = o[1];
    const c = o[2] === "]", h = o[3];
    if (c && (l = l | 0), h === void 0 || h === "[" && a + 2 === s) {
      Qp(n, h === void 0 ? new KM(l, t, e) : new My(l, t, e));
      break;
    } else {
      let u = n.map[l];
      u === void 0 && (u = new Sy(l), Qp(n, u)), n = u;
    }
  }
}
function Nr(t, e) {
  this.seq = [], this.map = {};
  const n = t.getProgramParameter(e, 35718);
  for (let r = 0; r < n; ++r) {
    const s = t.getActiveUniform(e, r), o = t.getUniformLocation(e, s.name);
    QM(s, o, this);
  }
}
Nr.prototype.setValue = function(t, e, n, r) {
  const s = this.map[e];
  s !== void 0 && s.setValue(t, n, r);
};
Nr.prototype.setOptional = function(t, e, n) {
  const r = e[n];
  r !== void 0 && this.setValue(t, n, r);
};
Nr.upload = function(t, e, n, r) {
  for (let s = 0, o = e.length; s !== o; ++s) {
    const a = e[s], l = n[a.id];
    l.needsUpdate !== !1 && a.setValue(t, l.value, r);
  }
};
Nr.seqWithValue = function(t, e) {
  const n = [];
  for (let r = 0, s = t.length; r !== s; ++r) {
    const o = t[r];
    o.id in e && n.push(o);
  }
  return n;
};
function em(t, e, n) {
  const r = t.createShader(e);
  return t.shaderSource(r, n), t.compileShader(r), r;
}
let eS = 0;
function tS(t) {
  const e = t.split(`
`);
  for (let n = 0; n < e.length; n++)
    e[n] = n + 1 + ": " + e[n];
  return e.join(`
`);
}
function Ey(t) {
  switch (t) {
    case Dl:
      return ["Linear", "( value )"];
    case qf:
      return ["sRGB", "( value )"];
    case u_:
      return ["RGBE", "( value )"];
    case f_:
      return ["RGBM", "( value, 7.0 )"];
    case p_:
      return ["RGBM", "( value, 16.0 )"];
    case m_:
      return ["RGBD", "( value, 256.0 )"];
    case h_:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case d_:
      return ["LogLuv", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];
  }
}
function tm(t, e, n) {
  const r = t.getShaderParameter(e, 35713), s = t.getShaderInfoLog(e).trim();
  if (r && s === "") return "";
  const o = t.getShaderSource(e);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + `
` + s + tS(o);
}
function ha(t, e) {
  const n = Ey(e);
  return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
}
function nS(t, e) {
  const n = Ey(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}
function iS(t, e) {
  let n;
  switch (e) {
    case l0:
      n = "Linear";
      break;
    case c0:
      n = "Reinhard";
      break;
    case h0:
      n = "OptimizedCineon";
      break;
    case u0:
      n = "ACESFilmic";
      break;
    case d0:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
function rS(t) {
  return [
    t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || t.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(La).join(`
`);
}
function sS(t) {
  const e = [];
  for (const n in t) {
    const r = t[n];
    r !== !1 && e.push("#define " + n + " " + r);
  }
  return e.join(`
`);
}
function oS(t, e) {
  const n = {}, r = t.getProgramParameter(e, 35721);
  for (let s = 0; s < r; s++) {
    const a = t.getActiveAttrib(e, s).name;
    n[a] = t.getAttribLocation(e, a);
  }
  return n;
}
function La(t) {
  return t !== "";
}
function nm(t, e) {
  return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function im(t, e) {
  return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const aS = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Id(t) {
  return t.replace(aS, lS);
}
function lS(t, e) {
  const n = tt[e];
  if (n === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return Id(n);
}
const cS = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, hS = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function rm(t) {
  return t.replace(hS, Ty).replace(cS, uS);
}
function uS(t, e, n, r) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ty(t, e, n, r);
}
function Ty(t, e, n, r) {
  let s = "";
  for (let o = parseInt(e); o < parseInt(n); o++)
    s += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return s;
}
function sm(t) {
  let e = "precision " + t.precision + ` float;
precision ` + t.precision + " int;";
  return t.precision === "highp" ? e += `
#define HIGH_PRECISION` : t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : t.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function dS(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return t.shadowMapType === sy ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === Hx ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === Aa && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function fS(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case Gf:
      case Vf:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case kf:
      case Wf:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function pS(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case Vf:
      case Wf:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function mS(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case Zh:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case o0:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case a0:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function gS(t, e, n, r) {
  const s = t.getContext(), o = n.defines;
  let a = n.vertexShader, l = n.fragmentShader;
  const c = dS(n), h = fS(n), d = pS(n), u = mS(n), p = t.gammaFactor > 0 ? t.gammaFactor : 1, f = n.isWebGL2 ? "" : rS(n), m = sS(o), y = s.createProgram();
  let x, v, g = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (x = [
    m
  ].filter(La).join(`
`), x.length > 0 && (x += `
`), v = [
    f,
    m
  ].filter(La).join(`
`), v.length > 0 && (v += `
`)) : (x = [
    sm(n),
    "#define SHADER_NAME " + n.shaderName,
    m,
    n.instancing ? "#define USE_INSTANCING" : "",
    n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    "#define GAMMA_FACTOR " + p,
    "#define MAX_BONES " + n.maxBones,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + d : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.vertexTangents ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexUvs ? "#define USE_UV" : "",
    n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.useVertexTexture ? "#define BONE_TEXTURE" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#ifdef USE_COLOR",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_MORPHTARGETS",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(La).join(`
`), v = [
    f,
    sm(n),
    "#define SHADER_NAME " + n.shaderName,
    m,
    n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "",
    // add '.0' if integer
    "#define GAMMA_FACTOR " + p,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + h : "",
    n.envMap ? "#define " + d : "",
    n.envMap ? "#define " + u : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.vertexTangents ? "#define USE_TANGENT" : "",
    n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
    n.vertexUvs ? "#define USE_UV" : "",
    n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== Na ? "#define TONE_MAPPING" : "",
    n.toneMapping !== Na ? tt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== Na ? iS("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    tt.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    n.map ? ha("mapTexelToLinear", n.mapEncoding) : "",
    n.matcap ? ha("matcapTexelToLinear", n.matcapEncoding) : "",
    n.envMap ? ha("envMapTexelToLinear", n.envMapEncoding) : "",
    n.emissiveMap ? ha("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "",
    n.lightMap ? ha("lightMapTexelToLinear", n.lightMapEncoding) : "",
    nS("linearToOutputTexel", n.outputEncoding),
    n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(La).join(`
`)), a = Id(a), a = nm(a, n), a = im(a, n), l = Id(l), l = nm(l, n), l = im(l, n), a = rm(a), l = rm(l), n.isWebGL2 && n.isRawShaderMaterial !== !0 && (g = `#version 300 es
`, x = [
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + x, v = [
    "#define varying in",
    n.glslVersion === Fp ? "" : "out highp vec4 pc_fragColor;",
    n.glslVersion === Fp ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + v);
  const S = g + x + a, T = g + v + l, E = em(s, 35633, S), w = em(s, 35632, T);
  if (s.attachShader(y, E), s.attachShader(y, w), n.index0AttributeName !== void 0 ? s.bindAttribLocation(y, 0, n.index0AttributeName) : n.morphTargets === !0 && s.bindAttribLocation(y, 0, "position"), s.linkProgram(y), t.debug.checkShaderErrors) {
    const Y = s.getProgramInfoLog(y).trim(), le = s.getShaderInfoLog(E).trim(), B = s.getShaderInfoLog(w).trim();
    let Z = !0, k = !0;
    if (s.getProgramParameter(y, 35714) === !1) {
      Z = !1;
      const O = tm(s, E, "vertex"), P = tm(s, w, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(y, 35715), "gl.getProgramInfoLog", Y, O, P);
    } else Y !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", Y) : (le === "" || B === "") && (k = !1);
    k && (this.diagnostics = {
      runnable: Z,
      programLog: Y,
      vertexShader: {
        log: le,
        prefix: x
      },
      fragmentShader: {
        log: B,
        prefix: v
      }
    });
  }
  s.deleteShader(E), s.deleteShader(w);
  let C;
  this.getUniforms = function() {
    return C === void 0 && (C = new Nr(s, y)), C;
  };
  let ee;
  return this.getAttributes = function() {
    return ee === void 0 && (ee = oS(s, y)), ee;
  }, this.destroy = function() {
    r.releaseStatesOfProgram(this), s.deleteProgram(y), this.program = void 0;
  }, this.name = n.shaderName, this.id = eS++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = E, this.fragmentShader = w, this;
}
function vS(t, e, n, r, s, o) {
  const a = [], l = r.isWebGL2, c = r.logarithmicDepthBuffer, h = r.floatVertexTextures, d = r.maxVertexUniforms, u = r.vertexTextures;
  let p = r.precision;
  const f = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  }, m = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function y(w) {
    const ee = w.skeleton.bones;
    if (h)
      return 1024;
    {
      const le = Math.floor((d - 20) / 4), B = Math.min(le, ee.length);
      return B < ee.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + ee.length + " bones. This GPU supports " + B + "."), 0) : B;
    }
  }
  function x(w) {
    let C;
    return w && w.isTexture ? C = w.encoding : w && w.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), C = w.texture.encoding) : C = Dl, C;
  }
  function v(w, C, ee, Y, le) {
    const B = Y.fog, Z = w.isMeshStandardMaterial ? Y.environment : null, k = e.get(w.envMap || Z), O = f[w.type], P = le.isSkinnedMesh ? y(le) : 0;
    w.precision !== null && (p = r.getMaxPrecision(w.precision), p !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", p, "instead."));
    let j, re;
    if (O) {
      const pe = ni[O];
      j = pe.vertexShader, re = pe.fragmentShader;
    } else
      j = w.vertexShader, re = w.fragmentShader;
    const ae = t.getRenderTarget();
    return {
      isWebGL2: l,
      shaderID: O,
      shaderName: w.type,
      vertexShader: j,
      fragmentShader: re,
      defines: w.defines,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: p,
      instancing: le.isInstancedMesh === !0,
      instancingColor: le.isInstancedMesh === !0 && le.instanceColor !== null,
      supportsVertexTextures: u,
      outputEncoding: ae !== null ? x(ae.texture) : t.outputEncoding,
      map: !!w.map,
      mapEncoding: x(w.map),
      matcap: !!w.matcap,
      matcapEncoding: x(w.matcap),
      envMap: !!k,
      envMapMode: k && k.mapping,
      envMapEncoding: x(k),
      envMapCubeUV: !!k && (k.mapping === kf || k.mapping === Wf),
      lightMap: !!w.lightMap,
      lightMapEncoding: x(w.lightMap),
      aoMap: !!w.aoMap,
      emissiveMap: !!w.emissiveMap,
      emissiveMapEncoding: x(w.emissiveMap),
      bumpMap: !!w.bumpMap,
      normalMap: !!w.normalMap,
      objectSpaceNormalMap: w.normalMapType === y_,
      tangentSpaceNormalMap: w.normalMapType === As,
      clearcoatMap: !!w.clearcoatMap,
      clearcoatRoughnessMap: !!w.clearcoatRoughnessMap,
      clearcoatNormalMap: !!w.clearcoatNormalMap,
      displacementMap: !!w.displacementMap,
      roughnessMap: !!w.roughnessMap,
      metalnessMap: !!w.metalnessMap,
      specularMap: !!w.specularMap,
      alphaMap: !!w.alphaMap,
      gradientMap: !!w.gradientMap,
      sheen: !!w.sheen,
      transmissionMap: !!w.transmissionMap,
      combine: w.combine,
      vertexTangents: w.normalMap && w.vertexTangents,
      vertexColors: w.vertexColors,
      vertexUvs: !!w.map || !!w.bumpMap || !!w.normalMap || !!w.specularMap || !!w.alphaMap || !!w.emissiveMap || !!w.roughnessMap || !!w.metalnessMap || !!w.clearcoatMap || !!w.clearcoatRoughnessMap || !!w.clearcoatNormalMap || !!w.displacementMap || !!w.transmissionMap,
      uvsVertexOnly: !(w.map || w.bumpMap || w.normalMap || w.specularMap || w.alphaMap || w.emissiveMap || w.roughnessMap || w.metalnessMap || w.clearcoatNormalMap || w.transmissionMap) && !!w.displacementMap,
      fog: !!B,
      useFog: w.fog,
      fogExp2: B && B.isFogExp2,
      flatShading: w.flatShading,
      sizeAttenuation: w.sizeAttenuation,
      logarithmicDepthBuffer: c,
      skinning: w.skinning && P > 0,
      maxBones: P,
      useVertexTexture: h,
      morphTargets: w.morphTargets,
      morphNormals: w.morphNormals,
      maxMorphTargets: t.maxMorphTargets,
      maxMorphNormals: t.maxMorphNormals,
      numDirLights: C.directional.length,
      numPointLights: C.point.length,
      numSpotLights: C.spot.length,
      numRectAreaLights: C.rectArea.length,
      numHemiLights: C.hemi.length,
      numDirLightShadows: C.directionalShadowMap.length,
      numPointLightShadows: C.pointShadowMap.length,
      numSpotLightShadows: C.spotShadowMap.length,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: t.shadowMap.enabled && ee.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: w.toneMapped ? t.toneMapping : Na,
      physicallyCorrectLights: t.physicallyCorrectLights,
      premultipliedAlpha: w.premultipliedAlpha,
      alphaTest: w.alphaTest,
      doubleSided: w.side === Zo,
      flipSided: w.side === Ut,
      depthPacking: w.depthPacking !== void 0 ? w.depthPacking : !1,
      index0AttributeName: w.index0AttributeName,
      extensionDerivatives: w.extensions && w.extensions.derivatives,
      extensionFragDepth: w.extensions && w.extensions.fragDepth,
      extensionDrawBuffers: w.extensions && w.extensions.drawBuffers,
      extensionShaderTextureLOD: w.extensions && w.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: l || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: w.customProgramCacheKey()
    };
  }
  function g(w) {
    const C = [];
    if (w.shaderID ? C.push(w.shaderID) : (C.push(w.fragmentShader), C.push(w.vertexShader)), w.defines !== void 0)
      for (const ee in w.defines)
        C.push(ee), C.push(w.defines[ee]);
    if (w.isRawShaderMaterial === !1) {
      for (let ee = 0; ee < m.length; ee++)
        C.push(w[m[ee]]);
      C.push(t.outputEncoding), C.push(t.gammaFactor);
    }
    return C.push(w.customProgramCacheKey), C.join();
  }
  function S(w) {
    const C = f[w.type];
    let ee;
    if (C) {
      const Y = ni[C];
      ee = yy.clone(Y.uniforms);
    } else
      ee = w.uniforms;
    return ee;
  }
  function T(w, C) {
    let ee;
    for (let Y = 0, le = a.length; Y < le; Y++) {
      const B = a[Y];
      if (B.cacheKey === C) {
        ee = B, ++ee.usedTimes;
        break;
      }
    }
    return ee === void 0 && (ee = new gS(t, C, w, s), a.push(ee)), ee;
  }
  function E(w) {
    if (--w.usedTimes === 0) {
      const C = a.indexOf(w);
      a[C] = a[a.length - 1], a.pop(), w.destroy();
    }
  }
  return {
    getParameters: v,
    getProgramCacheKey: g,
    getUniforms: S,
    acquireProgram: T,
    releaseProgram: E,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: a
  };
}
function yS() {
  let t = /* @__PURE__ */ new WeakMap();
  function e(o) {
    let a = t.get(o);
    return a === void 0 && (a = {}, t.set(o, a)), a;
  }
  function n(o) {
    t.delete(o);
  }
  function r(o, a, l) {
    t.get(o)[a] = l;
  }
  function s() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: n,
    update: r,
    dispose: s
  };
}
function xS(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
}
function _S(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
}
function om(t) {
  const e = [];
  let n = 0;
  const r = [], s = [], o = { id: -1 };
  function a() {
    n = 0, r.length = 0, s.length = 0;
  }
  function l(p, f, m, y, x, v) {
    let g = e[n];
    const S = t.get(m);
    return g === void 0 ? (g = {
      id: p.id,
      object: p,
      geometry: f,
      material: m,
      program: S.program || o,
      groupOrder: y,
      renderOrder: p.renderOrder,
      z: x,
      group: v
    }, e[n] = g) : (g.id = p.id, g.object = p, g.geometry = f, g.material = m, g.program = S.program || o, g.groupOrder = y, g.renderOrder = p.renderOrder, g.z = x, g.group = v), n++, g;
  }
  function c(p, f, m, y, x, v) {
    const g = l(p, f, m, y, x, v);
    (m.transparent === !0 ? s : r).push(g);
  }
  function h(p, f, m, y, x, v) {
    const g = l(p, f, m, y, x, v);
    (m.transparent === !0 ? s : r).unshift(g);
  }
  function d(p, f) {
    r.length > 1 && r.sort(p || xS), s.length > 1 && s.sort(f || _S);
  }
  function u() {
    for (let p = n, f = e.length; p < f; p++) {
      const m = e[p];
      if (m.id === null) break;
      m.id = null, m.object = null, m.geometry = null, m.material = null, m.program = null, m.group = null;
    }
  }
  return {
    opaque: r,
    transparent: s,
    init: a,
    push: c,
    unshift: h,
    finish: u,
    sort: d
  };
}
function bS(t) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(s, o) {
    const a = e.get(s);
    let l;
    return a === void 0 ? (l = new om(t), e.set(s, /* @__PURE__ */ new WeakMap()), e.get(s).set(o, l)) : (l = a.get(o), l === void 0 && (l = new om(t), a.set(o, l))), l;
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
function wS() {
  const t = {};
  return {
    get: function(e) {
      if (t[e.id] !== void 0)
        return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new z(),
            color: new Ne()
          };
          break;
        case "SpotLight":
          n = {
            position: new z(),
            direction: new z(),
            color: new Ne(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new z(),
            color: new Ne(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new z(),
            skyColor: new Ne(),
            groundColor: new Ne()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new Ne(),
            position: new z(),
            halfWidth: new z(),
            halfHeight: new z()
          };
          break;
      }
      return t[e.id] = n, n;
    }
  };
}
function MS() {
  const t = {};
  return {
    get: function(e) {
      if (t[e.id] !== void 0)
        return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ye()
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ye()
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ye(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return t[e.id] = n, n;
    }
  };
}
let SS = 0;
function ES(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}
function TS(t, e) {
  const n = new wS(), r = MS(), s = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let d = 0; d < 9; d++) s.probe.push(new z());
  const o = new z(), a = new Je(), l = new Je();
  function c(d) {
    let u = 0, p = 0, f = 0;
    for (let C = 0; C < 9; C++) s.probe[C].set(0, 0, 0);
    let m = 0, y = 0, x = 0, v = 0, g = 0, S = 0, T = 0, E = 0;
    d.sort(ES);
    for (let C = 0, ee = d.length; C < ee; C++) {
      const Y = d[C], le = Y.color, B = Y.intensity, Z = Y.distance, k = Y.shadow && Y.shadow.map ? Y.shadow.map.texture : null;
      if (Y.isAmbientLight)
        u += le.r * B, p += le.g * B, f += le.b * B;
      else if (Y.isLightProbe)
        for (let O = 0; O < 9; O++)
          s.probe[O].addScaledVector(Y.sh.coefficients[O], B);
      else if (Y.isDirectionalLight) {
        const O = n.get(Y);
        if (O.color.copy(Y.color).multiplyScalar(Y.intensity), Y.castShadow) {
          const P = Y.shadow, j = r.get(Y);
          j.shadowBias = P.bias, j.shadowNormalBias = P.normalBias, j.shadowRadius = P.radius, j.shadowMapSize = P.mapSize, s.directionalShadow[m] = j, s.directionalShadowMap[m] = k, s.directionalShadowMatrix[m] = Y.shadow.matrix, S++;
        }
        s.directional[m] = O, m++;
      } else if (Y.isSpotLight) {
        const O = n.get(Y);
        if (O.position.setFromMatrixPosition(Y.matrixWorld), O.color.copy(le).multiplyScalar(B), O.distance = Z, O.coneCos = Math.cos(Y.angle), O.penumbraCos = Math.cos(Y.angle * (1 - Y.penumbra)), O.decay = Y.decay, Y.castShadow) {
          const P = Y.shadow, j = r.get(Y);
          j.shadowBias = P.bias, j.shadowNormalBias = P.normalBias, j.shadowRadius = P.radius, j.shadowMapSize = P.mapSize, s.spotShadow[x] = j, s.spotShadowMap[x] = k, s.spotShadowMatrix[x] = Y.shadow.matrix, E++;
        }
        s.spot[x] = O, x++;
      } else if (Y.isRectAreaLight) {
        const O = n.get(Y);
        O.color.copy(le).multiplyScalar(B), O.halfWidth.set(Y.width * 0.5, 0, 0), O.halfHeight.set(0, Y.height * 0.5, 0), s.rectArea[v] = O, v++;
      } else if (Y.isPointLight) {
        const O = n.get(Y);
        if (O.color.copy(Y.color).multiplyScalar(Y.intensity), O.distance = Y.distance, O.decay = Y.decay, Y.castShadow) {
          const P = Y.shadow, j = r.get(Y);
          j.shadowBias = P.bias, j.shadowNormalBias = P.normalBias, j.shadowRadius = P.radius, j.shadowMapSize = P.mapSize, j.shadowCameraNear = P.camera.near, j.shadowCameraFar = P.camera.far, s.pointShadow[y] = j, s.pointShadowMap[y] = k, s.pointShadowMatrix[y] = Y.shadow.matrix, T++;
        }
        s.point[y] = O, y++;
      } else if (Y.isHemisphereLight) {
        const O = n.get(Y);
        O.skyColor.copy(Y.color).multiplyScalar(B), O.groundColor.copy(Y.groundColor).multiplyScalar(B), s.hemi[g] = O, g++;
      }
    }
    v > 0 && (e.isWebGL2 || t.has("OES_texture_float_linear") === !0 ? (s.rectAreaLTC1 = Ae.LTC_FLOAT_1, s.rectAreaLTC2 = Ae.LTC_FLOAT_2) : t.has("OES_texture_half_float_linear") === !0 ? (s.rectAreaLTC1 = Ae.LTC_HALF_1, s.rectAreaLTC2 = Ae.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), s.ambient[0] = u, s.ambient[1] = p, s.ambient[2] = f;
    const w = s.hash;
    (w.directionalLength !== m || w.pointLength !== y || w.spotLength !== x || w.rectAreaLength !== v || w.hemiLength !== g || w.numDirectionalShadows !== S || w.numPointShadows !== T || w.numSpotShadows !== E) && (s.directional.length = m, s.spot.length = x, s.rectArea.length = v, s.point.length = y, s.hemi.length = g, s.directionalShadow.length = S, s.directionalShadowMap.length = S, s.pointShadow.length = T, s.pointShadowMap.length = T, s.spotShadow.length = E, s.spotShadowMap.length = E, s.directionalShadowMatrix.length = S, s.pointShadowMatrix.length = T, s.spotShadowMatrix.length = E, w.directionalLength = m, w.pointLength = y, w.spotLength = x, w.rectAreaLength = v, w.hemiLength = g, w.numDirectionalShadows = S, w.numPointShadows = T, w.numSpotShadows = E, s.version = SS++);
  }
  function h(d, u) {
    let p = 0, f = 0, m = 0, y = 0, x = 0;
    const v = u.matrixWorldInverse;
    for (let g = 0, S = d.length; g < S; g++) {
      const T = d[g];
      if (T.isDirectionalLight) {
        const E = s.directional[p];
        E.direction.setFromMatrixPosition(T.matrixWorld), o.setFromMatrixPosition(T.target.matrixWorld), E.direction.sub(o), E.direction.transformDirection(v), p++;
      } else if (T.isSpotLight) {
        const E = s.spot[m];
        E.position.setFromMatrixPosition(T.matrixWorld), E.position.applyMatrix4(v), E.direction.setFromMatrixPosition(T.matrixWorld), o.setFromMatrixPosition(T.target.matrixWorld), E.direction.sub(o), E.direction.transformDirection(v), m++;
      } else if (T.isRectAreaLight) {
        const E = s.rectArea[y];
        E.position.setFromMatrixPosition(T.matrixWorld), E.position.applyMatrix4(v), l.identity(), a.copy(T.matrixWorld), a.premultiply(v), l.extractRotation(a), E.halfWidth.set(T.width * 0.5, 0, 0), E.halfHeight.set(0, T.height * 0.5, 0), E.halfWidth.applyMatrix4(l), E.halfHeight.applyMatrix4(l), y++;
      } else if (T.isPointLight) {
        const E = s.point[f];
        E.position.setFromMatrixPosition(T.matrixWorld), E.position.applyMatrix4(v), f++;
      } else if (T.isHemisphereLight) {
        const E = s.hemi[x];
        E.direction.setFromMatrixPosition(T.matrixWorld), E.direction.transformDirection(v), E.direction.normalize(), x++;
      }
    }
  }
  return {
    setup: c,
    setupView: h,
    state: s
  };
}
function am(t, e) {
  const n = new TS(t, e), r = [], s = [];
  function o() {
    r.length = 0, s.length = 0;
  }
  function a(u) {
    r.push(u);
  }
  function l(u) {
    s.push(u);
  }
  function c() {
    n.setup(r);
  }
  function h(u) {
    n.setupView(r, u);
  }
  return {
    init: o,
    state: {
      lightsArray: r,
      shadowsArray: s,
      lights: n
    },
    setupLights: c,
    setupLightsView: h,
    pushLight: a,
    pushShadow: l
  };
}
function AS(t, e) {
  let n = /* @__PURE__ */ new WeakMap();
  function r(o, a = 0) {
    let l;
    return n.has(o) === !1 ? (l = new am(t, e), n.set(o, []), n.get(o).push(l)) : a >= n.get(o).length ? (l = new am(t, e), n.get(o).push(l)) : l = n.get(o)[a], l;
  }
  function s() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: s
  };
}
function gs(t) {
  Ve.call(this), this.type = "MeshDepthMaterial", this.depthPacking = g_, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t);
}
gs.prototype = Object.create(Ve.prototype);
gs.prototype.constructor = gs;
gs.prototype.isMeshDepthMaterial = !0;
gs.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
};
function vs(t) {
  Ve.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new z(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t);
}
vs.prototype = Object.create(Ve.prototype);
vs.prototype.constructor = vs;
vs.prototype.isMeshDistanceMaterial = !0;
vs.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
};
var LS = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`, CS = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
function Ay(t, e, n) {
  let r = new Kh();
  const s = new ye(), o = new ye(), a = new ht(), l = [], c = [], h = {}, d = { 0: Ut, 1: Pl, 2: Zo }, u = new rn({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ye() },
      radius: { value: 4 }
    },
    vertexShader: CS,
    fragmentShader: LS
  }), p = u.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const f = new it();
  f.setAttribute(
    "position",
    new We(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const m = new Tt(f, u), y = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = sy, this.render = function(E, w, C) {
    if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || E.length === 0) return;
    const ee = t.getRenderTarget(), Y = t.getActiveCubeFace(), le = t.getActiveMipmapLevel(), B = t.state;
    B.setBlending(Ia), B.buffers.color.setClear(1, 1, 1, 1), B.buffers.depth.setTest(!0), B.setScissorTest(!1);
    for (let Z = 0, k = E.length; Z < k; Z++) {
      const O = E[Z], P = O.shadow;
      if (P === void 0) {
        console.warn("THREE.WebGLShadowMap:", O, "has no shadow.");
        continue;
      }
      if (P.autoUpdate === !1 && P.needsUpdate === !1) continue;
      s.copy(P.mapSize);
      const j = P.getFrameExtents();
      if (s.multiply(j), o.copy(P.mapSize), (s.x > n || s.y > n) && (s.x > n && (o.x = Math.floor(n / j.x), s.x = o.x * j.x, P.mapSize.x = o.x), s.y > n && (o.y = Math.floor(n / j.y), s.y = o.y * j.y, P.mapSize.y = o.y)), P.map === null && !P.isPointLightShadow && this.type === Aa) {
        const ae = { minFilter: Ht, magFilter: Ht, format: ri };
        P.map = new si(s.x, s.y, ae), P.map.texture.name = O.name + ".shadowMap", P.mapPass = new si(s.x, s.y, ae), P.camera.updateProjectionMatrix();
      }
      if (P.map === null) {
        const ae = { minFilter: qt, magFilter: qt, format: ri };
        P.map = new si(s.x, s.y, ae), P.map.texture.name = O.name + ".shadowMap", P.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(P.map), t.clear();
      const re = P.getViewportCount();
      for (let ae = 0; ae < re; ae++) {
        const ce = P.getViewport(ae);
        a.set(
          o.x * ce.x,
          o.y * ce.y,
          o.x * ce.z,
          o.y * ce.w
        ), B.viewport(a), P.updateMatrices(O, ae), r = P.getFrustum(), T(w, C, P.camera, O, this.type);
      }
      !P.isPointLightShadow && this.type === Aa && x(P, C), P.needsUpdate = !1;
    }
    y.needsUpdate = !1, t.setRenderTarget(ee, Y, le);
  };
  function x(E, w) {
    const C = e.update(m);
    u.uniforms.shadow_pass.value = E.map.texture, u.uniforms.resolution.value = E.mapSize, u.uniforms.radius.value = E.radius, t.setRenderTarget(E.mapPass), t.clear(), t.renderBufferDirect(w, null, C, u, m, null), p.uniforms.shadow_pass.value = E.mapPass.texture, p.uniforms.resolution.value = E.mapSize, p.uniforms.radius.value = E.radius, t.setRenderTarget(E.map), t.clear(), t.renderBufferDirect(w, null, C, p, m, null);
  }
  function v(E, w, C) {
    const ee = E << 0 | w << 1 | C << 2;
    let Y = l[ee];
    return Y === void 0 && (Y = new gs({
      depthPacking: v_,
      morphTargets: E,
      skinning: w
    }), l[ee] = Y), Y;
  }
  function g(E, w, C) {
    const ee = E << 0 | w << 1 | C << 2;
    let Y = c[ee];
    return Y === void 0 && (Y = new vs({
      morphTargets: E,
      skinning: w
    }), c[ee] = Y), Y;
  }
  function S(E, w, C, ee, Y, le, B) {
    let Z = null, k = v, O = E.customDepthMaterial;
    if (ee.isPointLight === !0 && (k = g, O = E.customDistanceMaterial), O === void 0) {
      let P = !1;
      C.morphTargets === !0 && (P = w.morphAttributes && w.morphAttributes.position && w.morphAttributes.position.length > 0);
      let j = !1;
      E.isSkinnedMesh === !0 && (C.skinning === !0 ? j = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", E));
      const re = E.isInstancedMesh === !0;
      Z = k(P, j, re);
    } else
      Z = O;
    if (t.localClippingEnabled && C.clipShadows === !0 && C.clippingPlanes.length !== 0) {
      const P = Z.uuid, j = C.uuid;
      let re = h[P];
      re === void 0 && (re = {}, h[P] = re);
      let ae = re[j];
      ae === void 0 && (ae = Z.clone(), re[j] = ae), Z = ae;
    }
    return Z.visible = C.visible, Z.wireframe = C.wireframe, B === Aa ? Z.side = C.shadowSide !== null ? C.shadowSide : C.side : Z.side = C.shadowSide !== null ? C.shadowSide : d[C.side], Z.clipShadows = C.clipShadows, Z.clippingPlanes = C.clippingPlanes, Z.clipIntersection = C.clipIntersection, Z.wireframeLinewidth = C.wireframeLinewidth, Z.linewidth = C.linewidth, ee.isPointLight === !0 && Z.isMeshDistanceMaterial === !0 && (Z.referencePosition.setFromMatrixPosition(ee.matrixWorld), Z.nearDistance = Y, Z.farDistance = le), Z;
  }
  function T(E, w, C, ee, Y) {
    if (E.visible === !1) return;
    if (E.layers.test(w.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && Y === Aa) && (!E.frustumCulled || r.intersectsObject(E))) {
      E.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, E.matrixWorld);
      const Z = e.update(E), k = E.material;
      if (Array.isArray(k)) {
        const O = Z.groups;
        for (let P = 0, j = O.length; P < j; P++) {
          const re = O[P], ae = k[re.materialIndex];
          if (ae && ae.visible) {
            const ce = S(E, Z, ae, ee, C.near, C.far, Y);
            t.renderBufferDirect(C, null, Z, ce, E, re);
          }
        }
      } else if (k.visible) {
        const O = S(E, Z, k, ee, C.near, C.far, Y);
        t.renderBufferDirect(C, null, Z, O, E, null);
      }
    }
    const B = E.children;
    for (let Z = 0, k = B.length; Z < k; Z++)
      T(B[Z], w, C, ee, Y);
  }
}
function RS(t, e, n) {
  const r = n.isWebGL2;
  function s() {
    let A = !1;
    const ie = new ht();
    let oe = null;
    const he = new ht(0, 0, 0, 0);
    return {
      setMask: function(se) {
        oe !== se && !A && (t.colorMask(se, se, se, se), oe = se);
      },
      setLocked: function(se) {
        A = se;
      },
      setClear: function(se, me, ve, be, fe) {
        fe === !0 && (se *= be, me *= be, ve *= be), ie.set(se, me, ve, be), he.equals(ie) === !1 && (t.clearColor(se, me, ve, be), he.copy(ie));
      },
      reset: function() {
        A = !1, oe = null, he.set(-1, 0, 0, 0);
      }
    };
  }
  function o() {
    let A = !1, ie = null, oe = null, he = null;
    return {
      setTest: function(se) {
        se ? pe(2929) : de(2929);
      },
      setMask: function(se) {
        ie !== se && !A && (t.depthMask(se), ie = se);
      },
      setFunc: function(se) {
        if (oe !== se) {
          if (se)
            switch (se) {
              case Qx:
                t.depthFunc(512);
                break;
              case e0:
                t.depthFunc(519);
                break;
              case t0:
                t.depthFunc(513);
                break;
              case Md:
                t.depthFunc(515);
                break;
              case n0:
                t.depthFunc(514);
                break;
              case i0:
                t.depthFunc(518);
                break;
              case r0:
                t.depthFunc(516);
                break;
              case s0:
                t.depthFunc(517);
                break;
              default:
                t.depthFunc(515);
            }
          else
            t.depthFunc(515);
          oe = se;
        }
      },
      setLocked: function(se) {
        A = se;
      },
      setClear: function(se) {
        he !== se && (t.clearDepth(se), he = se);
      },
      reset: function() {
        A = !1, ie = null, oe = null, he = null;
      }
    };
  }
  function a() {
    let A = !1, ie = null, oe = null, he = null, se = null, me = null, ve = null, be = null, fe = null;
    return {
      setTest: function(_e) {
        A || (_e ? pe(2960) : de(2960));
      },
      setMask: function(_e) {
        ie !== _e && !A && (t.stencilMask(_e), ie = _e);
      },
      setFunc: function(_e, Pe, rt) {
        (oe !== _e || he !== Pe || se !== rt) && (t.stencilFunc(_e, Pe, rt), oe = _e, he = Pe, se = rt);
      },
      setOp: function(_e, Pe, rt) {
        (me !== _e || ve !== Pe || be !== rt) && (t.stencilOp(_e, Pe, rt), me = _e, ve = Pe, be = rt);
      },
      setLocked: function(_e) {
        A = _e;
      },
      setClear: function(_e) {
        fe !== _e && (t.clearStencil(_e), fe = _e);
      },
      reset: function() {
        A = !1, ie = null, oe = null, he = null, se = null, me = null, ve = null, be = null, fe = null;
      }
    };
  }
  const l = new s(), c = new o(), h = new a();
  let d = {}, u = null, p = null, f = null, m = null, y = null, x = null, v = null, g = null, S = null, T = !1, E = null, w = null, C = null, ee = null, Y = null;
  const le = t.getParameter(35661);
  let B = !1, Z = 0;
  const k = t.getParameter(7938);
  k.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec(k)[1]), B = Z >= 1) : k.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec(k)[1]), B = Z >= 2);
  let O = null, P = {};
  const j = new ht(), re = new ht();
  function ae(A, ie, oe) {
    const he = new Uint8Array(4), se = t.createTexture();
    t.bindTexture(A, se), t.texParameteri(A, 10241, 9728), t.texParameteri(A, 10240, 9728);
    for (let me = 0; me < oe; me++)
      t.texImage2D(ie + me, 0, 6408, 1, 1, 0, 6408, 5121, he);
    return se;
  }
  const ce = {};
  ce[3553] = ae(3553, 3553, 1), ce[34067] = ae(34067, 34069, 6), l.setClear(0, 0, 0, 1), c.setClear(1), h.setClear(0), pe(2929), c.setFunc(Md), L(!1), U(yp), pe(2884), te(Ia);
  function pe(A) {
    d[A] !== !0 && (t.enable(A), d[A] = !0);
  }
  function de(A) {
    d[A] !== !1 && (t.disable(A), d[A] = !1);
  }
  function ge(A) {
    return u !== A ? (t.useProgram(A), u = A, !0) : !1;
  }
  const we = {
    [oo]: 32774,
    [Vx]: 32778,
    [kx]: 32779
  };
  if (r)
    we[wp] = 32775, we[Mp] = 32776;
  else {
    const A = e.get("EXT_blend_minmax");
    A !== null && (we[wp] = A.MIN_EXT, we[Mp] = A.MAX_EXT);
  }
  const Ge = {
    [Wx]: 0,
    [$x]: 1,
    [jx]: 768,
    [ay]: 770,
    [Kx]: 776,
    [Zx]: 774,
    [Xx]: 772,
    [qx]: 769,
    [ly]: 771,
    [Jx]: 775,
    [Yx]: 773
  };
  function te(A, ie, oe, he, se, me, ve, be) {
    if (A === Ia) {
      p && (de(3042), p = !1);
      return;
    }
    if (p || (pe(3042), p = !0), A !== Gx) {
      if (A !== f || be !== T) {
        if ((m !== oo || v !== oo) && (t.blendEquation(32774), m = oo, v = oo), be)
          switch (A) {
            case Da:
              t.blendFuncSeparate(1, 771, 1, 771);
              break;
            case xp:
              t.blendFunc(1, 1);
              break;
            case _p:
              t.blendFuncSeparate(0, 0, 769, 771);
              break;
            case bp:
              t.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", A);
              break;
          }
        else
          switch (A) {
            case Da:
              t.blendFuncSeparate(770, 771, 1, 771);
              break;
            case xp:
              t.blendFunc(770, 1);
              break;
            case _p:
              t.blendFunc(0, 769);
              break;
            case bp:
              t.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", A);
              break;
          }
        y = null, x = null, g = null, S = null, f = A, T = be;
      }
      return;
    }
    se = se || ie, me = me || oe, ve = ve || he, (ie !== m || se !== v) && (t.blendEquationSeparate(we[ie], we[se]), m = ie, v = se), (oe !== y || he !== x || me !== g || ve !== S) && (t.blendFuncSeparate(Ge[oe], Ge[he], Ge[me], Ge[ve]), y = oe, x = he, g = me, S = ve), f = A, T = null;
  }
  function I(A, ie) {
    A.side === Zo ? de(2884) : pe(2884);
    let oe = A.side === Ut;
    ie && (oe = !oe), L(oe), A.blending === Da && A.transparent === !1 ? te(Ia) : te(A.blending, A.blendEquation, A.blendSrc, A.blendDst, A.blendEquationAlpha, A.blendSrcAlpha, A.blendDstAlpha, A.premultipliedAlpha), c.setFunc(A.depthFunc), c.setTest(A.depthTest), c.setMask(A.depthWrite), l.setMask(A.colorWrite);
    const he = A.stencilWrite;
    h.setTest(he), he && (h.setMask(A.stencilWriteMask), h.setFunc(A.stencilFunc, A.stencilRef, A.stencilFuncMask), h.setOp(A.stencilFail, A.stencilZFail, A.stencilZPass)), V(A.polygonOffset, A.polygonOffsetFactor, A.polygonOffsetUnits);
  }
  function L(A) {
    E !== A && (A ? t.frontFace(2304) : t.frontFace(2305), E = A);
  }
  function U(A) {
    A !== zx ? (pe(2884), A !== w && (A === yp ? t.cullFace(1029) : A === Ux ? t.cullFace(1028) : t.cullFace(1032))) : de(2884), w = A;
  }
  function N(A) {
    A !== C && (B && t.lineWidth(A), C = A);
  }
  function V(A, ie, oe) {
    A ? (pe(32823), (ee !== ie || Y !== oe) && (t.polygonOffset(ie, oe), ee = ie, Y = oe)) : de(32823);
  }
  function W(A) {
    A ? pe(3089) : de(3089);
  }
  function R(A) {
    A === void 0 && (A = 33984 + le - 1), O !== A && (t.activeTexture(A), O = A);
  }
  function D(A, ie) {
    O === null && R();
    let oe = P[O];
    oe === void 0 && (oe = { type: void 0, texture: void 0 }, P[O] = oe), (oe.type !== A || oe.texture !== ie) && (t.bindTexture(A, ie || ce[A]), oe.type = A, oe.texture = ie);
  }
  function H() {
    const A = P[O];
    A !== void 0 && A.type !== void 0 && (t.bindTexture(A.type, null), A.type = void 0, A.texture = void 0);
  }
  function ne() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (A) {
      console.error("THREE.WebGLState:", A);
    }
  }
  function J() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (A) {
      console.error("THREE.WebGLState:", A);
    }
  }
  function b() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (A) {
      console.error("THREE.WebGLState:", A);
    }
  }
  function _(A) {
    j.equals(A) === !1 && (t.scissor(A.x, A.y, A.z, A.w), j.copy(A));
  }
  function Q(A) {
    re.equals(A) === !1 && (t.viewport(A.x, A.y, A.z, A.w), re.copy(A));
  }
  function X() {
    d = {}, O = null, P = {}, u = null, p = null, f = null, m = null, y = null, x = null, v = null, g = null, S = null, T = !1, E = null, w = null, C = null, ee = null, Y = null, l.reset(), c.reset(), h.reset();
  }
  return {
    buffers: {
      color: l,
      depth: c,
      stencil: h
    },
    enable: pe,
    disable: de,
    useProgram: ge,
    setBlending: te,
    setMaterial: I,
    setFlipSided: L,
    setCullFace: U,
    setLineWidth: N,
    setPolygonOffset: V,
    setScissorTest: W,
    activeTexture: R,
    bindTexture: D,
    unbindTexture: H,
    compressedTexImage2D: ne,
    texImage2D: J,
    texImage3D: b,
    scissor: _,
    viewport: Q,
    reset: X
  };
}
function PS(t, e, n, r, s, o, a) {
  const l = s.isWebGL2, c = s.maxTextures, h = s.maxCubemapSize, d = s.maxTextureSize, u = s.maxSamples, p = /* @__PURE__ */ new WeakMap();
  let f, m = !1;
  try {
    m = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function y(b, _) {
    return m ? new OffscreenCanvas(b, _) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function x(b, _, Q, X) {
    let A = 1;
    if ((b.width > X || b.height > X) && (A = X / Math.max(b.width, b.height)), A < 1 || _ === !0)
      if (typeof HTMLImageElement < "u" && b instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && b instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && b instanceof ImageBitmap) {
        const ie = _ ? $e.floorPowerOfTwo : Math.floor, oe = ie(A * b.width), he = ie(A * b.height);
        f === void 0 && (f = y(oe, he));
        const se = Q ? y(oe, he) : f;
        return se.width = oe, se.height = he, se.getContext("2d").drawImage(b, 0, 0, oe, he), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + b.width + "x" + b.height + ") to (" + oe + "x" + he + ")."), se;
      } else
        return "data" in b && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + b.width + "x" + b.height + ")."), b;
    return b;
  }
  function v(b) {
    return $e.isPowerOfTwo(b.width) && $e.isPowerOfTwo(b.height);
  }
  function g(b) {
    return l ? !1 : b.wrapS !== an || b.wrapT !== an || b.minFilter !== qt && b.minFilter !== Ht;
  }
  function S(b, _) {
    return b.generateMipmaps && _ && b.minFilter !== qt && b.minFilter !== Ht;
  }
  function T(b, _, Q, X) {
    t.generateMipmap(b);
    const A = r.get(_);
    A.__maxMipLevel = Math.log(Math.max(Q, X)) * Math.LOG2E;
  }
  function E(b, _, Q) {
    if (l === !1) return _;
    if (b !== null) {
      if (t[b] !== void 0) return t[b];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + b + "'");
    }
    let X = _;
    return _ === 6403 && (Q === 5126 && (X = 33326), Q === 5131 && (X = 33325), Q === 5121 && (X = 33321)), _ === 6407 && (Q === 5126 && (X = 34837), Q === 5131 && (X = 34843), Q === 5121 && (X = 32849)), _ === 6408 && (Q === 5126 && (X = 34836), Q === 5131 && (X = 34842), Q === 5121 && (X = 32856)), (X === 33325 || X === 33326 || X === 34842 || X === 34836) && e.get("EXT_color_buffer_float"), X;
  }
  function w(b) {
    return b === qt || b === Sd || b === Ed ? 9728 : 9729;
  }
  function C(b) {
    const _ = b.target;
    _.removeEventListener("dispose", C), Y(_), _.isVideoTexture && p.delete(_), a.memory.textures--;
  }
  function ee(b) {
    const _ = b.target;
    _.removeEventListener("dispose", ee), le(_), a.memory.textures--;
  }
  function Y(b) {
    const _ = r.get(b);
    _.__webglInit !== void 0 && (t.deleteTexture(_.__webglTexture), r.remove(b));
  }
  function le(b) {
    const _ = r.get(b), Q = r.get(b.texture);
    if (b) {
      if (Q.__webglTexture !== void 0 && t.deleteTexture(Q.__webglTexture), b.depthTexture && b.depthTexture.dispose(), b.isWebGLCubeRenderTarget)
        for (let X = 0; X < 6; X++)
          t.deleteFramebuffer(_.__webglFramebuffer[X]), _.__webglDepthbuffer && t.deleteRenderbuffer(_.__webglDepthbuffer[X]);
      else
        t.deleteFramebuffer(_.__webglFramebuffer), _.__webglDepthbuffer && t.deleteRenderbuffer(_.__webglDepthbuffer), _.__webglMultisampledFramebuffer && t.deleteFramebuffer(_.__webglMultisampledFramebuffer), _.__webglColorRenderbuffer && t.deleteRenderbuffer(_.__webglColorRenderbuffer), _.__webglDepthRenderbuffer && t.deleteRenderbuffer(_.__webglDepthRenderbuffer);
      r.remove(b.texture), r.remove(b);
    }
  }
  let B = 0;
  function Z() {
    B = 0;
  }
  function k() {
    const b = B;
    return b >= c && console.warn("THREE.WebGLTextures: Trying to use " + b + " texture units while this GPU supports only " + c), B += 1, b;
  }
  function O(b, _) {
    const Q = r.get(b);
    if (b.isVideoTexture && R(b), b.version > 0 && Q.__version !== b.version) {
      const X = b.image;
      if (X === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else if (X.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ge(Q, b, _);
        return;
      }
    }
    n.activeTexture(33984 + _), n.bindTexture(3553, Q.__webglTexture);
  }
  function P(b, _) {
    const Q = r.get(b);
    if (b.version > 0 && Q.__version !== b.version) {
      ge(Q, b, _);
      return;
    }
    n.activeTexture(33984 + _), n.bindTexture(35866, Q.__webglTexture);
  }
  function j(b, _) {
    const Q = r.get(b);
    if (b.version > 0 && Q.__version !== b.version) {
      ge(Q, b, _);
      return;
    }
    n.activeTexture(33984 + _), n.bindTexture(32879, Q.__webglTexture);
  }
  function re(b, _) {
    const Q = r.get(b);
    if (b.version > 0 && Q.__version !== b.version) {
      we(Q, b, _);
      return;
    }
    n.activeTexture(33984 + _), n.bindTexture(34067, Q.__webglTexture);
  }
  const ae = {
    [uh]: 10497,
    [an]: 33071,
    [dh]: 33648
  }, ce = {
    [qt]: 9728,
    [Sd]: 9984,
    [Ed]: 9986,
    [Ht]: 9729,
    [hy]: 9985,
    [Il]: 9987
  };
  function pe(b, _, Q) {
    Q ? (t.texParameteri(b, 10242, ae[_.wrapS]), t.texParameteri(b, 10243, ae[_.wrapT]), (b === 32879 || b === 35866) && t.texParameteri(b, 32882, ae[_.wrapR]), t.texParameteri(b, 10240, ce[_.magFilter]), t.texParameteri(b, 10241, ce[_.minFilter])) : (t.texParameteri(b, 10242, 33071), t.texParameteri(b, 10243, 33071), (b === 32879 || b === 35866) && t.texParameteri(b, 32882, 33071), (_.wrapS !== an || _.wrapT !== an) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(b, 10240, w(_.magFilter)), t.texParameteri(b, 10241, w(_.minFilter)), _.minFilter !== qt && _.minFilter !== Ht && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
    const X = e.get("EXT_texture_filter_anisotropic");
    if (X) {
      if (_.type === Cr && e.get("OES_texture_float_linear") === null || _.type === ph && (l || e.get("OES_texture_half_float_linear")) === null) return;
      (_.anisotropy > 1 || r.get(_).__currentAnisotropy) && (t.texParameterf(b, X.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(_.anisotropy, s.getMaxAnisotropy())), r.get(_).__currentAnisotropy = _.anisotropy);
    }
  }
  function de(b, _) {
    b.__webglInit === void 0 && (b.__webglInit = !0, _.addEventListener("dispose", C), b.__webglTexture = t.createTexture(), a.memory.textures++);
  }
  function ge(b, _, Q) {
    let X = 3553;
    _.isDataTexture2DArray && (X = 35866), _.isDataTexture3D && (X = 32879), de(b, _), n.activeTexture(33984 + Q), n.bindTexture(X, b.__webglTexture), t.pixelStorei(37440, _.flipY), t.pixelStorei(37441, _.premultiplyAlpha), t.pixelStorei(3317, _.unpackAlignment);
    const A = g(_) && v(_.image) === !1, ie = x(_.image, A, !1, d), oe = v(ie) || l, he = o.convert(_.format);
    let se = o.convert(_.type), me = E(_.internalFormat, he, se);
    pe(X, _, oe);
    let ve;
    const be = _.mipmaps;
    if (_.isDepthTexture)
      me = 6402, l ? _.type === Cr ? me = 36012 : _.type === oh ? me = 33190 : _.type === Oa ? me = 35056 : me = 33189 : _.type === Cr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), _.format === Mo && me === 6402 && _.type !== fh && _.type !== oh && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), _.type = fh, se = o.convert(_.type)), _.format === Ya && me === 6402 && (me = 34041, _.type !== Oa && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), _.type = Oa, se = o.convert(_.type))), n.texImage2D(3553, 0, me, ie.width, ie.height, 0, he, se, null);
    else if (_.isDataTexture)
      if (be.length > 0 && oe) {
        for (let fe = 0, _e = be.length; fe < _e; fe++)
          ve = be[fe], n.texImage2D(3553, fe, me, ve.width, ve.height, 0, he, se, ve.data);
        _.generateMipmaps = !1, b.__maxMipLevel = be.length - 1;
      } else
        n.texImage2D(3553, 0, me, ie.width, ie.height, 0, he, se, ie.data), b.__maxMipLevel = 0;
    else if (_.isCompressedTexture) {
      for (let fe = 0, _e = be.length; fe < _e; fe++)
        ve = be[fe], _.format !== ri && _.format !== Dr ? he !== null ? n.compressedTexImage2D(3553, fe, me, ve.width, ve.height, 0, ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, fe, me, ve.width, ve.height, 0, he, se, ve.data);
      b.__maxMipLevel = be.length - 1;
    } else if (_.isDataTexture2DArray)
      n.texImage3D(35866, 0, me, ie.width, ie.height, ie.depth, 0, he, se, ie.data), b.__maxMipLevel = 0;
    else if (_.isDataTexture3D)
      n.texImage3D(32879, 0, me, ie.width, ie.height, ie.depth, 0, he, se, ie.data), b.__maxMipLevel = 0;
    else if (be.length > 0 && oe) {
      for (let fe = 0, _e = be.length; fe < _e; fe++)
        ve = be[fe], n.texImage2D(3553, fe, me, he, se, ve);
      _.generateMipmaps = !1, b.__maxMipLevel = be.length - 1;
    } else
      n.texImage2D(3553, 0, me, he, se, ie), b.__maxMipLevel = 0;
    S(_, oe) && T(X, _, ie.width, ie.height), b.__version = _.version, _.onUpdate && _.onUpdate(_);
  }
  function we(b, _, Q) {
    if (_.image.length !== 6) return;
    de(b, _), n.activeTexture(33984 + Q), n.bindTexture(34067, b.__webglTexture), t.pixelStorei(37440, _.flipY);
    const X = _ && (_.isCompressedTexture || _.image[0].isCompressedTexture), A = _.image[0] && _.image[0].isDataTexture, ie = [];
    for (let fe = 0; fe < 6; fe++)
      !X && !A ? ie[fe] = x(_.image[fe], !1, !0, h) : ie[fe] = A ? _.image[fe].image : _.image[fe];
    const oe = ie[0], he = v(oe) || l, se = o.convert(_.format), me = o.convert(_.type), ve = E(_.internalFormat, se, me);
    pe(34067, _, he);
    let be;
    if (X) {
      for (let fe = 0; fe < 6; fe++) {
        be = ie[fe].mipmaps;
        for (let _e = 0; _e < be.length; _e++) {
          const Pe = be[_e];
          _.format !== ri && _.format !== Dr ? se !== null ? n.compressedTexImage2D(34069 + fe, _e, ve, Pe.width, Pe.height, 0, Pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + fe, _e, ve, Pe.width, Pe.height, 0, se, me, Pe.data);
        }
      }
      b.__maxMipLevel = be.length - 1;
    } else {
      be = _.mipmaps;
      for (let fe = 0; fe < 6; fe++)
        if (A) {
          n.texImage2D(34069 + fe, 0, ve, ie[fe].width, ie[fe].height, 0, se, me, ie[fe].data);
          for (let _e = 0; _e < be.length; _e++) {
            const rt = be[_e].image[fe].image;
            n.texImage2D(34069 + fe, _e + 1, ve, rt.width, rt.height, 0, se, me, rt.data);
          }
        } else {
          n.texImage2D(34069 + fe, 0, ve, se, me, ie[fe]);
          for (let _e = 0; _e < be.length; _e++) {
            const Pe = be[_e];
            n.texImage2D(34069 + fe, _e + 1, ve, se, me, Pe.image[fe]);
          }
        }
      b.__maxMipLevel = be.length;
    }
    S(_, he) && T(34067, _, oe.width, oe.height), b.__version = _.version, _.onUpdate && _.onUpdate(_);
  }
  function Ge(b, _, Q, X) {
    const A = o.convert(_.texture.format), ie = o.convert(_.texture.type), oe = E(_.texture.internalFormat, A, ie);
    n.texImage2D(X, 0, oe, _.width, _.height, 0, A, ie, null), t.bindFramebuffer(36160, b), t.framebufferTexture2D(36160, Q, X, r.get(_.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function te(b, _, Q) {
    if (t.bindRenderbuffer(36161, b), _.depthBuffer && !_.stencilBuffer) {
      let X = 33189;
      if (Q) {
        const A = _.depthTexture;
        A && A.isDepthTexture && (A.type === Cr ? X = 36012 : A.type === oh && (X = 33190));
        const ie = W(_);
        t.renderbufferStorageMultisample(36161, ie, X, _.width, _.height);
      } else
        t.renderbufferStorage(36161, X, _.width, _.height);
      t.framebufferRenderbuffer(36160, 36096, 36161, b);
    } else if (_.depthBuffer && _.stencilBuffer) {
      if (Q) {
        const X = W(_);
        t.renderbufferStorageMultisample(36161, X, 35056, _.width, _.height);
      } else
        t.renderbufferStorage(36161, 34041, _.width, _.height);
      t.framebufferRenderbuffer(36160, 33306, 36161, b);
    } else {
      const X = o.convert(_.texture.format), A = o.convert(_.texture.type), ie = E(_.texture.internalFormat, X, A);
      if (Q) {
        const oe = W(_);
        t.renderbufferStorageMultisample(36161, oe, ie, _.width, _.height);
      } else
        t.renderbufferStorage(36161, ie, _.width, _.height);
    }
    t.bindRenderbuffer(36161, null);
  }
  function I(b, _) {
    if (_ && _.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, b), !(_.depthTexture && _.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!r.get(_.depthTexture).__webglTexture || _.depthTexture.image.width !== _.width || _.depthTexture.image.height !== _.height) && (_.depthTexture.image.width = _.width, _.depthTexture.image.height = _.height, _.depthTexture.needsUpdate = !0), O(_.depthTexture, 0);
    const X = r.get(_.depthTexture).__webglTexture;
    if (_.depthTexture.format === Mo)
      t.framebufferTexture2D(36160, 36096, 3553, X, 0);
    else if (_.depthTexture.format === Ya)
      t.framebufferTexture2D(36160, 33306, 3553, X, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function L(b) {
    const _ = r.get(b), Q = b.isWebGLCubeRenderTarget === !0;
    if (b.depthTexture) {
      if (Q) throw new Error("target.depthTexture not supported in Cube render targets");
      I(_.__webglFramebuffer, b);
    } else if (Q) {
      _.__webglDepthbuffer = [];
      for (let X = 0; X < 6; X++)
        t.bindFramebuffer(36160, _.__webglFramebuffer[X]), _.__webglDepthbuffer[X] = t.createRenderbuffer(), te(_.__webglDepthbuffer[X], b, !1);
    } else
      t.bindFramebuffer(36160, _.__webglFramebuffer), _.__webglDepthbuffer = t.createRenderbuffer(), te(_.__webglDepthbuffer, b, !1);
    t.bindFramebuffer(36160, null);
  }
  function U(b) {
    const _ = r.get(b), Q = r.get(b.texture);
    b.addEventListener("dispose", ee), Q.__webglTexture = t.createTexture(), a.memory.textures++;
    const X = b.isWebGLCubeRenderTarget === !0, A = b.isWebGLMultisampleRenderTarget === !0, ie = v(b) || l;
    if (l && b.texture.format === Dr && (b.texture.type === Cr || b.texture.type === ph) && (b.texture.format = ri, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), X) {
      _.__webglFramebuffer = [];
      for (let oe = 0; oe < 6; oe++)
        _.__webglFramebuffer[oe] = t.createFramebuffer();
    } else if (_.__webglFramebuffer = t.createFramebuffer(), A)
      if (l) {
        _.__webglMultisampledFramebuffer = t.createFramebuffer(), _.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, _.__webglColorRenderbuffer);
        const oe = o.convert(b.texture.format), he = o.convert(b.texture.type), se = E(b.texture.internalFormat, oe, he), me = W(b);
        t.renderbufferStorageMultisample(36161, me, se, b.width, b.height), t.bindFramebuffer(36160, _.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, _.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), b.depthBuffer && (_.__webglDepthRenderbuffer = t.createRenderbuffer(), te(_.__webglDepthRenderbuffer, b, !0)), t.bindFramebuffer(36160, null);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    if (X) {
      n.bindTexture(34067, Q.__webglTexture), pe(34067, b.texture, ie);
      for (let oe = 0; oe < 6; oe++)
        Ge(_.__webglFramebuffer[oe], b, 36064, 34069 + oe);
      S(b.texture, ie) && T(34067, b.texture, b.width, b.height), n.bindTexture(34067, null);
    } else
      n.bindTexture(3553, Q.__webglTexture), pe(3553, b.texture, ie), Ge(_.__webglFramebuffer, b, 36064, 3553), S(b.texture, ie) && T(3553, b.texture, b.width, b.height), n.bindTexture(3553, null);
    b.depthBuffer && L(b);
  }
  function N(b) {
    const _ = b.texture, Q = v(b) || l;
    if (S(_, Q)) {
      const X = b.isWebGLCubeRenderTarget ? 34067 : 3553, A = r.get(_).__webglTexture;
      n.bindTexture(X, A), T(X, _, b.width, b.height), n.bindTexture(X, null);
    }
  }
  function V(b) {
    if (b.isWebGLMultisampleRenderTarget)
      if (l) {
        const _ = r.get(b);
        t.bindFramebuffer(36008, _.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, _.__webglFramebuffer);
        const Q = b.width, X = b.height;
        let A = 16384;
        b.depthBuffer && (A |= 256), b.stencilBuffer && (A |= 1024), t.blitFramebuffer(0, 0, Q, X, 0, 0, Q, X, A, 9728), t.bindFramebuffer(36160, _.__webglMultisampledFramebuffer);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }
  function W(b) {
    return l && b.isWebGLMultisampleRenderTarget ? Math.min(u, b.samples) : 0;
  }
  function R(b) {
    const _ = a.render.frame;
    p.get(b) !== _ && (p.set(b, _), b.update());
  }
  let D = !1, H = !1;
  function ne(b, _) {
    b && b.isWebGLRenderTarget && (D === !1 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), D = !0), b = b.texture), O(b, _);
  }
  function J(b, _) {
    b && b.isWebGLCubeRenderTarget && (H === !1 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), b = b.texture), re(b, _);
  }
  this.allocateTextureUnit = k, this.resetTextureUnits = Z, this.setTexture2D = O, this.setTexture2DArray = P, this.setTexture3D = j, this.setTextureCube = re, this.setupRenderTarget = U, this.updateRenderTargetMipmap = N, this.updateMultisampleRenderTarget = V, this.safeSetTexture2D = ne, this.safeSetTextureCube = J;
}
function IS(t, e, n) {
  const r = n.isWebGL2;
  function s(o) {
    let a;
    if (o === $f) return 5121;
    if (o === g0) return 32819;
    if (o === v0) return 32820;
    if (o === y0) return 33635;
    if (o === f0) return 5120;
    if (o === p0) return 5122;
    if (o === fh) return 5123;
    if (o === m0) return 5124;
    if (o === oh) return 5125;
    if (o === Cr) return 5126;
    if (o === ph)
      return r ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
    if (o === x0) return 6406;
    if (o === Dr) return 6407;
    if (o === ri) return 6408;
    if (o === _0) return 6409;
    if (o === b0) return 6410;
    if (o === Mo) return 6402;
    if (o === Ya) return 34041;
    if (o === w0) return 6403;
    if (o === M0) return 36244;
    if (o === S0) return 33319;
    if (o === E0) return 33320;
    if (o === T0) return 36248;
    if (o === A0) return 36249;
    if (o === Tp || o === Ap || o === Lp || o === Cp)
      if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (o === Tp) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === Ap) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === Lp) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === Cp) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (o === Rp || o === Pp || o === Ip || o === Dp)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (o === Rp) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === Pp) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === Ip) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === Dp) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (o === L0)
      return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    if ((o === Np || o === Op) && (a = e.get("WEBGL_compressed_texture_etc"), a !== null)) {
      if (o === Np) return a.COMPRESSED_RGB8_ETC2;
      if (o === Op) return a.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (o === C0 || o === R0 || o === P0 || o === I0 || o === D0 || o === N0 || o === O0 || o === F0 || o === B0 || o === z0 || o === U0 || o === H0 || o === G0 || o === V0 || o === W0 || o === $0 || o === j0 || o === q0 || o === X0 || o === Y0 || o === Z0 || o === J0 || o === K0 || o === Q0 || o === e_ || o === t_ || o === n_ || o === i_)
      return a = e.get("WEBGL_compressed_texture_astc"), a !== null ? o : null;
    if (o === k0)
      return a = e.get("EXT_texture_compression_bptc"), a !== null ? o : null;
    if (o === Oa)
      return r ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: s };
}
function Dd(t = []) {
  Nt.call(this), this.cameras = t;
}
Dd.prototype = Object.assign(Object.create(Nt.prototype), {
  constructor: Dd,
  isArrayCamera: !0
});
function us() {
  He.call(this), this.type = "Group";
}
us.prototype = Object.assign(Object.create(He.prototype), {
  constructor: us,
  isGroup: !0
});
function za() {
  this._targetRay = null, this._grip = null, this._hand = null;
}
Object.assign(za.prototype, {
  constructor: za,
  getHandSpace: function() {
    if (this._hand === null && (this._hand = new us(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand))
      for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
        const e = new us();
        e.matrixAutoUpdate = !1, e.visible = !1, this._hand.joints.push(e), this._hand.add(e);
      }
    return this._hand;
  },
  getTargetRaySpace: function() {
    return this._targetRay === null && (this._targetRay = new us(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay;
  },
  getGripSpace: function() {
    return this._grip === null && (this._grip = new us(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip;
  },
  dispatchEvent: function(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  },
  disconnect: function(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  },
  update: function(t, e, n) {
    let r = null, s = null, o = null;
    const a = this._targetRay, l = this._grip, c = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred")
      if (c && t.hand) {
        o = !0;
        for (let h = 0; h <= window.XRHand.LITTLE_PHALANX_TIP; h++)
          if (t.hand[h]) {
            const d = e.getJointPose(t.hand[h], n), u = c.joints[h];
            d !== null && (u.matrix.fromArray(d.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.jointRadius = d.radius), u.visible = d !== null;
            const p = c.joints[window.XRHand.INDEX_PHALANX_TIP], f = c.joints[window.XRHand.THUMB_PHALANX_TIP], m = p.position.distanceTo(f.position), y = 0.02, x = 5e-3;
            c.inputState.pinching && m > y + x ? (c.inputState.pinching = !1, this.dispatchEvent({
              type: "pinchend",
              handedness: t.handedness,
              target: this
            })) : !c.inputState.pinching && m <= y - x && (c.inputState.pinching = !0, this.dispatchEvent({
              type: "pinchstart",
              handedness: t.handedness,
              target: this
            }));
          }
      } else
        a !== null && (r = e.getPose(t.targetRaySpace, n), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale))), l !== null && t.gripSpace && (s = e.getPose(t.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale)));
    return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this;
  }
});
function Ly(t, e) {
  const n = this;
  let r = null, s = 1, o = null, a = "local-floor", l = null;
  const c = [], h = /* @__PURE__ */ new Map(), d = new Nt();
  d.layers.enable(1), d.viewport = new ht();
  const u = new Nt();
  u.layers.enable(2), u.viewport = new ht();
  const p = [d, u], f = new Dd();
  f.layers.enable(1), f.layers.enable(2);
  let m = null, y = null;
  this.enabled = !1, this.isPresenting = !1, this.getController = function(B) {
    let Z = c[B];
    return Z === void 0 && (Z = new za(), c[B] = Z), Z.getTargetRaySpace();
  }, this.getControllerGrip = function(B) {
    let Z = c[B];
    return Z === void 0 && (Z = new za(), c[B] = Z), Z.getGripSpace();
  }, this.getHand = function(B) {
    let Z = c[B];
    return Z === void 0 && (Z = new za(), c[B] = Z), Z.getHandSpace();
  };
  function x(B) {
    const Z = h.get(B.inputSource);
    Z && Z.dispatchEvent({ type: B.type, data: B.inputSource });
  }
  function v() {
    h.forEach(function(B, Z) {
      B.disconnect(Z);
    }), h.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), le.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" });
  }
  function g(B) {
    o = B, le.setContext(r), le.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
  }
  this.setFramebufferScaleFactor = function(B) {
    s = B, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
  }, this.setReferenceSpaceType = function(B) {
    a = B, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
  }, this.getReferenceSpace = function() {
    return o;
  }, this.getSession = function() {
    return r;
  }, this.setSession = function(B) {
    if (r = B, r !== null) {
      r.addEventListener("select", x), r.addEventListener("selectstart", x), r.addEventListener("selectend", x), r.addEventListener("squeeze", x), r.addEventListener("squeezestart", x), r.addEventListener("squeezeend", x), r.addEventListener("end", v);
      const Z = e.getContextAttributes();
      Z.xrCompatible !== !0 && e.makeXRCompatible();
      const k = {
        antialias: Z.antialias,
        alpha: Z.alpha,
        depth: Z.depth,
        stencil: Z.stencil,
        framebufferScaleFactor: s
      }, O = new XRWebGLLayer(r, e, k);
      r.updateRenderState({ baseLayer: O }), r.requestReferenceSpace(a).then(g), r.addEventListener("inputsourceschange", S);
    }
  };
  function S(B) {
    const Z = r.inputSources;
    for (let k = 0; k < c.length; k++)
      h.set(Z[k], c[k]);
    for (let k = 0; k < B.removed.length; k++) {
      const O = B.removed[k], P = h.get(O);
      P && (P.dispatchEvent({ type: "disconnected", data: O }), h.delete(O));
    }
    for (let k = 0; k < B.added.length; k++) {
      const O = B.added[k], P = h.get(O);
      P && P.dispatchEvent({ type: "connected", data: O });
    }
  }
  const T = new z(), E = new z();
  function w(B, Z, k) {
    T.setFromMatrixPosition(Z.matrixWorld), E.setFromMatrixPosition(k.matrixWorld);
    const O = T.distanceTo(E), P = Z.projectionMatrix.elements, j = k.projectionMatrix.elements, re = P[14] / (P[10] - 1), ae = P[14] / (P[10] + 1), ce = (P[9] + 1) / P[5], pe = (P[9] - 1) / P[5], de = (P[8] - 1) / P[0], ge = (j[8] + 1) / j[0], we = re * de, Ge = re * ge, te = O / (-de + ge), I = te * -de;
    Z.matrixWorld.decompose(B.position, B.quaternion, B.scale), B.translateX(I), B.translateZ(te), B.matrixWorld.compose(B.position, B.quaternion, B.scale), B.matrixWorldInverse.copy(B.matrixWorld).invert();
    const L = re + te, U = ae + te, N = we - I, V = Ge + (O - I), W = ce * ae / U * L, R = pe * ae / U * L;
    B.projectionMatrix.makePerspective(N, V, W, R, L, U);
  }
  function C(B, Z) {
    Z === null ? B.matrixWorld.copy(B.matrix) : B.matrixWorld.multiplyMatrices(Z.matrixWorld, B.matrix), B.matrixWorldInverse.copy(B.matrixWorld).invert();
  }
  this.getCamera = function(B) {
    f.near = u.near = d.near = B.near, f.far = u.far = d.far = B.far, (m !== f.near || y !== f.far) && (r.updateRenderState({
      depthNear: f.near,
      depthFar: f.far
    }), m = f.near, y = f.far);
    const Z = B.parent, k = f.cameras;
    C(f, Z);
    for (let P = 0; P < k.length; P++)
      C(k[P], Z);
    B.matrixWorld.copy(f.matrixWorld);
    const O = B.children;
    for (let P = 0, j = O.length; P < j; P++)
      O[P].updateMatrixWorld(!0);
    return k.length === 2 ? w(f, d, u) : f.projectionMatrix.copy(d.projectionMatrix), f;
  };
  let ee = null;
  function Y(B, Z) {
    if (l = Z.getViewerPose(o), l !== null) {
      const O = l.views, P = r.renderState.baseLayer;
      t.setFramebuffer(P.framebuffer);
      let j = !1;
      O.length !== f.cameras.length && (f.cameras.length = 0, j = !0);
      for (let re = 0; re < O.length; re++) {
        const ae = O[re], ce = P.getViewport(ae), pe = p[re];
        pe.matrix.fromArray(ae.transform.matrix), pe.projectionMatrix.fromArray(ae.projectionMatrix), pe.viewport.set(ce.x, ce.y, ce.width, ce.height), re === 0 && f.matrix.copy(pe.matrix), j === !0 && f.cameras.push(pe);
      }
    }
    const k = r.inputSources;
    for (let O = 0; O < c.length; O++) {
      const P = c[O], j = k[O];
      P.update(j, Z, o);
    }
    ee && ee(B, Z);
  }
  const le = new xy();
  le.setAnimationLoop(Y), this.setAnimationLoop = function(B) {
    ee = B;
  }, this.dispose = function() {
  };
}
Object.assign(Ly.prototype, ar.prototype);
function DS(t) {
  function e(v, g) {
    v.fogColor.value.copy(g.color), g.isFog ? (v.fogNear.value = g.near, v.fogFar.value = g.far) : g.isFogExp2 && (v.fogDensity.value = g.density);
  }
  function n(v, g, S, T) {
    g.isMeshBasicMaterial ? r(v, g) : g.isMeshLambertMaterial ? (r(v, g), c(v, g)) : g.isMeshToonMaterial ? (r(v, g), d(v, g)) : g.isMeshPhongMaterial ? (r(v, g), h(v, g)) : g.isMeshStandardMaterial ? (r(v, g), g.isMeshPhysicalMaterial ? p(v, g) : u(v, g)) : g.isMeshMatcapMaterial ? (r(v, g), f(v, g)) : g.isMeshDepthMaterial ? (r(v, g), m(v, g)) : g.isMeshDistanceMaterial ? (r(v, g), y(v, g)) : g.isMeshNormalMaterial ? (r(v, g), x(v, g)) : g.isLineBasicMaterial ? (s(v, g), g.isLineDashedMaterial && o(v, g)) : g.isPointsMaterial ? a(v, g, S, T) : g.isSpriteMaterial ? l(v, g) : g.isShadowMaterial ? (v.color.value.copy(g.color), v.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function r(v, g) {
    v.opacity.value = g.opacity, g.color && v.diffuse.value.copy(g.color), g.emissive && v.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (v.map.value = g.map), g.alphaMap && (v.alphaMap.value = g.alphaMap), g.specularMap && (v.specularMap.value = g.specularMap);
    const S = t.get(g).envMap;
    if (S) {
      v.envMap.value = S, v.flipEnvMap.value = S.isCubeTexture && S._needsFlipEnvMap ? -1 : 1, v.reflectivity.value = g.reflectivity, v.refractionRatio.value = g.refractionRatio;
      const w = t.get(S).__maxMipLevel;
      w !== void 0 && (v.maxMipLevel.value = w);
    }
    g.lightMap && (v.lightMap.value = g.lightMap, v.lightMapIntensity.value = g.lightMapIntensity), g.aoMap && (v.aoMap.value = g.aoMap, v.aoMapIntensity.value = g.aoMapIntensity);
    let T;
    g.map ? T = g.map : g.specularMap ? T = g.specularMap : g.displacementMap ? T = g.displacementMap : g.normalMap ? T = g.normalMap : g.bumpMap ? T = g.bumpMap : g.roughnessMap ? T = g.roughnessMap : g.metalnessMap ? T = g.metalnessMap : g.alphaMap ? T = g.alphaMap : g.emissiveMap ? T = g.emissiveMap : g.clearcoatMap ? T = g.clearcoatMap : g.clearcoatNormalMap ? T = g.clearcoatNormalMap : g.clearcoatRoughnessMap && (T = g.clearcoatRoughnessMap), T !== void 0 && (T.isWebGLRenderTarget && (T = T.texture), T.matrixAutoUpdate === !0 && T.updateMatrix(), v.uvTransform.value.copy(T.matrix));
    let E;
    g.aoMap ? E = g.aoMap : g.lightMap && (E = g.lightMap), E !== void 0 && (E.isWebGLRenderTarget && (E = E.texture), E.matrixAutoUpdate === !0 && E.updateMatrix(), v.uv2Transform.value.copy(E.matrix));
  }
  function s(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity;
  }
  function o(v, g) {
    v.dashSize.value = g.dashSize, v.totalSize.value = g.dashSize + g.gapSize, v.scale.value = g.scale;
  }
  function a(v, g, S, T) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.size.value = g.size * S, v.scale.value = T * 0.5, g.map && (v.map.value = g.map), g.alphaMap && (v.alphaMap.value = g.alphaMap);
    let E;
    g.map ? E = g.map : g.alphaMap && (E = g.alphaMap), E !== void 0 && (E.matrixAutoUpdate === !0 && E.updateMatrix(), v.uvTransform.value.copy(E.matrix));
  }
  function l(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.rotation.value = g.rotation, g.map && (v.map.value = g.map), g.alphaMap && (v.alphaMap.value = g.alphaMap);
    let S;
    g.map ? S = g.map : g.alphaMap && (S = g.alphaMap), S !== void 0 && (S.matrixAutoUpdate === !0 && S.updateMatrix(), v.uvTransform.value.copy(S.matrix));
  }
  function c(v, g) {
    g.emissiveMap && (v.emissiveMap.value = g.emissiveMap);
  }
  function h(v, g) {
    v.specular.value.copy(g.specular), v.shininess.value = Math.max(g.shininess, 1e-4), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap), g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ut && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ut && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  function d(v, g) {
    g.gradientMap && (v.gradientMap.value = g.gradientMap), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap), g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ut && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ut && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  function u(v, g) {
    v.roughness.value = g.roughness, v.metalness.value = g.metalness, g.roughnessMap && (v.roughnessMap.value = g.roughnessMap), g.metalnessMap && (v.metalnessMap.value = g.metalnessMap), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap), g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ut && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ut && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias), t.get(g).envMap && (v.envMapIntensity.value = g.envMapIntensity);
  }
  function p(v, g) {
    u(v, g), v.reflectivity.value = g.reflectivity, v.clearcoat.value = g.clearcoat, v.clearcoatRoughness.value = g.clearcoatRoughness, g.sheen && v.sheen.value.copy(g.sheen), g.clearcoatMap && (v.clearcoatMap.value = g.clearcoatMap), g.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap), g.clearcoatNormalMap && (v.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), v.clearcoatNormalMap.value = g.clearcoatNormalMap, g.side === Ut && v.clearcoatNormalScale.value.negate()), v.transmission.value = g.transmission, g.transmissionMap && (v.transmissionMap.value = g.transmissionMap);
  }
  function f(v, g) {
    g.matcap && (v.matcap.value = g.matcap), g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ut && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ut && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  function m(v, g) {
    g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  function y(v, g) {
    g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias), v.referencePosition.value.copy(g.referencePosition), v.nearDistance.value = g.nearDistance, v.farDistance.value = g.farDistance;
  }
  function x(v, g) {
    g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ut && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ut && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  return {
    refreshFogUniforms: e,
    refreshMaterialUniforms: n
  };
}
function NS() {
  const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  return t.style.display = "block", t;
}
function Qh(t) {
  t = t || {};
  const e = t.canvas !== void 0 ? t.canvas : NS(), n = t.context !== void 0 ? t.context : null, r = t.alpha !== void 0 ? t.alpha : !1, s = t.depth !== void 0 ? t.depth : !0, o = t.stencil !== void 0 ? t.stencil : !0, a = t.antialias !== void 0 ? t.antialias : !1, l = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0, c = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1, h = t.powerPreference !== void 0 ? t.powerPreference : "default", d = t.failIfMajorPerformanceCaveat !== void 0 ? t.failIfMajorPerformanceCaveat : !1;
  let u = null, p = null;
  const f = [];
  this.domElement = e, this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Dl, this.physicallyCorrectLights = !1, this.toneMapping = Na, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
  const m = this;
  let y = !1, x = null, v = 0, g = 0, S = null, T = null, E = -1, w = null;
  const C = new ht(), ee = new ht();
  let Y = null, le = e.width, B = e.height, Z = 1, k = null, O = null;
  const P = new ht(0, 0, le, B), j = new ht(0, 0, le, B);
  let re = !1;
  const ae = new Kh();
  let ce = !1, pe = !1;
  const de = new Je(), ge = new z(), we = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function Ge() {
    return S === null ? Z : 1;
  }
  let te = n;
  function I(M, q) {
    for (let G = 0; G < M.length; G++) {
      const K = M[G], ue = e.getContext(K, q);
      if (ue !== null) return ue;
    }
    return null;
  }
  try {
    const M = {
      alpha: r,
      depth: s,
      stencil: o,
      antialias: a,
      premultipliedAlpha: l,
      preserveDrawingBuffer: c,
      powerPreference: h,
      failIfMajorPerformanceCaveat: d
    };
    if (e.addEventListener("webglcontextlost", Pe, !1), e.addEventListener("webglcontextrestored", rt, !1), te === null) {
      const q = ["webgl2", "webgl", "experimental-webgl"];
      if (m.isWebGL1Renderer === !0 && q.shift(), te = I(q, M), te === null)
        throw I(q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    te.getShaderPrecisionFormat === void 0 && (te.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (M) {
    throw console.error("THREE.WebGLRenderer: " + M.message), M;
  }
  let L, U, N, V, W, R, D, H, ne, J, b, _, Q, X, A, ie, oe, he, se, me, ve;
  function be() {
    L = new uM(te), U = new lM(te, L, t), U.isWebGL2 === !1 && (L.get("WEBGL_depth_texture"), L.get("OES_texture_float"), L.get("OES_texture_half_float"), L.get("OES_texture_half_float_linear"), L.get("OES_standard_derivatives"), L.get("OES_element_index_uint"), L.get("OES_vertex_array_object"), L.get("ANGLE_instanced_arrays")), L.get("OES_texture_float_linear"), me = new IS(te, L, U), N = new RS(te, L, U), N.scissor(ee.copy(j).multiplyScalar(Z).floor()), N.viewport(C.copy(P).multiplyScalar(Z).floor()), V = new pM(), W = new yS(), R = new PS(te, L, N, W, U, me, V), D = new hM(m), H = new F_(te, U), ve = new oM(te, L, H, U), ne = new dM(te, H, V, ve), J = new yM(te, ne, H, V), oe = new vM(te), A = new cM(W), b = new vS(m, D, L, U, ve, A), _ = new DS(W), Q = new bS(W), X = new AS(L, U), ie = new sM(m, D, N, J, l), he = new aM(te, L, V, U), se = new fM(te, L, V, U), V.programs = b.programs, m.capabilities = U, m.extensions = L, m.properties = W, m.renderLists = Q, m.state = N, m.info = V;
  }
  be();
  const fe = new Ly(m, te);
  this.xr = fe;
  const _e = new Ay(m, J, U.maxTextureSize);
  this.shadowMap = _e, this.getContext = function() {
    return te;
  }, this.getContextAttributes = function() {
    return te.getContextAttributes();
  }, this.forceContextLoss = function() {
    const M = L.get("WEBGL_lose_context");
    M && M.loseContext();
  }, this.forceContextRestore = function() {
    const M = L.get("WEBGL_lose_context");
    M && M.restoreContext();
  }, this.getPixelRatio = function() {
    return Z;
  }, this.setPixelRatio = function(M) {
    M !== void 0 && (Z = M, this.setSize(le, B, !1));
  }, this.getSize = function(M) {
    return M === void 0 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), M = new ye()), M.set(le, B);
  }, this.setSize = function(M, q, G) {
    if (fe.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    le = M, B = q, e.width = Math.floor(M * Z), e.height = Math.floor(q * Z), G !== !1 && (e.style.width = M + "px", e.style.height = q + "px"), this.setViewport(0, 0, M, q);
  }, this.getDrawingBufferSize = function(M) {
    return M === void 0 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), M = new ye()), M.set(le * Z, B * Z).floor();
  }, this.setDrawingBufferSize = function(M, q, G) {
    le = M, B = q, Z = G, e.width = Math.floor(M * G), e.height = Math.floor(q * G), this.setViewport(0, 0, M, q);
  }, this.getCurrentViewport = function(M) {
    return M === void 0 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), M = new ht()), M.copy(C);
  }, this.getViewport = function(M) {
    return M.copy(P);
  }, this.setViewport = function(M, q, G, K) {
    M.isVector4 ? P.set(M.x, M.y, M.z, M.w) : P.set(M, q, G, K), N.viewport(C.copy(P).multiplyScalar(Z).floor());
  }, this.getScissor = function(M) {
    return M.copy(j);
  }, this.setScissor = function(M, q, G, K) {
    M.isVector4 ? j.set(M.x, M.y, M.z, M.w) : j.set(M, q, G, K), N.scissor(ee.copy(j).multiplyScalar(Z).floor());
  }, this.getScissorTest = function() {
    return re;
  }, this.setScissorTest = function(M) {
    N.setScissorTest(re = M);
  }, this.setOpaqueSort = function(M) {
    k = M;
  }, this.setTransparentSort = function(M) {
    O = M;
  }, this.getClearColor = function(M) {
    return M === void 0 && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), M = new Ne()), M.copy(ie.getClearColor());
  }, this.setClearColor = function() {
    ie.setClearColor.apply(ie, arguments);
  }, this.getClearAlpha = function() {
    return ie.getClearAlpha();
  }, this.setClearAlpha = function() {
    ie.setClearAlpha.apply(ie, arguments);
  }, this.clear = function(M, q, G) {
    let K = 0;
    (M === void 0 || M) && (K |= 16384), (q === void 0 || q) && (K |= 256), (G === void 0 || G) && (K |= 1024), te.clear(K);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", Pe, !1), e.removeEventListener("webglcontextrestored", rt, !1), Q.dispose(), X.dispose(), W.dispose(), D.dispose(), J.dispose(), ve.dispose(), fe.dispose(), Wt.stop();
  };
  function Pe(M) {
    M.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0;
  }
  function rt() {
    console.log("THREE.WebGLRenderer: Context Restored."), y = !1, be();
  }
  function dn(M) {
    const q = M.target;
    q.removeEventListener("dispose", dn), es(q);
  }
  function es(M) {
    Fi(M), W.remove(M);
  }
  function Fi(M) {
    const q = W.get(M).program;
    q !== void 0 && b.releaseProgram(q);
  }
  function cr(M, q) {
    M.render(function(G) {
      m.renderBufferImmediate(G, q);
    });
  }
  this.renderBufferImmediate = function(M, q) {
    ve.initAttributes();
    const G = W.get(M);
    M.hasPositions && !G.position && (G.position = te.createBuffer()), M.hasNormals && !G.normal && (G.normal = te.createBuffer()), M.hasUvs && !G.uv && (G.uv = te.createBuffer()), M.hasColors && !G.color && (G.color = te.createBuffer());
    const K = q.getAttributes();
    M.hasPositions && (te.bindBuffer(34962, G.position), te.bufferData(34962, M.positionArray, 35048), ve.enableAttribute(K.position), te.vertexAttribPointer(K.position, 3, 5126, !1, 0, 0)), M.hasNormals && (te.bindBuffer(34962, G.normal), te.bufferData(34962, M.normalArray, 35048), ve.enableAttribute(K.normal), te.vertexAttribPointer(K.normal, 3, 5126, !1, 0, 0)), M.hasUvs && (te.bindBuffer(34962, G.uv), te.bufferData(34962, M.uvArray, 35048), ve.enableAttribute(K.uv), te.vertexAttribPointer(K.uv, 2, 5126, !1, 0, 0)), M.hasColors && (te.bindBuffer(34962, G.color), te.bufferData(34962, M.colorArray, 35048), ve.enableAttribute(K.color), te.vertexAttribPointer(K.color, 3, 5126, !1, 0, 0)), ve.disableUnusedAttributes(), te.drawArrays(4, 0, M.count), M.count = 0;
  }, this.renderBufferDirect = function(M, q, G, K, ue, Le) {
    q === null && (q = we);
    const Se = ue.isMesh && ue.matrixWorld.determinant() < 0, Re = zi(M, q, K, ue);
    N.setMaterial(K, Se);
    let Ee = G.index;
    const Ze = G.attributes.position;
    if (Ee === null) {
      if (Ze === void 0 || Ze.count === 0) return;
    } else if (Ee.count === 0)
      return;
    let je = 1;
    K.wireframe === !0 && (Ee = ne.getWireframeAttribute(G), je = 2), (K.morphTargets || K.morphNormals) && oe.update(ue, G, K, Re), ve.setup(ue, K, Re, G, Ee);
    let Me, Be = he;
    Ee !== null && (Me = H.get(Ee), Be = se, Be.setIndex(Me));
    const Lt = Ee !== null ? Ee.count : Ze.count, ze = G.drawRange.start * je, tn = G.drawRange.count * je, et = Le !== null ? Le.start * je : 0, ns = Le !== null ? Le.count * je : 1 / 0, lt = Math.max(ze, et), Wn = Math.min(Lt, ze + tn, et + ns) - 1, fn = Math.max(0, Wn - lt + 1);
    if (fn !== 0) {
      if (ue.isMesh)
        K.wireframe === !0 ? (N.setLineWidth(K.wireframeLinewidth * Ge()), Be.setMode(1)) : Be.setMode(4);
      else if (ue.isLine) {
        let $n = K.linewidth;
        $n === void 0 && ($n = 1), N.setLineWidth($n * Ge()), ue.isLineSegments ? Be.setMode(1) : ue.isLineLoop ? Be.setMode(2) : Be.setMode(3);
      } else ue.isPoints ? Be.setMode(0) : ue.isSprite && Be.setMode(4);
      if (ue.isInstancedMesh)
        Be.renderInstances(lt, fn, ue.count);
      else if (G.isInstancedBufferGeometry) {
        const $n = Math.min(G.instanceCount, G._maxInstanceCount);
        Be.renderInstances(lt, fn, $n);
      } else
        Be.render(lt, fn);
    }
  }, this.compile = function(M, q) {
    p = X.get(M), p.init(), M.traverseVisible(function(K) {
      K.isLight && K.layers.test(q.layers) && (p.pushLight(K), K.castShadow && p.pushShadow(K));
    }), p.setupLights();
    const G = /* @__PURE__ */ new WeakMap();
    M.traverse(function(K) {
      const ue = K.material;
      if (ue)
        if (Array.isArray(ue))
          for (let Le = 0; Le < ue.length; Le++) {
            const Se = ue[Le];
            G.has(Se) === !1 && (ct(Se, M, K), G.set(Se));
          }
        else G.has(ue) === !1 && (ct(ue, M, K), G.set(ue));
    });
  };
  let Bi = null;
  function ra(M) {
    fe.isPresenting || Bi && Bi(M);
  }
  const Wt = new xy();
  Wt.setAnimationLoop(ra), typeof window < "u" && Wt.setContext(window), this.setAnimationLoop = function(M) {
    Bi = M, fe.setAnimationLoop(M), M === null ? Wt.stop() : Wt.start();
  }, this.render = function(M, q) {
    let G, K;
    if (arguments[2] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), G = arguments[2]), arguments[3] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), K = arguments[3]), q !== void 0 && q.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (y === !0) return;
    ve.resetDefaultState(), E = -1, w = null, M.autoUpdate === !0 && M.updateMatrixWorld(), q.parent === null && q.updateMatrixWorld(), fe.enabled === !0 && fe.isPresenting === !0 && (q = fe.getCamera(q)), M.isScene === !0 && M.onBeforeRender(m, M, q, G || S), p = X.get(M, f.length), p.init(), f.push(p), de.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse), ae.setFromProjectionMatrix(de), pe = this.localClippingEnabled, ce = A.init(this.clippingPlanes, pe, q), u = Q.get(M, q), u.init(), en(M, q, 0, m.sortObjects), u.finish(), m.sortObjects === !0 && u.sort(k, O), ce === !0 && A.beginShadows();
    const ue = p.state.shadowsArray;
    _e.render(ue, M, q), p.setupLights(), p.setupLightsView(q), ce === !0 && A.endShadows(), this.info.autoReset === !0 && this.info.reset(), G !== void 0 && this.setRenderTarget(G), ie.render(u, M, q, K);
    const Le = u.opaque, Se = u.transparent;
    Le.length > 0 && kn(Le, M, q), Se.length > 0 && kn(Se, M, q), M.isScene === !0 && M.onAfterRender(m, M, q), S !== null && (R.updateRenderTargetMipmap(S), R.updateMultisampleRenderTarget(S)), N.buffers.depth.setTest(!0), N.buffers.depth.setMask(!0), N.buffers.color.setMask(!0), N.setPolygonOffset(!1), f.pop(), f.length > 0 ? p = f[f.length - 1] : p = null, u = null;
  };
  function en(M, q, G, K) {
    if (M.visible === !1) return;
    if (M.layers.test(q.layers)) {
      if (M.isGroup)
        G = M.renderOrder;
      else if (M.isLOD)
        M.autoUpdate === !0 && M.update(q);
      else if (M.isLight)
        p.pushLight(M), M.castShadow && p.pushShadow(M);
      else if (M.isSprite) {
        if (!M.frustumCulled || ae.intersectsSprite(M)) {
          K && ge.setFromMatrixPosition(M.matrixWorld).applyMatrix4(de);
          const Se = J.update(M), Re = M.material;
          Re.visible && u.push(M, Se, Re, G, ge.z, null);
        }
      } else if (M.isImmediateRenderObject)
        K && ge.setFromMatrixPosition(M.matrixWorld).applyMatrix4(de), u.push(M, null, M.material, G, ge.z, null);
      else if ((M.isMesh || M.isLine || M.isPoints) && (M.isSkinnedMesh && M.skeleton.frame !== V.render.frame && (M.skeleton.update(), M.skeleton.frame = V.render.frame), !M.frustumCulled || ae.intersectsObject(M))) {
        K && ge.setFromMatrixPosition(M.matrixWorld).applyMatrix4(de);
        const Se = J.update(M), Re = M.material;
        if (Array.isArray(Re)) {
          const Ee = Se.groups;
          for (let Ze = 0, je = Ee.length; Ze < je; Ze++) {
            const Me = Ee[Ze], Be = Re[Me.materialIndex];
            Be && Be.visible && u.push(M, Se, Be, G, ge.z, Me);
          }
        } else Re.visible && u.push(M, Se, Re, G, ge.z, null);
      }
    }
    const Le = M.children;
    for (let Se = 0, Re = Le.length; Se < Re; Se++)
      en(Le[Se], q, G, K);
  }
  function kn(M, q, G) {
    const K = q.isScene === !0 ? q.overrideMaterial : null;
    for (let ue = 0, Le = M.length; ue < Le; ue++) {
      const Se = M[ue], Re = Se.object, Ee = Se.geometry, Ze = K === null ? Se.material : K, je = Se.group;
      if (G.isArrayCamera) {
        const Me = G.cameras;
        for (let Be = 0, Lt = Me.length; Be < Lt; Be++) {
          const ze = Me[Be];
          Re.layers.test(ze.layers) && (N.viewport(C.copy(ze.viewport)), p.setupLightsView(ze), hr(Re, q, ze, Ee, Ze, je));
        }
      } else
        hr(Re, q, G, Ee, Ze, je);
    }
  }
  function hr(M, q, G, K, ue, Le) {
    if (M.onBeforeRender(m, q, G, K, ue, Le), M.modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, M.matrixWorld), M.normalMatrix.getNormalMatrix(M.modelViewMatrix), M.isImmediateRenderObject) {
      const Se = zi(G, q, ue, M);
      N.setMaterial(ue), ve.reset(), cr(M, Se);
    } else
      m.renderBufferDirect(G, q, K, ue, M, Le);
    M.onAfterRender(m, q, G, K, ue, Le);
  }
  function ct(M, q, G) {
    q.isScene !== !0 && (q = we);
    const K = W.get(M), ue = p.state.lights, Le = p.state.shadowsArray, Se = ue.state.version, Re = b.getParameters(M, ue.state, Le, q, G), Ee = b.getProgramCacheKey(Re);
    let Ze = K.program, je = !0;
    if (Ze === void 0)
      M.addEventListener("dispose", dn);
    else if (Ze.cacheKey !== Ee)
      Fi(M);
    else if (K.lightsStateVersion !== Se)
      je = !1;
    else if (Re.shaderID !== void 0) {
      const ze = M.isMeshStandardMaterial ? q.environment : null;
      K.envMap = D.get(M.envMap || ze);
      return;
    } else
      je = !1;
    je && (Re.uniforms = b.getUniforms(M), M.onBeforeCompile(Re, m), Ze = b.acquireProgram(Re, Ee), K.program = Ze, K.uniforms = Re.uniforms, K.outputEncoding = Re.outputEncoding);
    const Me = K.uniforms;
    (!M.isShaderMaterial && !M.isRawShaderMaterial || M.clipping === !0) && (K.numClippingPlanes = A.numPlanes, K.numIntersection = A.numIntersection, Me.clippingPlanes = A.uniform), K.environment = M.isMeshStandardMaterial ? q.environment : null, K.fog = q.fog, K.envMap = D.get(M.envMap || K.environment), K.needsLights = sa(M), K.lightsStateVersion = Se, K.needsLights && (Me.ambientLightColor.value = ue.state.ambient, Me.lightProbe.value = ue.state.probe, Me.directionalLights.value = ue.state.directional, Me.directionalLightShadows.value = ue.state.directionalShadow, Me.spotLights.value = ue.state.spot, Me.spotLightShadows.value = ue.state.spotShadow, Me.rectAreaLights.value = ue.state.rectArea, Me.ltc_1.value = ue.state.rectAreaLTC1, Me.ltc_2.value = ue.state.rectAreaLTC2, Me.pointLights.value = ue.state.point, Me.pointLightShadows.value = ue.state.pointShadow, Me.hemisphereLights.value = ue.state.hemi, Me.directionalShadowMap.value = ue.state.directionalShadowMap, Me.directionalShadowMatrix.value = ue.state.directionalShadowMatrix, Me.spotShadowMap.value = ue.state.spotShadowMap, Me.spotShadowMatrix.value = ue.state.spotShadowMatrix, Me.pointShadowMap.value = ue.state.pointShadowMap, Me.pointShadowMatrix.value = ue.state.pointShadowMatrix);
    const Be = K.program.getUniforms(), Lt = Nr.seqWithValue(Be.seq, Me);
    K.uniformsList = Lt;
  }
  function zi(M, q, G, K) {
    q.isScene !== !0 && (q = we), R.resetTextureUnits();
    const ue = q.fog, Le = G.isMeshStandardMaterial ? q.environment : null, Se = S === null ? m.outputEncoding : S.texture.encoding, Re = D.get(G.envMap || Le), Ee = W.get(G), Ze = p.state.lights;
    if (ce === !0 && (pe === !0 || M !== w)) {
      const et = M === w && G.id === E;
      A.setState(G, M, et);
    }
    G.version === Ee.__version ? (G.fog && Ee.fog !== ue || Ee.environment !== Le || Ee.needsLights && Ee.lightsStateVersion !== Ze.state.version || Ee.numClippingPlanes !== void 0 && (Ee.numClippingPlanes !== A.numPlanes || Ee.numIntersection !== A.numIntersection) || Ee.outputEncoding !== Se || Ee.envMap !== Re) && ct(G, q, K) : (ct(G, q, K), Ee.__version = G.version);
    let je = !1, Me = !1, Be = !1;
    const Lt = Ee.program, ze = Lt.getUniforms(), tn = Ee.uniforms;
    if (N.useProgram(Lt.program) && (je = !0, Me = !0, Be = !0), G.id !== E && (E = G.id, Me = !0), je || w !== M) {
      if (ze.setValue(te, "projectionMatrix", M.projectionMatrix), U.logarithmicDepthBuffer && ze.setValue(
        te,
        "logDepthBufFC",
        2 / (Math.log(M.far + 1) / Math.LN2)
      ), w !== M && (w = M, Me = !0, Be = !0), G.isShaderMaterial || G.isMeshPhongMaterial || G.isMeshToonMaterial || G.isMeshStandardMaterial || G.envMap) {
        const et = ze.map.cameraPosition;
        et !== void 0 && et.setValue(
          te,
          ge.setFromMatrixPosition(M.matrixWorld)
        );
      }
      (G.isMeshPhongMaterial || G.isMeshToonMaterial || G.isMeshLambertMaterial || G.isMeshBasicMaterial || G.isMeshStandardMaterial || G.isShaderMaterial) && ze.setValue(te, "isOrthographic", M.isOrthographicCamera === !0), (G.isMeshPhongMaterial || G.isMeshToonMaterial || G.isMeshLambertMaterial || G.isMeshBasicMaterial || G.isMeshStandardMaterial || G.isShaderMaterial || G.isShadowMaterial || G.skinning) && ze.setValue(te, "viewMatrix", M.matrixWorldInverse);
    }
    if (G.skinning) {
      ze.setOptional(te, K, "bindMatrix"), ze.setOptional(te, K, "bindMatrixInverse");
      const et = K.skeleton;
      if (et) {
        const ns = et.bones;
        if (U.floatVertexTextures) {
          if (et.boneTexture === null) {
            let lt = Math.sqrt(ns.length * 4);
            lt = $e.ceilPowerOfTwo(lt), lt = Math.max(lt, 4);
            const Wn = new Float32Array(lt * lt * 4);
            Wn.set(et.boneMatrices);
            const fn = new Co(Wn, lt, lt, ri, Cr);
            et.boneMatrices = Wn, et.boneTexture = fn, et.boneTextureSize = lt;
          }
          ze.setValue(te, "boneTexture", et.boneTexture, R), ze.setValue(te, "boneTextureSize", et.boneTextureSize);
        } else
          ze.setOptional(te, et, "boneMatrices");
      }
    }
    return (Me || Ee.receiveShadow !== K.receiveShadow) && (Ee.receiveShadow = K.receiveShadow, ze.setValue(te, "receiveShadow", K.receiveShadow)), Me && (ze.setValue(te, "toneMappingExposure", m.toneMappingExposure), Ee.needsLights && ts(tn, Be), ue && G.fog && _.refreshFogUniforms(tn, ue), _.refreshMaterialUniforms(tn, G, Z, B), Nr.upload(te, Ee.uniformsList, tn, R)), G.isShaderMaterial && G.uniformsNeedUpdate === !0 && (Nr.upload(te, Ee.uniformsList, tn, R), G.uniformsNeedUpdate = !1), G.isSpriteMaterial && ze.setValue(te, "center", K.center), ze.setValue(te, "modelViewMatrix", K.modelViewMatrix), ze.setValue(te, "normalMatrix", K.normalMatrix), ze.setValue(te, "modelMatrix", K.matrixWorld), Lt;
  }
  function ts(M, q) {
    M.ambientLightColor.needsUpdate = q, M.lightProbe.needsUpdate = q, M.directionalLights.needsUpdate = q, M.directionalLightShadows.needsUpdate = q, M.pointLights.needsUpdate = q, M.pointLightShadows.needsUpdate = q, M.spotLights.needsUpdate = q, M.spotLightShadows.needsUpdate = q, M.rectAreaLights.needsUpdate = q, M.hemisphereLights.needsUpdate = q;
  }
  function sa(M) {
    return M.isMeshLambertMaterial || M.isMeshToonMaterial || M.isMeshPhongMaterial || M.isMeshStandardMaterial || M.isShadowMaterial || M.isShaderMaterial && M.lights === !0;
  }
  this.setFramebuffer = function(M) {
    x !== M && S === null && te.bindFramebuffer(36160, M), x = M;
  }, this.getActiveCubeFace = function() {
    return v;
  }, this.getActiveMipmapLevel = function() {
    return g;
  }, this.getRenderList = function() {
    return u;
  }, this.setRenderList = function(M) {
    u = M;
  }, this.getRenderTarget = function() {
    return S;
  }, this.setRenderTarget = function(M, q = 0, G = 0) {
    S = M, v = q, g = G, M && W.get(M).__webglFramebuffer === void 0 && R.setupRenderTarget(M);
    let K = x, ue = !1;
    if (M) {
      const Le = W.get(M).__webglFramebuffer;
      M.isWebGLCubeRenderTarget ? (K = Le[q], ue = !0) : M.isWebGLMultisampleRenderTarget ? K = W.get(M).__webglMultisampledFramebuffer : K = Le, C.copy(M.viewport), ee.copy(M.scissor), Y = M.scissorTest;
    } else
      C.copy(P).multiplyScalar(Z).floor(), ee.copy(j).multiplyScalar(Z).floor(), Y = re;
    if (T !== K && (te.bindFramebuffer(36160, K), T = K), N.viewport(C), N.scissor(ee), N.setScissorTest(Y), ue) {
      const Le = W.get(M.texture);
      te.framebufferTexture2D(36160, 36064, 34069 + q, Le.__webglTexture, G);
    }
  }, this.readRenderTargetPixels = function(M, q, G, K, ue, Le, Se) {
    if (!(M && M.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let Re = W.get(M).__webglFramebuffer;
    if (M.isWebGLCubeRenderTarget && Se !== void 0 && (Re = Re[Se]), Re) {
      let Ee = !1;
      Re !== T && (te.bindFramebuffer(36160, Re), Ee = !0);
      try {
        const Ze = M.texture, je = Ze.format, Me = Ze.type;
        if (je !== ri && me.convert(je) !== te.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (Me !== $f && me.convert(Me) !== te.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(Me === Cr && (U.isWebGL2 || L.get("OES_texture_float") || L.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !(Me === ph && (U.isWebGL2 ? L.get("EXT_color_buffer_float") : L.get("EXT_color_buffer_half_float")))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        te.checkFramebufferStatus(36160) === 36053 ? q >= 0 && q <= M.width - K && G >= 0 && G <= M.height - ue && te.readPixels(q, G, K, ue, me.convert(je), me.convert(Me), Le) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        Ee && te.bindFramebuffer(36160, T);
      }
    }
  }, this.copyFramebufferToTexture = function(M, q, G = 0) {
    const K = Math.pow(2, -G), ue = Math.floor(q.image.width * K), Le = Math.floor(q.image.height * K), Se = me.convert(q.format);
    R.setTexture2D(q, 0), te.copyTexImage2D(3553, G, Se, M.x, M.y, ue, Le, 0), N.unbindTexture();
  }, this.copyTextureToTexture = function(M, q, G, K = 0) {
    const ue = q.image.width, Le = q.image.height, Se = me.convert(G.format), Re = me.convert(G.type);
    R.setTexture2D(G, 0), te.pixelStorei(37440, G.flipY), te.pixelStorei(37441, G.premultiplyAlpha), te.pixelStorei(3317, G.unpackAlignment), q.isDataTexture ? te.texSubImage2D(3553, K, M.x, M.y, ue, Le, Se, Re, q.image.data) : q.isCompressedTexture ? te.compressedTexSubImage2D(3553, K, M.x, M.y, q.mipmaps[0].width, q.mipmaps[0].height, Se, q.mipmaps[0].data) : te.texSubImage2D(3553, K, M.x, M.y, Se, Re, q.image), K === 0 && G.generateMipmaps && te.generateMipmap(3553), N.unbindTexture();
  }, this.initTexture = function(M) {
    R.setTexture2D(M, 0), N.unbindTexture();
  }, this.resetState = function() {
    N.reset(), ve.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
function lm(t) {
  Qh.call(this, t);
}
lm.prototype = Object.assign(Object.create(Qh.prototype), {
  constructor: lm,
  isWebGL1Renderer: !0
});
let Zf = class extends He {
  constructor() {
    super(), Object.defineProperty(this, "isScene", { value: !0 }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.background !== null && (n.object.background = this.background.toJSON(e)), this.environment !== null && (n.object.environment = this.environment.toJSON(e)), this.fog !== null && (n.object.fog = this.fog.toJSON()), n;
  }
};
function xn(t, e) {
  this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = Jh, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = $e.generateUUID();
}
Object.defineProperty(xn.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
Object.assign(xn.prototype, {
  isInterleavedBuffer: !0,
  onUploadCallback: function() {
  },
  setUsage: function(t) {
    return this.usage = t, this;
  },
  copy: function(t) {
    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
  },
  copyAt: function(t, e, n) {
    t *= this.stride, n *= e.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[t + r] = e.array[n + r];
    return this;
  },
  set: function(t, e = 0) {
    return this.array.set(t, e), this;
  },
  clone: function(t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = $e.generateUUID()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new xn(e, this.stride);
    return n.setUsage(this.usage), n;
  },
  onUpload: function(t) {
    return this.onUploadCallback = t, this;
  },
  toJSON: function(t) {
    return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = $e.generateUUID()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
const os = new z();
function wi(t, e, n, r) {
  this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = r === !0;
}
Object.defineProperties(wi.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(t) {
      this.data.needsUpdate = t;
    }
  }
});
Object.assign(wi.prototype, {
  isInterleavedBufferAttribute: !0,
  applyMatrix4: function(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      os.x = this.getX(e), os.y = this.getY(e), os.z = this.getZ(e), os.applyMatrix4(t), this.setXYZ(e, os.x, os.y, os.z);
    return this;
  },
  setX: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset] = e, this;
  },
  setY: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
  },
  setZ: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
  },
  setW: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
  },
  getX: function(t) {
    return this.data.array[t * this.data.stride + this.offset];
  },
  getY: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 1];
  },
  getZ: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 2];
  },
  getW: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 3];
  },
  setXY: function(t, e, n) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
  },
  setXYZ: function(t, e, n, r) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this;
  },
  setXYZW: function(t, e, n, r, s) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = s, this;
  },
  clone: function(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          e.push(this.data.array[r + s]);
      }
      return new We(new this.array.constructor(e), this.itemSize, this.normalized);
    } else
      return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new wi(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  },
  toJSON: function(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          e.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized
      };
    } else
      return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
});
function kr(t) {
  Ve.call(this), this.type = "SpriteMaterial", this.color = new Ne(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t);
}
kr.prototype = Object.create(Ve.prototype);
kr.prototype.constructor = kr;
kr.prototype.isSpriteMaterial = !0;
kr.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
};
let Hs;
const ua = new z(), Gs = new z(), Vs = new z(), ks = new ye(), da = new ye(), Cy = new Je(), tc = new z(), fa = new z(), nc = new z(), cm = new ye(), Fu = new ye(), hm = new ye();
function Nd(t) {
  if (He.call(this), this.type = "Sprite", Hs === void 0) {
    Hs = new it();
    const e = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0,
      0.5,
      -0.5,
      0,
      1,
      0,
      0.5,
      0.5,
      0,
      1,
      1,
      -0.5,
      0.5,
      0,
      0,
      1
    ]), n = new xn(e, 5);
    Hs.setIndex([0, 1, 2, 0, 2, 3]), Hs.setAttribute("position", new wi(n, 3, 0, !1)), Hs.setAttribute("uv", new wi(n, 2, 3, !1));
  }
  this.geometry = Hs, this.material = t !== void 0 ? t : new kr(), this.center = new ye(0.5, 0.5);
}
Nd.prototype = Object.assign(Object.create(He.prototype), {
  constructor: Nd,
  isSprite: !0,
  raycast: function(t, e) {
    t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Gs.setFromMatrixScale(this.matrixWorld), Cy.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Vs.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Gs.multiplyScalar(-Vs.z);
    const n = this.material.rotation;
    let r, s;
    n !== 0 && (s = Math.cos(n), r = Math.sin(n));
    const o = this.center;
    ic(tc.set(-0.5, -0.5, 0), Vs, o, Gs, r, s), ic(fa.set(0.5, -0.5, 0), Vs, o, Gs, r, s), ic(nc.set(0.5, 0.5, 0), Vs, o, Gs, r, s), cm.set(0, 0), Fu.set(1, 0), hm.set(1, 1);
    let a = t.ray.intersectTriangle(tc, fa, nc, !1, ua);
    if (a === null && (ic(fa.set(-0.5, 0.5, 0), Vs, o, Gs, r, s), Fu.set(0, 1), a = t.ray.intersectTriangle(tc, nc, fa, !1, ua), a === null))
      return;
    const l = t.ray.origin.distanceTo(ua);
    l < t.near || l > t.far || e.push({
      distance: l,
      point: ua.clone(),
      uv: oi.getUV(ua, tc, fa, nc, cm, Fu, hm, new ye()),
      face: null,
      object: this
    });
  },
  copy: function(t) {
    return He.prototype.copy.call(this, t), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this;
  }
});
function ic(t, e, n, r, s, o) {
  ks.subVectors(t, n).addScalar(0.5).multiply(r), s !== void 0 ? (da.x = o * ks.x - s * ks.y, da.y = s * ks.x + o * ks.y) : da.copy(ks), t.copy(e), t.x += da.x, t.y += da.y, t.applyMatrix4(Cy);
}
const rc = new z(), um = new z();
function Od() {
  He.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
    levels: {
      enumerable: !0,
      value: []
    }
  }), this.autoUpdate = !0;
}
Od.prototype = Object.assign(Object.create(He.prototype), {
  constructor: Od,
  isLOD: !0,
  copy: function(t) {
    He.prototype.copy.call(this, t, !1);
    const e = t.levels;
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      this.addLevel(s.object.clone(), s.distance);
    }
    return this.autoUpdate = t.autoUpdate, this;
  },
  addLevel: function(t, e = 0) {
    e = Math.abs(e);
    const n = this.levels;
    let r;
    for (r = 0; r < n.length && !(e < n[r].distance); r++)
      ;
    return n.splice(r, 0, { distance: e, object: t }), this.add(t), this;
  },
  getCurrentLevel: function() {
    return this._currentLevel;
  },
  getObjectForDistance: function(t) {
    const e = this.levels;
    if (e.length > 0) {
      let n, r;
      for (n = 1, r = e.length; n < r && !(t < e[n].distance); n++)
        ;
      return e[n - 1].object;
    }
    return null;
  },
  raycast: function(t, e) {
    if (this.levels.length > 0) {
      rc.setFromMatrixPosition(this.matrixWorld);
      const r = t.ray.origin.distanceTo(rc);
      this.getObjectForDistance(r).raycast(t, e);
    }
  },
  update: function(t) {
    const e = this.levels;
    if (e.length > 1) {
      rc.setFromMatrixPosition(t.matrixWorld), um.setFromMatrixPosition(this.matrixWorld);
      const n = rc.distanceTo(um) / t.zoom;
      e[0].object.visible = !0;
      let r, s;
      for (r = 1, s = e.length; r < s && n >= e[r].distance; r++)
        e[r - 1].object.visible = !1, e[r].object.visible = !0;
      for (this._currentLevel = r - 1; r < s; r++)
        e[r].object.visible = !1;
    }
  },
  toJSON: function(t) {
    const e = He.prototype.toJSON.call(this, t);
    this.autoUpdate === !1 && (e.object.autoUpdate = !1), e.object.levels = [];
    const n = this.levels;
    for (let r = 0, s = n.length; r < s; r++) {
      const o = n[r];
      e.object.levels.push({
        object: o.object.uuid,
        distance: o.distance
      });
    }
    return e;
  }
});
const dm = new z(), fm = new ht(), pm = new ht(), OS = new z(), mm = new Je();
function yh(t, e) {
  t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Tt.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Je(), this.bindMatrixInverse = new Je();
}
yh.prototype = Object.assign(Object.create(Tt.prototype), {
  constructor: yh,
  isSkinnedMesh: !0,
  copy: function(t) {
    return Tt.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
  },
  bind: function(t, e) {
    this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const t = new ht(), e = this.geometry.attributes.skinWeight;
    for (let n = 0, r = e.count; n < r; n++) {
      t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
      const s = 1 / t.manhattanLength();
      s !== 1 / 0 ? t.multiplyScalar(s) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
    }
  },
  updateMatrixWorld: function(t) {
    Tt.prototype.updateMatrixWorld.call(this, t), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  },
  boneTransform: function(t, e) {
    const n = this.skeleton, r = this.geometry;
    fm.fromBufferAttribute(r.attributes.skinIndex, t), pm.fromBufferAttribute(r.attributes.skinWeight, t), dm.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = pm.getComponent(s);
      if (o !== 0) {
        const a = fm.getComponent(s);
        mm.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), e.addScaledVector(OS.copy(dm).applyMatrix4(mm), o);
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse);
  }
});
function xh() {
  He.call(this), this.type = "Bone";
}
xh.prototype = Object.assign(Object.create(He.prototype), {
  constructor: xh,
  isBone: !0
});
const gm = new Je(), FS = new Je();
function _h(t = [], e = []) {
  this.uuid = $e.generateUUID(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
}
Object.assign(_h.prototype, {
  init: function() {
    const t = this.bones, e = this.boneInverses;
    if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0)
      this.calculateInverses();
    else if (t.length !== e.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new Je());
    }
  },
  calculateInverses: function() {
    this.boneInverses.length = 0;
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = new Je();
      this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n);
    }
  },
  pose: function() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && n.matrixWorld.copy(this.boneInverses[t]).invert();
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  },
  update: function() {
    const t = this.bones, e = this.boneInverses, n = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s] ? t[s].matrixWorld : FS;
      gm.multiplyMatrices(a, e[s]), gm.toArray(n, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  },
  clone: function() {
    return new _h(this.bones, this.boneInverses);
  },
  getBoneByName: function(t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      if (r.name === t)
        return r;
    }
  },
  dispose: function() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  },
  fromJSON: function(t, e) {
    this.uuid = t.uuid;
    for (let n = 0, r = t.bones.length; n < r; n++) {
      const s = t.bones[n];
      let o = e[s];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new xh()), this.bones.push(o), this.boneInverses.push(new Je().fromArray(t.boneInverses[n]));
    }
    return this.init(), this;
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    t.uuid = this.uuid;
    const e = this.bones, n = this.boneInverses;
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      t.bones.push(o.uuid);
      const a = n[r];
      t.boneInverses.push(a.toArray());
    }
    return t;
  }
});
const vm = new Je(), ym = new Je(), sc = [], pa = new Tt();
function xm(t, e, n) {
  Tt.call(this, t, e), this.instanceMatrix = new We(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1;
}
xm.prototype = Object.assign(Object.create(Tt.prototype), {
  constructor: xm,
  isInstancedMesh: !0,
  copy: function(t) {
    return Tt.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this;
  },
  getColorAt: function(t, e) {
    e.fromArray(this.instanceColor.array, t * 3);
  },
  getMatrixAt: function(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  },
  raycast: function(t, e) {
    const n = this.matrixWorld, r = this.count;
    if (pa.geometry = this.geometry, pa.material = this.material, pa.material !== void 0)
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, vm), ym.multiplyMatrices(n, vm), pa.matrixWorld = ym, pa.raycast(t, sc);
        for (let o = 0, a = sc.length; o < a; o++) {
          const l = sc[o];
          l.instanceId = s, l.object = this, e.push(l);
        }
        sc.length = 0;
      }
  },
  setColorAt: function(t, e) {
    this.instanceColor === null && (this.instanceColor = new We(new Float32Array(this.count * 3), 3)), e.toArray(this.instanceColor.array, t * 3);
  },
  setMatrixAt: function(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  },
  updateMorphTargets: function() {
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function un(t) {
  Ve.call(this), this.type = "LineBasicMaterial", this.color = new Ne(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t);
}
un.prototype = Object.create(Ve.prototype);
un.prototype.constructor = un;
un.prototype.isLineBasicMaterial = !0;
un.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this;
};
const _m = new z(), bm = new z(), wm = new Je(), oc = new Nl(), ac = new hi();
function Wr(t = new it(), e = new un()) {
  He.call(this), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
}
Wr.prototype = Object.assign(Object.create(He.prototype), {
  constructor: Wr,
  isLine: !0,
  copy: function(t) {
    return He.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
  },
  computeLineDistances: function() {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position, n = [0];
        for (let r = 1, s = e.count; r < s; r++)
          _m.fromBufferAttribute(e, r - 1), bm.fromBufferAttribute(e, r), n[r] = n[r - 1], n[r] += _m.distanceTo(bm);
        t.setAttribute("lineDistance", new Ke(n, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (t.isGeometry) {
      const e = t.vertices, n = t.lineDistances;
      n[0] = 0;
      for (let r = 1, s = e.length; r < s; r++)
        n[r] = n[r - 1], n[r] += e[r - 1].distanceTo(e[r]);
    }
    return this;
  },
  raycast: function(t, e) {
    const n = this.geometry, r = this.matrixWorld, s = t.params.Line.threshold;
    if (n.boundingSphere === null && n.computeBoundingSphere(), ac.copy(n.boundingSphere), ac.applyMatrix4(r), ac.radius += s, t.ray.intersectsSphere(ac) === !1) return;
    wm.copy(r).invert(), oc.copy(t.ray).applyMatrix4(wm);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o, l = new z(), c = new z(), h = new z(), d = new z(), u = this.isLineSegments ? 2 : 1;
    if (n.isBufferGeometry) {
      const p = n.index, m = n.attributes.position;
      if (p !== null) {
        const y = p.array;
        for (let x = 0, v = y.length - 1; x < v; x += u) {
          const g = y[x], S = y[x + 1];
          if (l.fromBufferAttribute(m, g), c.fromBufferAttribute(m, S), oc.distanceSqToSegment(l, c, d, h) > a) continue;
          d.applyMatrix4(this.matrixWorld);
          const E = t.ray.origin.distanceTo(d);
          E < t.near || E > t.far || e.push({
            distance: E,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: x,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else
        for (let y = 0, x = m.count - 1; y < x; y += u) {
          if (l.fromBufferAttribute(m, y), c.fromBufferAttribute(m, y + 1), oc.distanceSqToSegment(l, c, d, h) > a) continue;
          d.applyMatrix4(this.matrixWorld);
          const g = t.ray.origin.distanceTo(d);
          g < t.near || g > t.far || e.push({
            distance: g,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this
          });
        }
    } else if (n.isGeometry) {
      const p = n.vertices, f = p.length;
      for (let m = 0; m < f - 1; m += u) {
        if (oc.distanceSqToSegment(p[m], p[m + 1], d, h) > a) continue;
        d.applyMatrix4(this.matrixWorld);
        const x = t.ray.origin.distanceTo(d);
        x < t.near || x > t.far || e.push({
          distance: x,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: h.clone().applyMatrix4(this.matrixWorld),
          index: m,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const r = e[n[0]];
        if (r !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
const lc = new z(), cc = new z();
function nl(t, e) {
  Wr.call(this, t, e), this.type = "LineSegments";
}
nl.prototype = Object.assign(Object.create(Wr.prototype), {
  constructor: nl,
  isLineSegments: !0,
  computeLineDistances: function() {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position, n = [];
        for (let r = 0, s = e.count; r < s; r += 2)
          lc.fromBufferAttribute(e, r), cc.fromBufferAttribute(e, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + lc.distanceTo(cc);
        t.setAttribute("lineDistance", new Ke(n, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (t.isGeometry) {
      const e = t.vertices, n = t.lineDistances;
      for (let r = 0, s = e.length; r < s; r += 2)
        lc.copy(e[r]), cc.copy(e[r + 1]), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + lc.distanceTo(cc);
    }
    return this;
  }
});
function Fd(t, e) {
  Wr.call(this, t, e), this.type = "LineLoop";
}
Fd.prototype = Object.assign(Object.create(Wr.prototype), {
  constructor: Fd,
  isLineLoop: !0
});
function li(t) {
  Ve.call(this), this.type = "PointsMaterial", this.color = new Ne(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t);
}
li.prototype = Object.create(Ve.prototype);
li.prototype.constructor = li;
li.prototype.isPointsMaterial = !0;
li.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
};
const Mm = new Je(), Bd = new Nl(), hc = new hi(), uc = new z();
function Ro(t = new it(), e = new li()) {
  He.call(this), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets();
}
Ro.prototype = Object.assign(Object.create(He.prototype), {
  constructor: Ro,
  isPoints: !0,
  copy: function(t) {
    return He.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
  },
  raycast: function(t, e) {
    const n = this.geometry, r = this.matrixWorld, s = t.params.Points.threshold;
    if (n.boundingSphere === null && n.computeBoundingSphere(), hc.copy(n.boundingSphere), hc.applyMatrix4(r), hc.radius += s, t.ray.intersectsSphere(hc) === !1) return;
    Mm.copy(r).invert(), Bd.copy(t.ray).applyMatrix4(Mm);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o;
    if (n.isBufferGeometry) {
      const l = n.index, h = n.attributes.position;
      if (l !== null) {
        const d = l.array;
        for (let u = 0, p = d.length; u < p; u++) {
          const f = d[u];
          uc.fromBufferAttribute(h, f), Bu(uc, f, a, r, t, e, this);
        }
      } else
        for (let d = 0, u = h.count; d < u; d++)
          uc.fromBufferAttribute(h, d), Bu(uc, d, a, r, t, e, this);
    } else {
      const l = n.vertices;
      for (let c = 0, h = l.length; c < h; c++)
        Bu(l[c], c, a, r, t, e, this);
    }
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const r = e[n[0]];
        if (r !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function Bu(t, e, n, r, s, o, a) {
  const l = Bd.distanceSqToPoint(t);
  if (l < n) {
    const c = new z();
    Bd.closestPointToPoint(t, c), c.applyMatrix4(r);
    const h = s.ray.origin.distanceTo(c);
    if (h < s.near || h > s.far) return;
    o.push({
      distance: h,
      distanceToRay: Math.sqrt(l),
      point: c,
      index: e,
      face: null,
      object: a
    });
  }
}
function Sm(t, e, n, r, s, o, a, l, c) {
  ft.call(this, t, e, n, r, s, o, a, l, c), this.format = a !== void 0 ? a : Dr, this.minFilter = o !== void 0 ? o : Ht, this.magFilter = s !== void 0 ? s : Ht, this.generateMipmaps = !1;
  const h = this;
  function d() {
    h.needsUpdate = !0, t.requestVideoFrameCallback(d);
  }
  "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(d);
}
Sm.prototype = Object.assign(Object.create(ft.prototype), {
  constructor: Sm,
  clone: function() {
    return new this.constructor(this.image).copy(this);
  },
  isVideoTexture: !0,
  update: function() {
    const t = this.image;
    "requestVideoFrameCallback" in t === !1 && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
});
function il(t, e, n, r, s, o, a, l, c, h, d, u) {
  ft.call(this, null, o, a, l, c, h, r, s, d, u), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
}
il.prototype = Object.create(ft.prototype);
il.prototype.constructor = il;
il.prototype.isCompressedTexture = !0;
function rl(t, e, n, r, s, o, a, l, c) {
  ft.call(this, t, e, n, r, s, o, a, l, c), this.needsUpdate = !0;
}
rl.prototype = Object.create(ft.prototype);
rl.prototype.constructor = rl;
rl.prototype.isCanvasTexture = !0;
function bh(t, e, n, r, s, o, a, l, c, h) {
  if (h = h !== void 0 ? h : Mo, h !== Mo && h !== Ya)
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  n === void 0 && h === Mo && (n = fh), n === void 0 && h === Ya && (n = Oa), ft.call(this, null, r, s, o, a, l, h, n, c), this.image = { width: t, height: e }, this.magFilter = a !== void 0 ? a : qt, this.minFilter = l !== void 0 ? l : qt, this.flipY = !1, this.generateMipmaps = !1;
}
bh.prototype = Object.create(ft.prototype);
bh.prototype.constructor = bh;
bh.prototype.isDepthTexture = !0;
let BS = 0;
const di = new Je(), zu = new He(), dc = new z();
function cn() {
  Object.defineProperty(this, "id", { value: BS += 2 }), this.uuid = $e.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
cn.prototype = Object.assign(Object.create(ar.prototype), {
  constructor: cn,
  isGeometry: !0,
  applyMatrix4: function(t) {
    const e = new ln().getNormalMatrix(t);
    for (let n = 0, r = this.vertices.length; n < r; n++)
      this.vertices[n].applyMatrix4(t);
    for (let n = 0, r = this.faces.length; n < r; n++) {
      const s = this.faces[n];
      s.normal.applyMatrix3(e).normalize();
      for (let o = 0, a = s.vertexNormals.length; o < a; o++)
        s.vertexNormals[o].applyMatrix3(e).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
  },
  rotateX: function(t) {
    return di.makeRotationX(t), this.applyMatrix4(di), this;
  },
  rotateY: function(t) {
    return di.makeRotationY(t), this.applyMatrix4(di), this;
  },
  rotateZ: function(t) {
    return di.makeRotationZ(t), this.applyMatrix4(di), this;
  },
  translate: function(t, e, n) {
    return di.makeTranslation(t, e, n), this.applyMatrix4(di), this;
  },
  scale: function(t, e, n) {
    return di.makeScale(t, e, n), this.applyMatrix4(di), this;
  },
  lookAt: function(t) {
    return zu.lookAt(t), zu.updateMatrix(), this.applyMatrix4(zu.matrix), this;
  },
  fromBufferGeometry: function(t) {
    const e = this, n = t.index !== null ? t.index : void 0, r = t.attributes;
    if (r.position === void 0)
      return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    const s = r.position, o = r.normal, a = r.color, l = r.uv, c = r.uv2;
    c !== void 0 && (this.faceVertexUvs[1] = []);
    for (let u = 0; u < s.count; u++)
      e.vertices.push(new z().fromBufferAttribute(s, u)), a !== void 0 && e.colors.push(new Ne().fromBufferAttribute(a, u));
    function h(u, p, f, m) {
      const y = a === void 0 ? [] : [
        e.colors[u].clone(),
        e.colors[p].clone(),
        e.colors[f].clone()
      ], x = o === void 0 ? [] : [
        new z().fromBufferAttribute(o, u),
        new z().fromBufferAttribute(o, p),
        new z().fromBufferAttribute(o, f)
      ], v = new gh(u, p, f, x, y, m);
      e.faces.push(v), l !== void 0 && e.faceVertexUvs[0].push([
        new ye().fromBufferAttribute(l, u),
        new ye().fromBufferAttribute(l, p),
        new ye().fromBufferAttribute(l, f)
      ]), c !== void 0 && e.faceVertexUvs[1].push([
        new ye().fromBufferAttribute(c, u),
        new ye().fromBufferAttribute(c, p),
        new ye().fromBufferAttribute(c, f)
      ]);
    }
    const d = t.groups;
    if (d.length > 0)
      for (let u = 0; u < d.length; u++) {
        const p = d[u], f = p.start, m = p.count;
        for (let y = f, x = f + m; y < x; y += 3)
          n !== void 0 ? h(n.getX(y), n.getX(y + 1), n.getX(y + 2), p.materialIndex) : h(y, y + 1, y + 2, p.materialIndex);
      }
    else if (n !== void 0)
      for (let u = 0; u < n.count; u += 3)
        h(n.getX(u), n.getX(u + 1), n.getX(u + 2));
    else
      for (let u = 0; u < s.count; u += 3)
        h(u, u + 1, u + 2);
    return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
  },
  center: function() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(dc).negate(), this.translate(dc.x, dc.y, dc.z), this;
  },
  normalize: function() {
    this.computeBoundingSphere();
    const t = this.boundingSphere.center, e = this.boundingSphere.radius, n = e === 0 ? 1 : 1 / e, r = new Je();
    return r.set(
      n,
      0,
      0,
      -n * t.x,
      0,
      n,
      0,
      -n * t.y,
      0,
      0,
      n,
      -n * t.z,
      0,
      0,
      0,
      1
    ), this.applyMatrix4(r), this;
  },
  computeFaceNormals: function() {
    const t = new z(), e = new z();
    for (let n = 0, r = this.faces.length; n < r; n++) {
      const s = this.faces[n], o = this.vertices[s.a], a = this.vertices[s.b], l = this.vertices[s.c];
      t.subVectors(l, a), e.subVectors(o, a), t.cross(e), t.normalize(), s.normal.copy(t);
    }
  },
  computeVertexNormals: function(t = !0) {
    const e = new Array(this.vertices.length);
    for (let n = 0, r = this.vertices.length; n < r; n++)
      e[n] = new z();
    if (t) {
      const n = new z(), r = new z();
      for (let s = 0, o = this.faces.length; s < o; s++) {
        const a = this.faces[s], l = this.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c];
        n.subVectors(h, c), r.subVectors(l, c), n.cross(r), e[a.a].add(n), e[a.b].add(n), e[a.c].add(n);
      }
    } else {
      this.computeFaceNormals();
      for (let n = 0, r = this.faces.length; n < r; n++) {
        const s = this.faces[n];
        e[s.a].add(s.normal), e[s.b].add(s.normal), e[s.c].add(s.normal);
      }
    }
    for (let n = 0, r = this.vertices.length; n < r; n++)
      e[n].normalize();
    for (let n = 0, r = this.faces.length; n < r; n++) {
      const s = this.faces[n], o = s.vertexNormals;
      o.length === 3 ? (o[0].copy(e[s.a]), o[1].copy(e[s.b]), o[2].copy(e[s.c])) : (o[0] = e[s.a].clone(), o[1] = e[s.b].clone(), o[2] = e[s.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function() {
    this.computeFaceNormals();
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const n = this.faces[t], r = n.vertexNormals;
      r.length === 3 ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function() {
    for (let e = 0, n = this.faces.length; e < n; e++) {
      const r = this.faces[e];
      r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []);
      for (let s = 0, o = r.vertexNormals.length; s < o; s++)
        r.__originalVertexNormals[s] ? r.__originalVertexNormals[s].copy(r.vertexNormals[s]) : r.__originalVertexNormals[s] = r.vertexNormals[s].clone();
    }
    const t = new cn();
    t.faces = this.faces;
    for (let e = 0, n = this.morphTargets.length; e < n; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        const s = this.morphNormals[e].faceNormals, o = this.morphNormals[e].vertexNormals;
        for (let a = 0, l = this.faces.length; a < l; a++) {
          const c = new z(), h = { a: new z(), b: new z(), c: new z() };
          s.push(c), o.push(h);
        }
      }
      const r = this.morphNormals[e];
      t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
      for (let s = 0, o = this.faces.length; s < o; s++) {
        const a = this.faces[s], l = r.faceNormals[s], c = r.vertexNormals[s];
        l.copy(a.normal), c.a.copy(a.vertexNormals[0]), c.b.copy(a.vertexNormals[1]), c.c.copy(a.vertexNormals[2]);
      }
    }
    for (let e = 0, n = this.faces.length; e < n; e++) {
      const r = this.faces[e];
      r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals;
    }
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new kt()), this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new hi()), this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(t, e, n = 0) {
    if (!(t && t.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
      return;
    }
    let r;
    const s = this.vertices.length, o = this.vertices, a = t.vertices, l = this.faces, c = t.faces, h = this.colors, d = t.colors;
    e !== void 0 && (r = new ln().getNormalMatrix(e));
    for (let u = 0, p = a.length; u < p; u++) {
      const m = a[u].clone();
      e !== void 0 && m.applyMatrix4(e), o.push(m);
    }
    for (let u = 0, p = d.length; u < p; u++)
      h.push(d[u].clone());
    for (let u = 0, p = c.length; u < p; u++) {
      const f = c[u];
      let m, y;
      const x = f.vertexNormals, v = f.vertexColors, g = new gh(f.a + s, f.b + s, f.c + s);
      g.normal.copy(f.normal), r !== void 0 && g.normal.applyMatrix3(r).normalize();
      for (let S = 0, T = x.length; S < T; S++)
        m = x[S].clone(), r !== void 0 && m.applyMatrix3(r).normalize(), g.vertexNormals.push(m);
      g.color.copy(f.color);
      for (let S = 0, T = v.length; S < T; S++)
        y = v[S], g.vertexColors.push(y.clone());
      g.materialIndex = f.materialIndex + n, l.push(g);
    }
    for (let u = 0, p = t.faceVertexUvs.length; u < p; u++) {
      const f = t.faceVertexUvs[u];
      this.faceVertexUvs[u] === void 0 && (this.faceVertexUvs[u] = []);
      for (let m = 0, y = f.length; m < y; m++) {
        const x = f[m], v = [];
        for (let g = 0, S = x.length; g < S; g++)
          v.push(x[g].clone());
        this.faceVertexUvs[u].push(v);
      }
    }
  },
  mergeMesh: function(t) {
    if (!(t && t.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t);
      return;
    }
    t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix);
  },
  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function(t = 4) {
    const e = {}, n = [], r = [], s = Math.pow(10, t);
    for (let l = 0, c = this.vertices.length; l < c; l++) {
      const h = this.vertices[l], d = Math.round(h.x * s) + "_" + Math.round(h.y * s) + "_" + Math.round(h.z * s);
      e[d] === void 0 ? (e[d] = l, n.push(this.vertices[l]), r[l] = n.length - 1) : r[l] = r[e[d]];
    }
    const o = [];
    for (let l = 0, c = this.faces.length; l < c; l++) {
      const h = this.faces[l];
      h.a = r[h.a], h.b = r[h.b], h.c = r[h.c];
      const d = [h.a, h.b, h.c];
      for (let u = 0; u < 3; u++)
        if (d[u] === d[(u + 1) % 3]) {
          o.push(l);
          break;
        }
    }
    for (let l = o.length - 1; l >= 0; l--) {
      const c = o[l];
      this.faces.splice(c, 1);
      for (let h = 0, d = this.faceVertexUvs.length; h < d; h++)
        this.faceVertexUvs[h].splice(c, 1);
    }
    const a = this.vertices.length - n.length;
    return this.vertices = n, a;
  },
  setFromPoints: function(t) {
    this.vertices = [];
    for (let e = 0, n = t.length; e < n; e++) {
      const r = t[e];
      this.vertices.push(new z(r.x, r.y, r.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function() {
    const t = this.faces, e = t.length;
    for (let l = 0; l < e; l++)
      t[l]._id = l;
    function n(l, c) {
      return l.materialIndex - c.materialIndex;
    }
    t.sort(n);
    const r = this.faceVertexUvs[0], s = this.faceVertexUvs[1];
    let o, a;
    r && r.length === e && (o = []), s && s.length === e && (a = []);
    for (let l = 0; l < e; l++) {
      const c = t[l]._id;
      o && o.push(r[c]), a && a.push(s[c]);
    }
    o && (this.faceVertexUvs[0] = o), a && (this.faceVertexUvs[1] = a);
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), this.parameters !== void 0) {
      const f = this.parameters;
      for (const m in f)
        f[m] !== void 0 && (t[m] = f[m]);
      return t;
    }
    const e = [];
    for (let f = 0; f < this.vertices.length; f++) {
      const m = this.vertices[f];
      e.push(m.x, m.y, m.z);
    }
    const n = [], r = [], s = {}, o = [], a = {}, l = [], c = {};
    for (let f = 0; f < this.faces.length; f++) {
      const m = this.faces[f], y = !0, x = !1, v = this.faceVertexUvs[0][f] !== void 0, g = m.normal.length() > 0, S = m.vertexNormals.length > 0, T = m.color.r !== 1 || m.color.g !== 1 || m.color.b !== 1, E = m.vertexColors.length > 0;
      let w = 0;
      if (w = h(w, 0, 0), w = h(w, 1, y), w = h(w, 2, x), w = h(w, 3, v), w = h(w, 4, g), w = h(w, 5, S), w = h(w, 6, T), w = h(w, 7, E), n.push(w), n.push(m.a, m.b, m.c), n.push(m.materialIndex), v) {
        const C = this.faceVertexUvs[0][f];
        n.push(
          p(C[0]),
          p(C[1]),
          p(C[2])
        );
      }
      if (g && n.push(d(m.normal)), S) {
        const C = m.vertexNormals;
        n.push(
          d(C[0]),
          d(C[1]),
          d(C[2])
        );
      }
      if (T && n.push(u(m.color)), E) {
        const C = m.vertexColors;
        n.push(
          u(C[0]),
          u(C[1]),
          u(C[2])
        );
      }
    }
    function h(f, m, y) {
      return y ? f | 1 << m : f & ~(1 << m);
    }
    function d(f) {
      const m = f.x.toString() + f.y.toString() + f.z.toString();
      return s[m] !== void 0 || (s[m] = r.length / 3, r.push(f.x, f.y, f.z)), s[m];
    }
    function u(f) {
      const m = f.r.toString() + f.g.toString() + f.b.toString();
      return a[m] !== void 0 || (a[m] = o.length, o.push(f.getHex())), a[m];
    }
    function p(f) {
      const m = f.x.toString() + f.y.toString();
      return c[m] !== void 0 || (c[m] = l.length / 2, l.push(f.x, f.y)), c[m];
    }
    return t.data = {}, t.data.vertices = e, t.data.normals = r, o.length > 0 && (t.data.colors = o), l.length > 0 && (t.data.uvs = [l]), t.data.faces = n, t;
  },
  clone: function() {
    return new cn().copy(this);
  },
  copy: function(t) {
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
    const e = t.vertices;
    for (let u = 0, p = e.length; u < p; u++)
      this.vertices.push(e[u].clone());
    const n = t.colors;
    for (let u = 0, p = n.length; u < p; u++)
      this.colors.push(n[u].clone());
    const r = t.faces;
    for (let u = 0, p = r.length; u < p; u++)
      this.faces.push(r[u].clone());
    for (let u = 0, p = t.faceVertexUvs.length; u < p; u++) {
      const f = t.faceVertexUvs[u];
      this.faceVertexUvs[u] === void 0 && (this.faceVertexUvs[u] = []);
      for (let m = 0, y = f.length; m < y; m++) {
        const x = f[m], v = [];
        for (let g = 0, S = x.length; g < S; g++) {
          const T = x[g];
          v.push(T.clone());
        }
        this.faceVertexUvs[u].push(v);
      }
    }
    const s = t.morphTargets;
    for (let u = 0, p = s.length; u < p; u++) {
      const f = {};
      if (f.name = s[u].name, s[u].vertices !== void 0) {
        f.vertices = [];
        for (let m = 0, y = s[u].vertices.length; m < y; m++)
          f.vertices.push(s[u].vertices[m].clone());
      }
      if (s[u].normals !== void 0) {
        f.normals = [];
        for (let m = 0, y = s[u].normals.length; m < y; m++)
          f.normals.push(s[u].normals[m].clone());
      }
      this.morphTargets.push(f);
    }
    const o = t.morphNormals;
    for (let u = 0, p = o.length; u < p; u++) {
      const f = {};
      if (o[u].vertexNormals !== void 0) {
        f.vertexNormals = [];
        for (let m = 0, y = o[u].vertexNormals.length; m < y; m++) {
          const x = o[u].vertexNormals[m], v = {};
          v.a = x.a.clone(), v.b = x.b.clone(), v.c = x.c.clone(), f.vertexNormals.push(v);
        }
      }
      if (o[u].faceNormals !== void 0) {
        f.faceNormals = [];
        for (let m = 0, y = o[u].faceNormals.length; m < y; m++)
          f.faceNormals.push(o[u].faceNormals[m].clone());
      }
      this.morphNormals.push(f);
    }
    const a = t.skinWeights;
    for (let u = 0, p = a.length; u < p; u++)
      this.skinWeights.push(a[u].clone());
    const l = t.skinIndices;
    for (let u = 0, p = l.length; u < p; u++)
      this.skinIndices.push(l[u].clone());
    const c = t.lineDistances;
    for (let u = 0, p = c.length; u < p; u++)
      this.lineDistances.push(c[u]);
    const h = t.boundingBox;
    h !== null && (this.boundingBox = h.clone());
    const d = t.boundingSphere;
    return d !== null && (this.boundingSphere = d.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
let zS = class extends cn {
  constructor(e, n, r, s, o, a) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: r,
      widthSegments: s,
      heightSegments: o,
      depthSegments: a
    }, this.fromBufferGeometry(new Yf(e, n, r, s, o, a)), this.mergeVertices();
  }
};
new z();
new z();
new z();
new oi();
const US = {
  triangulate: function(t, e, n) {
    n = n || 2;
    const r = e && e.length, s = r ? e[0] * n : t.length;
    let o = Ry(t, 0, s, n, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let l, c, h, d, u, p, f;
    if (r && (o = WS(t, e, o, n)), t.length > 80 * n) {
      l = h = t[0], c = d = t[1];
      for (let m = n; m < s; m += n)
        u = t[m], p = t[m + 1], u < l && (l = u), p < c && (c = p), u > h && (h = u), p > d && (d = p);
      f = Math.max(h - l, d - c), f = f !== 0 ? 1 / f : 0;
    }
    return sl(o, a, n, l, c, f), a;
  }
};
function Ry(t, e, n, r, s) {
  let o, a;
  if (s === t1(t, e, n, r) > 0)
    for (o = e; o < n; o += r) a = Em(o, t[o], t[o + 1], a);
  else
    for (o = n - r; o >= e; o -= r) a = Em(o, t[o], t[o + 1], a);
  return a && eu(a, a.next) && (al(a), a = a.next), a;
}
function $r(t, e) {
  if (!t) return t;
  e || (e = t);
  let n = t, r;
  do
    if (r = !1, !n.steiner && (eu(n, n.next) || wt(n.prev, n, n.next) === 0)) {
      if (al(n), n = e = n.prev, n === n.next) break;
      r = !0;
    } else
      n = n.next;
  while (r || n !== e);
  return e;
}
function sl(t, e, n, r, s, o, a) {
  if (!t) return;
  !a && o && YS(t, r, s, o);
  let l = t, c, h;
  for (; t.prev !== t.next; ) {
    if (c = t.prev, h = t.next, o ? GS(t, r, s, o) : HS(t)) {
      e.push(c.i / n), e.push(t.i / n), e.push(h.i / n), al(t), t = h.next, l = h.next;
      continue;
    }
    if (t = h, t === l) {
      a ? a === 1 ? (t = VS($r(t), e, n), sl(t, e, n, r, s, o, 2)) : a === 2 && kS(t, e, n, r, s, o) : sl($r(t), e, n, r, s, o, 1);
      break;
    }
  }
}
function HS(t) {
  const e = t.prev, n = t, r = t.next;
  if (wt(e, n, r) >= 0) return !1;
  let s = t.next.next;
  for (; s !== t.prev; ) {
    if (mo(e.x, e.y, n.x, n.y, r.x, r.y, s.x, s.y) && wt(s.prev, s, s.next) >= 0) return !1;
    s = s.next;
  }
  return !0;
}
function GS(t, e, n, r) {
  const s = t.prev, o = t, a = t.next;
  if (wt(s, o, a) >= 0) return !1;
  const l = s.x < o.x ? s.x < a.x ? s.x : a.x : o.x < a.x ? o.x : a.x, c = s.y < o.y ? s.y < a.y ? s.y : a.y : o.y < a.y ? o.y : a.y, h = s.x > o.x ? s.x > a.x ? s.x : a.x : o.x > a.x ? o.x : a.x, d = s.y > o.y ? s.y > a.y ? s.y : a.y : o.y > a.y ? o.y : a.y, u = zd(l, c, e, n, r), p = zd(h, d, e, n, r);
  let f = t.prevZ, m = t.nextZ;
  for (; f && f.z >= u && m && m.z <= p; ) {
    if (f !== t.prev && f !== t.next && mo(s.x, s.y, o.x, o.y, a.x, a.y, f.x, f.y) && wt(f.prev, f, f.next) >= 0 || (f = f.prevZ, m !== t.prev && m !== t.next && mo(s.x, s.y, o.x, o.y, a.x, a.y, m.x, m.y) && wt(m.prev, m, m.next) >= 0)) return !1;
    m = m.nextZ;
  }
  for (; f && f.z >= u; ) {
    if (f !== t.prev && f !== t.next && mo(s.x, s.y, o.x, o.y, a.x, a.y, f.x, f.y) && wt(f.prev, f, f.next) >= 0) return !1;
    f = f.prevZ;
  }
  for (; m && m.z <= p; ) {
    if (m !== t.prev && m !== t.next && mo(s.x, s.y, o.x, o.y, a.x, a.y, m.x, m.y) && wt(m.prev, m, m.next) >= 0) return !1;
    m = m.nextZ;
  }
  return !0;
}
function VS(t, e, n) {
  let r = t;
  do {
    const s = r.prev, o = r.next.next;
    !eu(s, o) && Py(s, r, r.next, o) && ol(s, o) && ol(o, s) && (e.push(s.i / n), e.push(r.i / n), e.push(o.i / n), al(r), al(r.next), r = t = o), r = r.next;
  } while (r !== t);
  return $r(r);
}
function kS(t, e, n, r, s, o) {
  let a = t;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && KS(a, l)) {
        let c = Iy(a, l);
        a = $r(a, a.next), c = $r(c, c.next), sl(a, e, n, r, s, o), sl(c, e, n, r, s, o);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== t);
}
function WS(t, e, n, r) {
  const s = [];
  let o, a, l, c, h;
  for (o = 0, a = e.length; o < a; o++)
    l = e[o] * r, c = o < a - 1 ? e[o + 1] * r : t.length, h = Ry(t, l, c, r, !1), h === h.next && (h.steiner = !0), s.push(JS(h));
  for (s.sort($S), o = 0; o < s.length; o++)
    jS(s[o], n), n = $r(n, n.next);
  return n;
}
function $S(t, e) {
  return t.x - e.x;
}
function jS(t, e) {
  if (e = qS(t, e), e) {
    const n = Iy(e, t);
    $r(e, e.next), $r(n, n.next);
  }
}
function qS(t, e) {
  let n = e;
  const r = t.x, s = t.y;
  let o = -1 / 0, a;
  do {
    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
      const p = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (p <= r && p > o) {
        if (o = p, p === r) {
          if (s === n.y) return n;
          if (s === n.next.y) return n.next;
        }
        a = n.x < n.next.x ? n : n.next;
      }
    }
    n = n.next;
  } while (n !== e);
  if (!a) return null;
  if (r === o) return a;
  const l = a, c = a.x, h = a.y;
  let d = 1 / 0, u;
  n = a;
  do
    r >= n.x && n.x >= c && r !== n.x && mo(s < h ? r : o, s, c, h, s < h ? o : r, s, n.x, n.y) && (u = Math.abs(s - n.y) / (r - n.x), ol(n, t) && (u < d || u === d && (n.x > a.x || n.x === a.x && XS(a, n))) && (a = n, d = u)), n = n.next;
  while (n !== l);
  return a;
}
function XS(t, e) {
  return wt(t.prev, t, e.prev) < 0 && wt(e.next, t, t.next) < 0;
}
function YS(t, e, n, r) {
  let s = t;
  do
    s.z === null && (s.z = zd(s.x, s.y, e, n, r)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== t);
  s.prevZ.nextZ = null, s.prevZ = null, ZS(s);
}
function ZS(t) {
  let e, n, r, s, o, a, l, c, h = 1;
  do {
    for (n = t, t = null, o = null, a = 0; n; ) {
      for (a++, r = n, l = 0, e = 0; e < h && (l++, r = r.nextZ, !!r); e++)
        ;
      for (c = h; l > 0 || c > 0 && r; )
        l !== 0 && (c === 0 || !r || n.z <= r.z) ? (s = n, n = n.nextZ, l--) : (s = r, r = r.nextZ, c--), o ? o.nextZ = s : t = s, s.prevZ = o, o = s;
      n = r;
    }
    o.nextZ = null, h *= 2;
  } while (a > 1);
  return t;
}
function zd(t, e, n, r, s) {
  return t = 32767 * (t - n) * s, e = 32767 * (e - r) * s, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1;
}
function JS(t) {
  let e = t, n = t;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== t);
  return n;
}
function mo(t, e, n, r, s, o, a, l) {
  return (s - a) * (e - l) - (t - a) * (o - l) >= 0 && (t - a) * (r - l) - (n - a) * (e - l) >= 0 && (n - a) * (o - l) - (s - a) * (r - l) >= 0;
}
function KS(t, e) {
  return t.next.i !== e.i && t.prev.i !== e.i && !QS(t, e) && // dones't intersect other edges
  (ol(t, e) && ol(e, t) && e1(t, e) && // locally visible
  (wt(t.prev, t, e.prev) || wt(t, e.prev, e)) || // does not create opposite-facing sectors
  eu(t, e) && wt(t.prev, t, t.next) > 0 && wt(e.prev, e, e.next) > 0);
}
function wt(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function eu(t, e) {
  return t.x === e.x && t.y === e.y;
}
function Py(t, e, n, r) {
  const s = pc(wt(t, e, n)), o = pc(wt(t, e, r)), a = pc(wt(n, r, t)), l = pc(wt(n, r, e));
  return !!(s !== o && a !== l || s === 0 && fc(t, n, e) || o === 0 && fc(t, r, e) || a === 0 && fc(n, t, r) || l === 0 && fc(n, e, r));
}
function fc(t, e, n) {
  return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
}
function pc(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function QS(t, e) {
  let n = t;
  do {
    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Py(n, n.next, t, e)) return !0;
    n = n.next;
  } while (n !== t);
  return !1;
}
function ol(t, e) {
  return wt(t.prev, t, t.next) < 0 ? wt(t, e, t.next) >= 0 && wt(t, t.prev, e) >= 0 : wt(t, e, t.prev) < 0 || wt(t, t.next, e) < 0;
}
function e1(t, e) {
  let n = t, r = !1;
  const s = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && s < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next;
  while (n !== t);
  return r;
}
function Iy(t, e) {
  const n = new Ud(t.i, t.x, t.y), r = new Ud(e.i, e.x, e.y), s = t.next, o = e.prev;
  return t.next = e, e.prev = t, n.next = s, s.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r;
}
function Em(t, e, n, r) {
  const s = new Ud(t, e, n);
  return r ? (s.next = r.next, s.prev = r, r.next.prev = s, r.next = s) : (s.prev = s, s.next = s), s;
}
function al(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Ud(t, e, n) {
  this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function t1(t, e, n, r) {
  let s = 0;
  for (let o = e, a = n - r; o < n; o += r)
    s += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
  return s;
}
const Or = {
  // calculate area of the contour polygon
  area: function(t) {
    const e = t.length;
    let n = 0;
    for (let r = e - 1, s = 0; s < e; r = s++)
      n += t[r].x * t[s].y - t[s].x * t[r].y;
    return n * 0.5;
  },
  isClockWise: function(t) {
    return Or.area(t) < 0;
  },
  triangulateShape: function(t, e) {
    const n = [], r = [], s = [];
    Tm(t), Am(n, t);
    let o = t.length;
    e.forEach(Tm);
    for (let l = 0; l < e.length; l++)
      r.push(o), o += e[l].length, Am(n, e[l]);
    const a = US.triangulate(n, r);
    for (let l = 0; l < a.length; l += 3)
      s.push(a.slice(l, l + 3));
    return s;
  }
};
function Tm(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function Am(t, e) {
  for (let n = 0; n < e.length; n++)
    t.push(e[n].x), t.push(e[n].y);
}
let Dy = class extends it {
  constructor(e, n) {
    super(), this.type = "ExtrudeBufferGeometry", this.parameters = {
      shapes: e,
      options: n
    }, e = Array.isArray(e) ? e : [e];
    const r = this, s = [], o = [];
    for (let l = 0, c = e.length; l < c; l++) {
      const h = e[l];
      a(h);
    }
    this.setAttribute("position", new Ke(s, 3)), this.setAttribute("uv", new Ke(o, 2)), this.computeVertexNormals();
    function a(l) {
      const c = [], h = n.curveSegments !== void 0 ? n.curveSegments : 12, d = n.steps !== void 0 ? n.steps : 1;
      let u = n.depth !== void 0 ? n.depth : 100, p = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0, f = n.bevelThickness !== void 0 ? n.bevelThickness : 6, m = n.bevelSize !== void 0 ? n.bevelSize : f - 2, y = n.bevelOffset !== void 0 ? n.bevelOffset : 0, x = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
      const v = n.extrudePath, g = n.UVGenerator !== void 0 ? n.UVGenerator : n1;
      n.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), u = n.amount);
      let S, T = !1, E, w, C, ee;
      v && (S = v.getSpacedPoints(d), T = !0, p = !1, E = v.computeFrenetFrames(d, !1), w = new z(), C = new z(), ee = new z()), p || (x = 0, f = 0, m = 0, y = 0);
      const Y = l.extractPoints(h);
      let le = Y.shape;
      const B = Y.holes;
      if (!Or.isClockWise(le)) {
        le = le.reverse();
        for (let R = 0, D = B.length; R < D; R++) {
          const H = B[R];
          Or.isClockWise(H) && (B[R] = H.reverse());
        }
      }
      const k = Or.triangulateShape(le, B), O = le;
      for (let R = 0, D = B.length; R < D; R++) {
        const H = B[R];
        le = le.concat(H);
      }
      function P(R, D, H) {
        return D || console.error("THREE.ExtrudeGeometry: vec does not exist"), D.clone().multiplyScalar(H).add(R);
      }
      const j = le.length, re = k.length;
      function ae(R, D, H) {
        let ne, J, b;
        const _ = R.x - D.x, Q = R.y - D.y, X = H.x - R.x, A = H.y - R.y, ie = _ * _ + Q * Q, oe = _ * A - Q * X;
        if (Math.abs(oe) > Number.EPSILON) {
          const he = Math.sqrt(ie), se = Math.sqrt(X * X + A * A), me = D.x - Q / he, ve = D.y + _ / he, be = H.x - A / se, fe = H.y + X / se, _e = ((be - me) * A - (fe - ve) * X) / (_ * A - Q * X);
          ne = me + _ * _e - R.x, J = ve + Q * _e - R.y;
          const Pe = ne * ne + J * J;
          if (Pe <= 2)
            return new ye(ne, J);
          b = Math.sqrt(Pe / 2);
        } else {
          let he = !1;
          _ > Number.EPSILON ? X > Number.EPSILON && (he = !0) : _ < -Number.EPSILON ? X < -Number.EPSILON && (he = !0) : Math.sign(Q) === Math.sign(A) && (he = !0), he ? (ne = -Q, J = _, b = Math.sqrt(ie)) : (ne = _, J = Q, b = Math.sqrt(ie / 2));
        }
        return new ye(ne / b, J / b);
      }
      const ce = [];
      for (let R = 0, D = O.length, H = D - 1, ne = R + 1; R < D; R++, H++, ne++)
        H === D && (H = 0), ne === D && (ne = 0), ce[R] = ae(O[R], O[H], O[ne]);
      const pe = [];
      let de, ge = ce.concat();
      for (let R = 0, D = B.length; R < D; R++) {
        const H = B[R];
        de = [];
        for (let ne = 0, J = H.length, b = J - 1, _ = ne + 1; ne < J; ne++, b++, _++)
          b === J && (b = 0), _ === J && (_ = 0), de[ne] = ae(H[ne], H[b], H[_]);
        pe.push(de), ge = ge.concat(de);
      }
      for (let R = 0; R < x; R++) {
        const D = R / x, H = f * Math.cos(D * Math.PI / 2), ne = m * Math.sin(D * Math.PI / 2) + y;
        for (let J = 0, b = O.length; J < b; J++) {
          const _ = P(O[J], ce[J], ne);
          L(_.x, _.y, -H);
        }
        for (let J = 0, b = B.length; J < b; J++) {
          const _ = B[J];
          de = pe[J];
          for (let Q = 0, X = _.length; Q < X; Q++) {
            const A = P(_[Q], de[Q], ne);
            L(A.x, A.y, -H);
          }
        }
      }
      const we = m + y;
      for (let R = 0; R < j; R++) {
        const D = p ? P(le[R], ge[R], we) : le[R];
        T ? (C.copy(E.normals[0]).multiplyScalar(D.x), w.copy(E.binormals[0]).multiplyScalar(D.y), ee.copy(S[0]).add(C).add(w), L(ee.x, ee.y, ee.z)) : L(D.x, D.y, 0);
      }
      for (let R = 1; R <= d; R++)
        for (let D = 0; D < j; D++) {
          const H = p ? P(le[D], ge[D], we) : le[D];
          T ? (C.copy(E.normals[R]).multiplyScalar(H.x), w.copy(E.binormals[R]).multiplyScalar(H.y), ee.copy(S[R]).add(C).add(w), L(ee.x, ee.y, ee.z)) : L(H.x, H.y, u / d * R);
        }
      for (let R = x - 1; R >= 0; R--) {
        const D = R / x, H = f * Math.cos(D * Math.PI / 2), ne = m * Math.sin(D * Math.PI / 2) + y;
        for (let J = 0, b = O.length; J < b; J++) {
          const _ = P(O[J], ce[J], ne);
          L(_.x, _.y, u + H);
        }
        for (let J = 0, b = B.length; J < b; J++) {
          const _ = B[J];
          de = pe[J];
          for (let Q = 0, X = _.length; Q < X; Q++) {
            const A = P(_[Q], de[Q], ne);
            T ? L(A.x, A.y + S[d - 1].y, S[d - 1].x + H) : L(A.x, A.y, u + H);
          }
        }
      }
      Ge(), te();
      function Ge() {
        const R = s.length / 3;
        if (p) {
          let D = 0, H = j * D;
          for (let ne = 0; ne < re; ne++) {
            const J = k[ne];
            U(J[2] + H, J[1] + H, J[0] + H);
          }
          D = d + x * 2, H = j * D;
          for (let ne = 0; ne < re; ne++) {
            const J = k[ne];
            U(J[0] + H, J[1] + H, J[2] + H);
          }
        } else {
          for (let D = 0; D < re; D++) {
            const H = k[D];
            U(H[2], H[1], H[0]);
          }
          for (let D = 0; D < re; D++) {
            const H = k[D];
            U(H[0] + j * d, H[1] + j * d, H[2] + j * d);
          }
        }
        r.addGroup(R, s.length / 3 - R, 0);
      }
      function te() {
        const R = s.length / 3;
        let D = 0;
        I(O, D), D += O.length;
        for (let H = 0, ne = B.length; H < ne; H++) {
          const J = B[H];
          I(J, D), D += J.length;
        }
        r.addGroup(R, s.length / 3 - R, 1);
      }
      function I(R, D) {
        let H = R.length;
        for (; --H >= 0; ) {
          const ne = H;
          let J = H - 1;
          J < 0 && (J = R.length - 1);
          for (let b = 0, _ = d + x * 2; b < _; b++) {
            const Q = j * b, X = j * (b + 1), A = D + ne + Q, ie = D + J + Q, oe = D + J + X, he = D + ne + X;
            N(A, ie, oe, he);
          }
        }
      }
      function L(R, D, H) {
        c.push(R), c.push(D), c.push(H);
      }
      function U(R, D, H) {
        V(R), V(D), V(H);
        const ne = s.length / 3, J = g.generateTopUV(r, s, ne - 3, ne - 2, ne - 1);
        W(J[0]), W(J[1]), W(J[2]);
      }
      function N(R, D, H, ne) {
        V(R), V(D), V(ne), V(D), V(H), V(ne);
        const J = s.length / 3, b = g.generateSideWallUV(r, s, J - 6, J - 3, J - 2, J - 1);
        W(b[0]), W(b[1]), W(b[3]), W(b[1]), W(b[2]), W(b[3]);
      }
      function V(R) {
        s.push(c[R * 3 + 0]), s.push(c[R * 3 + 1]), s.push(c[R * 3 + 2]);
      }
      function W(R) {
        o.push(R.x), o.push(R.y);
      }
    }
  }
  toJSON() {
    const e = it.prototype.toJSON.call(this), n = this.parameters.shapes, r = this.parameters.options;
    return i1(n, r, e);
  }
};
const n1 = {
  generateTopUV: function(t, e, n, r, s) {
    const o = e[n * 3], a = e[n * 3 + 1], l = e[r * 3], c = e[r * 3 + 1], h = e[s * 3], d = e[s * 3 + 1];
    return [
      new ye(o, a),
      new ye(l, c),
      new ye(h, d)
    ];
  },
  generateSideWallUV: function(t, e, n, r, s, o) {
    const a = e[n * 3], l = e[n * 3 + 1], c = e[n * 3 + 2], h = e[r * 3], d = e[r * 3 + 1], u = e[r * 3 + 2], p = e[s * 3], f = e[s * 3 + 1], m = e[s * 3 + 2], y = e[o * 3], x = e[o * 3 + 1], v = e[o * 3 + 2];
    return Math.abs(l - d) < 0.01 ? [
      new ye(a, 1 - c),
      new ye(h, 1 - u),
      new ye(p, 1 - m),
      new ye(y, 1 - v)
    ] : [
      new ye(l, 1 - c),
      new ye(d, 1 - u),
      new ye(f, 1 - m),
      new ye(x, 1 - v)
    ];
  }
};
function i1(t, e, n) {
  if (n.shapes = [], Array.isArray(t))
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      n.shapes.push(o.uuid);
    }
  else
    n.shapes.push(t.uuid);
  return e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}
let r1 = class extends cn {
  constructor(e, n) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: n
    }, this.fromBufferGeometry(new Dy(e, n)), this.mergeVertices();
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes, r = this.parameters.options;
    return s1(n, r, e);
  }
};
function s1(t, e, n) {
  if (n.shapes = [], Array.isArray(t))
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      n.shapes.push(o.uuid);
    }
  else
    n.shapes.push(t.uuid);
  return e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}
function wh(t, e, n) {
  it.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
    func: t,
    slices: e,
    stacks: n
  };
  const r = [], s = [], o = [], a = [], l = 1e-5, c = new z(), h = new z(), d = new z(), u = new z(), p = new z();
  t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  const f = e + 1;
  for (let m = 0; m <= n; m++) {
    const y = m / n;
    for (let x = 0; x <= e; x++) {
      const v = x / e;
      t(v, y, h), s.push(h.x, h.y, h.z), v - l >= 0 ? (t(v - l, y, d), u.subVectors(h, d)) : (t(v + l, y, d), u.subVectors(d, h)), y - l >= 0 ? (t(v, y - l, d), p.subVectors(h, d)) : (t(v, y + l, d), p.subVectors(d, h)), c.crossVectors(u, p).normalize(), o.push(c.x, c.y, c.z), a.push(v, y);
    }
  }
  for (let m = 0; m < n; m++)
    for (let y = 0; y < e; y++) {
      const x = m * f + y, v = m * f + y + 1, g = (m + 1) * f + y + 1, S = (m + 1) * f + y;
      r.push(x, v, S), r.push(v, g, S);
    }
  this.setIndex(r), this.setAttribute("position", new Ke(s, 3)), this.setAttribute("normal", new Ke(o, 3)), this.setAttribute("uv", new Ke(a, 2));
}
wh.prototype = Object.create(it.prototype);
wh.prototype.constructor = wh;
function Hd(t, e, n) {
  cn.call(this), this.type = "ParametricGeometry", this.parameters = {
    func: t,
    slices: e,
    stacks: n
  }, this.fromBufferGeometry(new wh(t, e, n)), this.mergeVertices();
}
Hd.prototype = Object.create(cn.prototype);
Hd.prototype.constructor = Hd;
let o1 = class extends it {
  constructor(e, n = 12) {
    super(), this.type = "ShapeBufferGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const r = [], s = [], o = [], a = [];
    let l = 0, c = 0;
    if (Array.isArray(e) === !1)
      h(e);
    else
      for (let d = 0; d < e.length; d++)
        h(e[d]), this.addGroup(l, c, d), l += c, c = 0;
    this.setIndex(r), this.setAttribute("position", new Ke(s, 3)), this.setAttribute("normal", new Ke(o, 3)), this.setAttribute("uv", new Ke(a, 2));
    function h(d) {
      const u = s.length / 3, p = d.extractPoints(n);
      let f = p.shape;
      const m = p.holes;
      Or.isClockWise(f) === !1 && (f = f.reverse());
      for (let x = 0, v = m.length; x < v; x++) {
        const g = m[x];
        Or.isClockWise(g) === !0 && (m[x] = g.reverse());
      }
      const y = Or.triangulateShape(f, m);
      for (let x = 0, v = m.length; x < v; x++) {
        const g = m[x];
        f = f.concat(g);
      }
      for (let x = 0, v = f.length; x < v; x++) {
        const g = f[x];
        s.push(g.x, g.y, 0), o.push(0, 0, 1), a.push(g.x, g.y);
      }
      for (let x = 0, v = y.length; x < v; x++) {
        const g = y[x], S = g[0] + u, T = g[1] + u, E = g[2] + u;
        r.push(S, T, E), c += 3;
      }
    }
  }
  toJSON() {
    const e = it.prototype.toJSON.call(this), n = this.parameters.shapes;
    return a1(n, e);
  }
};
function a1(t, e) {
  if (e.shapes = [], Array.isArray(t))
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.shapes.push(s.uuid);
    }
  else
    e.shapes.push(t.uuid);
  return e;
}
let l1 = class extends cn {
  constructor(e, n) {
    super(), this.type = "ShapeGeometry", typeof n == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), n = n.curveSegments), this.parameters = {
      shapes: e,
      curveSegments: n
    }, this.fromBufferGeometry(new o1(e, n)), this.mergeVertices();
  }
  toJSON() {
    const e = cn.prototype.toJSON.call(this), n = this.parameters.shapes;
    return c1(n, e);
  }
};
function c1(t, e) {
  if (e.shapes = [], Array.isArray(t))
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.shapes.push(s.uuid);
    }
  else
    e.shapes.push(t.uuid);
  return e;
}
let h1 = class extends it {
  constructor(e = 1, n = 8, r = 6, s = 0, o = Math.PI * 2, a = 0, l = Math.PI) {
    super(), this.type = "SphereBufferGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: r,
      phiStart: s,
      phiLength: o,
      thetaStart: a,
      thetaLength: l
    }, n = Math.max(3, Math.floor(n)), r = Math.max(2, Math.floor(r));
    const c = Math.min(a + l, Math.PI);
    let h = 0;
    const d = [], u = new z(), p = new z(), f = [], m = [], y = [], x = [];
    for (let v = 0; v <= r; v++) {
      const g = [], S = v / r;
      let T = 0;
      v == 0 && a == 0 ? T = 0.5 / n : v == r && c == Math.PI && (T = -0.5 / n);
      for (let E = 0; E <= n; E++) {
        const w = E / n;
        u.x = -e * Math.cos(s + w * o) * Math.sin(a + S * l), u.y = e * Math.cos(a + S * l), u.z = e * Math.sin(s + w * o) * Math.sin(a + S * l), m.push(u.x, u.y, u.z), p.copy(u).normalize(), y.push(p.x, p.y, p.z), x.push(w + T, 1 - S), g.push(h++);
      }
      d.push(g);
    }
    for (let v = 0; v < r; v++)
      for (let g = 0; g < n; g++) {
        const S = d[v][g + 1], T = d[v][g], E = d[v + 1][g], w = d[v + 1][g + 1];
        (v !== 0 || a > 0) && f.push(S, T, w), (v !== r - 1 || c < Math.PI) && f.push(T, E, w);
      }
    this.setIndex(f), this.setAttribute("position", new Ke(m, 3)), this.setAttribute("normal", new Ke(y, 3)), this.setAttribute("uv", new Ke(x, 2));
  }
}, u1 = class extends cn {
  constructor(e, n, r, s, o, a, l) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: r,
      phiStart: s,
      phiLength: o,
      thetaStart: a,
      thetaLength: l
    }, this.fromBufferGeometry(new h1(e, n, r, s, o, a, l)), this.mergeVertices();
  }
}, d1 = class extends it {
  constructor(e) {
    super(), this.type = "WireframeGeometry";
    const n = [], r = [0, 0], s = {}, o = ["a", "b", "c"];
    if (e && e.isGeometry) {
      const a = e.faces;
      for (let l = 0, c = a.length; l < c; l++) {
        const h = a[l];
        for (let d = 0; d < 3; d++) {
          const u = h[o[d]], p = h[o[(d + 1) % 3]];
          r[0] = Math.min(u, p), r[1] = Math.max(u, p);
          const f = r[0] + "," + r[1];
          s[f] === void 0 && (s[f] = { index1: r[0], index2: r[1] });
        }
      }
      for (const l in s) {
        const c = s[l];
        let h = e.vertices[c.index1];
        n.push(h.x, h.y, h.z), h = e.vertices[c.index2], n.push(h.x, h.y, h.z);
      }
    } else if (e && e.isBufferGeometry) {
      const a = new z();
      if (e.index !== null) {
        const l = e.attributes.position, c = e.index;
        let h = e.groups;
        h.length === 0 && (h = [{ start: 0, count: c.count, materialIndex: 0 }]);
        for (let d = 0, u = h.length; d < u; ++d) {
          const p = h[d], f = p.start, m = p.count;
          for (let y = f, x = f + m; y < x; y += 3)
            for (let v = 0; v < 3; v++) {
              const g = c.getX(y + v), S = c.getX(y + (v + 1) % 3);
              r[0] = Math.min(g, S), r[1] = Math.max(g, S);
              const T = r[0] + "," + r[1];
              s[T] === void 0 && (s[T] = { index1: r[0], index2: r[1] });
            }
        }
        for (const d in s) {
          const u = s[d];
          a.fromBufferAttribute(l, u.index1), n.push(a.x, a.y, a.z), a.fromBufferAttribute(l, u.index2), n.push(a.x, a.y, a.z);
        }
      } else {
        const l = e.attributes.position;
        for (let c = 0, h = l.count / 3; c < h; c++)
          for (let d = 0; d < 3; d++) {
            const u = 3 * c + d;
            a.fromBufferAttribute(l, u), n.push(a.x, a.y, a.z);
            const p = 3 * c + (d + 1) % 3;
            a.fromBufferAttribute(l, p), n.push(a.x, a.y, a.z);
          }
      }
    }
    this.setAttribute("position", new Ke(n, 3));
  }
};
function Po(t) {
  Ve.call(this), this.type = "ShadowMaterial", this.color = new Ne(0), this.transparent = !0, this.setValues(t);
}
Po.prototype = Object.create(Ve.prototype);
Po.prototype.constructor = Po;
Po.prototype.isShadowMaterial = !0;
Po.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.color.copy(t.color), this;
};
function ll(t) {
  rn.call(this, t), this.type = "RawShaderMaterial";
}
ll.prototype = Object.create(rn.prototype);
ll.prototype.constructor = ll;
ll.prototype.isRawShaderMaterial = !0;
function Mi(t) {
  Ve.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ne(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = As, this.normalScale = new ye(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t);
}
Mi.prototype = Object.create(Ve.prototype);
Mi.prototype.constructor = Mi;
Mi.prototype.isMeshStandardMaterial = !0;
Mi.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this;
};
function jr(t) {
  Mi.call(this), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ye(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", {
    get: function() {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function(e) {
      this.reflectivity = $e.clamp(2.5 * (e - 1) / (e + 1), 0, 1);
    }
  }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t);
}
jr.prototype = Object.create(Mi.prototype);
jr.prototype.constructor = jr;
jr.prototype.isMeshPhysicalMaterial = !0;
jr.prototype.copy = function(t) {
  return Mi.prototype.copy.call(this, t), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Ne()).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this;
};
function ys(t) {
  Ve.call(this), this.type = "MeshPhongMaterial", this.color = new Ne(16777215), this.specular = new Ne(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = As, this.normalScale = new ye(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Zh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
ys.prototype = Object.create(Ve.prototype);
ys.prototype.constructor = ys;
ys.prototype.isMeshPhongMaterial = !0;
ys.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function Io(t) {
  Ve.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Ne(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = As, this.normalScale = new ye(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
Io.prototype = Object.create(Ve.prototype);
Io.prototype.constructor = Io;
Io.prototype.isMeshToonMaterial = !0;
Io.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function xs(t) {
  Ve.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = As, this.normalScale = new ye(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
xs.prototype = Object.create(Ve.prototype);
xs.prototype.constructor = xs;
xs.prototype.isMeshNormalMaterial = !0;
xs.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function Do(t) {
  Ve.call(this), this.type = "MeshLambertMaterial", this.color = new Ne(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Zh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
Do.prototype = Object.create(Ve.prototype);
Do.prototype.constructor = Do;
Do.prototype.isMeshLambertMaterial = !0;
Do.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function No(t) {
  Ve.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Ne(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = As, this.normalScale = new ye(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
No.prototype = Object.create(Ve.prototype);
No.prototype.constructor = No;
No.prototype.isMeshMatcapMaterial = !0;
No.prototype.copy = function(t) {
  return Ve.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function Oo(t) {
  un.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
}
Oo.prototype = Object.create(un.prototype);
Oo.prototype.constructor = Oo;
Oo.prototype.isLineDashedMaterial = !0;
Oo.prototype.copy = function(t) {
  return un.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
};
var f1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial: Po,
  SpriteMaterial: kr,
  RawShaderMaterial: ll,
  ShaderMaterial: rn,
  PointsMaterial: li,
  MeshPhysicalMaterial: jr,
  MeshStandardMaterial: Mi,
  MeshPhongMaterial: ys,
  MeshToonMaterial: Io,
  MeshNormalMaterial: xs,
  MeshLambertMaterial: Do,
  MeshDepthMaterial: gs,
  MeshDistanceMaterial: vs,
  MeshBasicMaterial: Fn,
  MeshMatcapMaterial: No,
  LineDashedMaterial: Oo,
  LineBasicMaterial: un,
  Material: Ve
});
const _t = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(t, e, n) {
    return _t.isTypedArray(t) ? new t.constructor(t.subarray(e, n !== void 0 ? n : t.length)) : t.slice(e, n);
  },
  // converts an array to a specific type
  convertArray: function(t, e, n) {
    return !t || // let 'undefined' and 'null' pass
    !n && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t);
  },
  isTypedArray: function(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(t) {
    function e(s, o) {
      return t[s] - t[o];
    }
    const n = t.length, r = new Array(n);
    for (let s = 0; s !== n; ++s) r[s] = s;
    return r.sort(e), r;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(t, e, n) {
    const r = t.length, s = new t.constructor(r);
    for (let o = 0, a = 0; a !== r; ++o) {
      const l = n[o] * e;
      for (let c = 0; c !== e; ++c)
        s[a++] = t[l + c];
    }
    return s;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(t, e, n, r) {
    let s = 1, o = t[0];
    for (; o !== void 0 && o[r] === void 0; )
      o = t[s++];
    if (o === void 0) return;
    let a = o[r];
    if (a !== void 0)
      if (Array.isArray(a))
        do
          a = o[r], a !== void 0 && (e.push(o.time), n.push.apply(n, a)), o = t[s++];
        while (o !== void 0);
      else if (a.toArray !== void 0)
        do
          a = o[r], a !== void 0 && (e.push(o.time), a.toArray(n, n.length)), o = t[s++];
        while (o !== void 0);
      else
        do
          a = o[r], a !== void 0 && (e.push(o.time), n.push(a)), o = t[s++];
        while (o !== void 0);
  },
  subclip: function(t, e, n, r, s = 30) {
    const o = t.clone();
    o.name = e;
    const a = [];
    for (let c = 0; c < o.tracks.length; ++c) {
      const h = o.tracks[c], d = h.getValueSize(), u = [], p = [];
      for (let f = 0; f < h.times.length; ++f) {
        const m = h.times[f] * s;
        if (!(m < n || m >= r)) {
          u.push(h.times[f]);
          for (let y = 0; y < d; ++y)
            p.push(h.values[f * d + y]);
        }
      }
      u.length !== 0 && (h.times = _t.convertArray(u, h.times.constructor), h.values = _t.convertArray(p, h.values.constructor), a.push(h));
    }
    o.tracks = a;
    let l = 1 / 0;
    for (let c = 0; c < o.tracks.length; ++c)
      l > o.tracks[c].times[0] && (l = o.tracks[c].times[0]);
    for (let c = 0; c < o.tracks.length; ++c)
      o.tracks[c].shift(-1 * l);
    return o.resetDuration(), o;
  },
  makeClipAdditive: function(t, e = 0, n = t, r = 30) {
    r <= 0 && (r = 30);
    const s = n.tracks.length, o = e / r;
    for (let a = 0; a < s; ++a) {
      const l = n.tracks[a], c = l.ValueTypeName;
      if (c === "bool" || c === "string") continue;
      const h = t.tracks.find(function(v) {
        return v.name === l.name && v.ValueTypeName === c;
      });
      if (h === void 0) continue;
      let d = 0;
      const u = l.getValueSize();
      l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = u / 3);
      let p = 0;
      const f = h.getValueSize();
      h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = f / 3);
      const m = l.times.length - 1;
      let y;
      if (o <= l.times[0]) {
        const v = d, g = u - d;
        y = _t.arraySlice(l.values, v, g);
      } else if (o >= l.times[m]) {
        const v = m * u + d, g = v + u - d;
        y = _t.arraySlice(l.values, v, g);
      } else {
        const v = l.createInterpolant(), g = d, S = u - d;
        v.evaluate(o), y = _t.arraySlice(v.resultBuffer, g, S);
      }
      c === "quaternion" && new bn().fromArray(y).normalize().conjugate().toArray(y);
      const x = h.times.length;
      for (let v = 0; v < x; ++v) {
        const g = v * f + p;
        if (c === "quaternion")
          bn.multiplyQuaternionsFlat(
            h.values,
            g,
            y,
            0,
            h.values,
            g
          );
        else {
          const S = f - p * 2;
          for (let T = 0; T < S; ++T)
            h.values[g + T] -= y[T];
        }
      }
    }
    return t.blendMode = uy, t;
  }
};
function wn(t, e, n, r) {
  this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n;
}
Object.assign(wn.prototype, {
  evaluate: function(t) {
    const e = this.parameterPositions;
    let n = this._cachedIndex, r = e[n], s = e[n - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(t < r)) {
            for (let a = n + 2; ; ) {
              if (r === void 0) {
                if (t < s) break i;
                return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, s);
              }
              if (n === a) break;
              if (s = r, r = e[++n], t < r)
                break t;
            }
            o = e.length;
            break n;
          }
          if (!(t >= s)) {
            const a = e[1];
            t < a && (n = 2, s = a);
            for (let l = n - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t, r);
              if (n === l) break;
              if (r = s, s = e[--n - 1], t >= s)
                break t;
            }
            o = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < o; ) {
          const a = n + o >>> 1;
          t < e[a] ? o = a : n = a + 1;
        }
        if (r = e[n], s = e[n - 1], s === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, t, r);
        if (r === void 0)
          return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, s, t);
      }
      this._cachedIndex = n, this.intervalChanged_(n, s, r);
    }
    return this.interpolate_(n, s, t, r);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(t) {
    const e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = t * r;
    for (let o = 0; o !== r; ++o)
      e[o] = n[s + o];
    return e;
  },
  // Template methods for derived classes:
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(wn.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: wn.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: wn.prototype.copySampleValue_
});
function Gd(t, e, n, r) {
  wn.call(this, t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
}
Gd.prototype = Object.assign(Object.create(wn.prototype), {
  constructor: Gd,
  DefaultSettings_: {
    endingStart: co,
    endingEnd: co
  },
  intervalChanged_: function(t, e, n) {
    const r = this.parameterPositions;
    let s = t - 2, o = t + 1, a = r[s], l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case ho:
          s = t, a = 2 * e - n;
          break;
        case mh:
          s = r.length - 2, a = e + r[s] - r[s + 1];
          break;
        default:
          s = t, a = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case ho:
          o = t, l = 2 * n - e;
          break;
        case mh:
          o = 1, l = n + r[1] - r[0];
          break;
        default:
          o = t - 1, l = e;
      }
    const c = (n - e) * 0.5, h = this.valueSize;
    this._weightPrev = c / (e - a), this._weightNext = c / (l - n), this._offsetPrev = s * h, this._offsetNext = o * h;
  },
  interpolate_: function(t, e, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, c = l - a, h = this._offsetPrev, d = this._offsetNext, u = this._weightPrev, p = this._weightNext, f = (n - e) / (r - e), m = f * f, y = m * f, x = -u * y + 2 * u * m - u * f, v = (1 + u) * y + (-1.5 - 2 * u) * m + (-0.5 + u) * f + 1, g = (-1 - p) * y + (1.5 + p) * m + 0.5 * f, S = p * y - p * m;
    for (let T = 0; T !== a; ++T)
      s[T] = x * o[h + T] + v * o[c + T] + g * o[l + T] + S * o[d + T];
    return s;
  }
});
function Mh(t, e, n, r) {
  wn.call(this, t, e, n, r);
}
Mh.prototype = Object.assign(Object.create(wn.prototype), {
  constructor: Mh,
  interpolate_: function(t, e, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, c = l - a, h = (n - e) / (r - e), d = 1 - h;
    for (let u = 0; u !== a; ++u)
      s[u] = o[c + u] * d + o[l + u] * h;
    return s;
  }
});
function Vd(t, e, n, r) {
  wn.call(this, t, e, n, r);
}
Vd.prototype = Object.assign(Object.create(wn.prototype), {
  constructor: Vd,
  interpolate_: function(t) {
    return this.copySampleValue_(t - 1);
  }
});
function Jt(t, e, n, r) {
  if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
  this.name = t, this.times = _t.convertArray(e, this.TimeBufferType), this.values = _t.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
}
Object.assign(Jt, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function(t) {
    const e = t.constructor;
    let n;
    if (e.toJSON !== void 0)
      n = e.toJSON(t);
    else {
      n = {
        name: t.name,
        times: _t.convertArray(t.times, Array),
        values: _t.convertArray(t.values, Array)
      };
      const r = t.getInterpolation();
      r !== t.DefaultInterpolation && (n.interpolation = r);
    }
    return n.type = t.ValueTypeName, n;
  }
});
Object.assign(Jt.prototype, {
  constructor: Jt,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: Fa,
  InterpolantFactoryMethodDiscrete: function(t) {
    return new Vd(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodLinear: function(t) {
    return new Mh(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: function(t) {
    return new Gd(this.times, this.values, this.getValueSize(), t);
  },
  setInterpolation: function(t) {
    let e;
    switch (t) {
      case Za:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case Fa:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case fu:
        e = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (e === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (t !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = e, this;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Za;
      case this.InterpolantFactoryMethodLinear:
        return Fa;
      case this.InterpolantFactoryMethodSmooth:
        return fu;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function(t) {
    if (t !== 0) {
      const e = this.times;
      for (let n = 0, r = e.length; n !== r; ++n)
        e[n] += t;
    }
    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function(t) {
    if (t !== 1) {
      const e = this.times;
      for (let n = 0, r = e.length; n !== r; ++n)
        e[n] *= t;
    }
    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function(t, e) {
    const n = this.times, r = n.length;
    let s = 0, o = r - 1;
    for (; s !== r && n[s] < t; )
      ++s;
    for (; o !== -1 && n[o] > e; )
      --o;
    if (++o, s !== 0 || o !== r) {
      s >= o && (o = Math.max(o, 1), s = o - 1);
      const a = this.getValueSize();
      this.times = _t.arraySlice(n, s, o), this.values = _t.arraySlice(this.values, s * a, o * a);
    }
    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function() {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
    const n = this.times, r = this.values, s = n.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = n[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), t = !1;
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), t = !1;
        break;
      }
      o = l;
    }
    if (r !== void 0 && _t.isTypedArray(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), t = !1;
          break;
        }
      }
    return t;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function() {
    const t = _t.arraySlice(this.times), e = _t.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === fu, s = t.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = t[a], h = t[a + 1];
      if (c !== h && (a !== 1 || c !== c[0]))
        if (r)
          l = !0;
        else {
          const d = a * n, u = d - n, p = d + n;
          for (let f = 0; f !== n; ++f) {
            const m = e[d + f];
            if (m !== e[u + f] || m !== e[p + f]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          t[o] = t[a];
          const d = a * n, u = o * n;
          for (let p = 0; p !== n; ++p)
            e[u + p] = e[d + p];
        }
        ++o;
      }
    }
    if (s > 0) {
      t[o] = t[s];
      for (let a = s * n, l = o * n, c = 0; c !== n; ++c)
        e[l + c] = e[a + c];
      ++o;
    }
    return o !== t.length ? (this.times = _t.arraySlice(t, 0, o), this.values = _t.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this;
  },
  clone: function() {
    const t = _t.arraySlice(this.times, 0), e = _t.arraySlice(this.values, 0), n = this.constructor, r = new n(this.name, t, e);
    return r.createInterpolant = this.createInterpolant, r;
  }
});
function kd(t, e, n) {
  Jt.call(this, t, e, n);
}
kd.prototype = Object.assign(Object.create(Jt.prototype), {
  constructor: kd,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: Za,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
});
function Wd(t, e, n, r) {
  Jt.call(this, t, e, n, r);
}
Wd.prototype = Object.assign(Object.create(Jt.prototype), {
  constructor: Wd,
  ValueTypeName: "color"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
});
function Fo(t, e, n, r) {
  Jt.call(this, t, e, n, r);
}
Fo.prototype = Object.assign(Object.create(Jt.prototype), {
  constructor: Fo,
  ValueTypeName: "number"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function $d(t, e, n, r) {
  wn.call(this, t, e, n, r);
}
$d.prototype = Object.assign(Object.create(wn.prototype), {
  constructor: $d,
  interpolate_: function(t, e, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - e) / (r - e);
    let c = t * a;
    for (let h = c + a; c !== h; c += 4)
      bn.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
});
function cl(t, e, n, r) {
  Jt.call(this, t, e, n, r);
}
cl.prototype = Object.assign(Object.create(Jt.prototype), {
  constructor: cl,
  ValueTypeName: "quaternion",
  // ValueBufferType is inherited
  DefaultInterpolation: Fa,
  InterpolantFactoryMethodLinear: function(t) {
    return new $d(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: void 0
  // not yet implemented
});
function jd(t, e, n, r) {
  Jt.call(this, t, e, n, r);
}
jd.prototype = Object.assign(Object.create(Jt.prototype), {
  constructor: jd,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: Za,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function Bo(t, e, n, r) {
  Jt.call(this, t, e, n, r);
}
Bo.prototype = Object.assign(Object.create(Jt.prototype), {
  constructor: Bo,
  ValueTypeName: "vector"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function Pn(t, e = -1, n, r = jf) {
  this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = $e.generateUUID(), this.duration < 0 && this.resetDuration();
}
function p1(t) {
  switch (t.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Fo;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Bo;
    case "color":
      return Wd;
    case "quaternion":
      return cl;
    case "bool":
    case "boolean":
      return kd;
    case "string":
      return jd;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
}
function m1(t) {
  if (t.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = p1(t.type);
  if (t.times === void 0) {
    const n = [], r = [];
    _t.flattenJSON(t.keys, n, r, "value"), t.times = n, t.values = r;
  }
  return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
}
Object.assign(Pn, {
  parse: function(t) {
    const e = [], n = t.tracks, r = 1 / (t.fps || 1);
    for (let o = 0, a = n.length; o !== a; ++o)
      e.push(m1(n[o]).scale(r));
    const s = new Pn(t.name, t.duration, e, t.blendMode);
    return s.uuid = t.uuid, s;
  },
  toJSON: function(t) {
    const e = [], n = t.tracks, r = {
      name: t.name,
      duration: t.duration,
      tracks: e,
      uuid: t.uuid,
      blendMode: t.blendMode
    };
    for (let s = 0, o = n.length; s !== o; ++s)
      e.push(Jt.toJSON(n[s]));
    return r;
  },
  CreateFromMorphTargetSequence: function(t, e, n, r) {
    const s = e.length, o = [];
    for (let a = 0; a < s; a++) {
      let l = [], c = [];
      l.push(
        (a + s - 1) % s,
        a,
        (a + 1) % s
      ), c.push(0, 1, 0);
      const h = _t.getKeyframeOrder(l);
      l = _t.sortedArray(l, 1, h), c = _t.sortedArray(c, 1, h), !r && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(
        new Fo(
          ".morphTargetInfluences[" + e[a].name + "]",
          l,
          c
        ).scale(1 / n)
      );
    }
    return new Pn(t, -1, o);
  },
  findByName: function(t, e) {
    let n = t;
    if (!Array.isArray(t)) {
      const r = t;
      n = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < n.length; r++)
      if (n[r].name === e)
        return n[r];
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(t, e, n) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = t.length; a < l; a++) {
      const c = t[a], h = c.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let u = r[d];
        u || (r[d] = u = []), u.push(c);
      }
    }
    const o = [];
    for (const a in r)
      o.push(Pn.CreateFromMorphTargetSequence(a, r[a], e, n));
    return o;
  },
  // parse the animation.hierarchy format
  parseAnimation: function(t, e) {
    if (!t)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(d, u, p, f, m) {
      if (p.length !== 0) {
        const y = [], x = [];
        _t.flattenJSON(p, y, x, f), y.length !== 0 && m.push(new d(u, y, x));
      }
    }, r = [], s = t.name || "default", o = t.fps || 30, a = t.blendMode;
    let l = t.length || -1;
    const c = t.hierarchy || [];
    for (let d = 0; d < c.length; d++) {
      const u = c[d].keys;
      if (!(!u || u.length === 0))
        if (u[0].morphTargets) {
          const p = {};
          let f;
          for (f = 0; f < u.length; f++)
            if (u[f].morphTargets)
              for (let m = 0; m < u[f].morphTargets.length; m++)
                p[u[f].morphTargets[m]] = -1;
          for (const m in p) {
            const y = [], x = [];
            for (let v = 0; v !== u[f].morphTargets.length; ++v) {
              const g = u[f];
              y.push(g.time), x.push(g.morphTarget === m ? 1 : 0);
            }
            r.push(new Fo(".morphTargetInfluence[" + m + "]", y, x));
          }
          l = p.length * o;
        } else {
          const p = ".bones[" + e[d].name + "]";
          n(
            Bo,
            p + ".position",
            u,
            "pos",
            r
          ), n(
            cl,
            p + ".quaternion",
            u,
            "rot",
            r
          ), n(
            Bo,
            p + ".scale",
            u,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new Pn(s, l, r, a);
  }
});
Object.assign(Pn.prototype, {
  resetDuration: function() {
    const t = this.tracks;
    let e = 0;
    for (let n = 0, r = t.length; n !== r; ++n) {
      const s = this.tracks[n];
      e = Math.max(e, s.times[s.times.length - 1]);
    }
    return this.duration = e, this;
  },
  trim: function() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration);
    return this;
  },
  validate: function() {
    let t = !0;
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate();
    return t;
  },
  optimize: function() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].optimize();
    return this;
  },
  clone: function() {
    const t = [];
    for (let e = 0; e < this.tracks.length; e++)
      t.push(this.tracks[e].clone());
    return new Pn(this.name, this.duration, t, this.blendMode);
  },
  toJSON: function() {
    return Pn.toJSON(this);
  }
});
const zo = {
  enabled: !1,
  files: {},
  add: function(t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function(t) {
    if (this.enabled !== !1)
      return this.files[t];
  },
  remove: function(t) {
    delete this.files[t];
  },
  clear: function() {
    this.files = {};
  }
};
function g1(t, e, n) {
  const r = this;
  let s = !1, o = 0, a = 0, l;
  const c = [];
  this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(h) {
    a++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, a), s = !0;
  }, this.itemEnd = function(h) {
    o++, r.onProgress !== void 0 && r.onProgress(h, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad());
  }, this.itemError = function(h) {
    r.onError !== void 0 && r.onError(h);
  }, this.resolveURL = function(h) {
    return l ? l(h) : h;
  }, this.setURLModifier = function(h) {
    return l = h, this;
  }, this.addHandler = function(h, d) {
    return c.push(h, d), this;
  }, this.removeHandler = function(h) {
    const d = c.indexOf(h);
    return d !== -1 && c.splice(d, 2), this;
  }, this.getHandler = function(h) {
    for (let d = 0, u = c.length; d < u; d += 2) {
      const p = c[d], f = c[d + 1];
      if (p.global && (p.lastIndex = 0), p.test(h))
        return f;
    }
    return null;
  };
}
const v1 = new g1();
function dt(t) {
  this.manager = t !== void 0 ? t : v1, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
}
Object.assign(dt.prototype, {
  load: function() {
  },
  loadAsync: function(t, e) {
    const n = this;
    return new Promise(function(r, s) {
      n.load(t, r, e, s);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(t) {
    return this.crossOrigin = t, this;
  },
  setWithCredentials: function(t) {
    return this.withCredentials = t, this;
  },
  setPath: function(t) {
    return this.path = t, this;
  },
  setResourcePath: function(t) {
    return this.resourcePath = t, this;
  },
  setRequestHeader: function(t) {
    return this.requestHeader = t, this;
  }
});
const Yn = {};
function Si(t) {
  dt.call(this, t);
}
Si.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Si,
  load: function(t, e, n, r) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const s = this, o = zo.get(t);
    if (o !== void 0)
      return s.manager.itemStart(t), setTimeout(function() {
        e && e(o), s.manager.itemEnd(t);
      }, 0), o;
    if (Yn[t] !== void 0) {
      Yn[t].push({
        onLoad: e,
        onProgress: n,
        onError: r
      });
      return;
    }
    const a = /^data:(.*?)(;base64)?,(.*)$/, l = t.match(a);
    let c;
    if (l) {
      const h = l[1], d = !!l[2];
      let u = l[3];
      u = decodeURIComponent(u), d && (u = atob(u));
      try {
        let p;
        const f = (this.responseType || "").toLowerCase();
        switch (f) {
          case "arraybuffer":
          case "blob":
            const m = new Uint8Array(u.length);
            for (let x = 0; x < u.length; x++)
              m[x] = u.charCodeAt(x);
            f === "blob" ? p = new Blob([m.buffer], { type: h }) : p = m.buffer;
            break;
          case "document":
            p = new DOMParser().parseFromString(u, h);
            break;
          case "json":
            p = JSON.parse(u);
            break;
          default:
            p = u;
            break;
        }
        setTimeout(function() {
          e && e(p), s.manager.itemEnd(t);
        }, 0);
      } catch (p) {
        setTimeout(function() {
          r && r(p), s.manager.itemError(t), s.manager.itemEnd(t);
        }, 0);
      }
    } else {
      Yn[t] = [], Yn[t].push({
        onLoad: e,
        onProgress: n,
        onError: r
      }), c = new XMLHttpRequest(), c.open("GET", t, !0), c.addEventListener("load", function(h) {
        const d = this.response, u = Yn[t];
        if (delete Yn[t], this.status === 200 || this.status === 0) {
          this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), zo.add(t, d);
          for (let p = 0, f = u.length; p < f; p++) {
            const m = u[p];
            m.onLoad && m.onLoad(d);
          }
          s.manager.itemEnd(t);
        } else {
          for (let p = 0, f = u.length; p < f; p++) {
            const m = u[p];
            m.onError && m.onError(h);
          }
          s.manager.itemError(t), s.manager.itemEnd(t);
        }
      }, !1), c.addEventListener("progress", function(h) {
        const d = Yn[t];
        for (let u = 0, p = d.length; u < p; u++) {
          const f = d[u];
          f.onProgress && f.onProgress(h);
        }
      }, !1), c.addEventListener("error", function(h) {
        const d = Yn[t];
        delete Yn[t];
        for (let u = 0, p = d.length; u < p; u++) {
          const f = d[u];
          f.onError && f.onError(h);
        }
        s.manager.itemError(t), s.manager.itemEnd(t);
      }, !1), c.addEventListener("abort", function(h) {
        const d = Yn[t];
        delete Yn[t];
        for (let u = 0, p = d.length; u < p; u++) {
          const f = d[u];
          f.onError && f.onError(h);
        }
        s.manager.itemError(t), s.manager.itemEnd(t);
      }, !1), this.responseType !== void 0 && (c.responseType = this.responseType), this.withCredentials !== void 0 && (c.withCredentials = this.withCredentials), c.overrideMimeType && c.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const h in this.requestHeader)
        c.setRequestHeader(h, this.requestHeader[h]);
      c.send(null);
    }
    return s.manager.itemStart(t), c;
  },
  setResponseType: function(t) {
    return this.responseType = t, this;
  },
  setMimeType: function(t) {
    return this.mimeType = t, this;
  }
});
function Lm(t) {
  dt.call(this, t);
}
Lm.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Lm,
  load: function(t, e, n, r) {
    const s = this, o = new Si(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      try {
        e(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  },
  parse: function(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const r = Pn.parse(t[n]);
      e.push(r);
    }
    return e;
  }
});
function Cm(t) {
  dt.call(this, t);
}
Cm.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Cm,
  load: function(t, e, n, r) {
    const s = this, o = [], a = new il(), l = new Si(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials);
    let c = 0;
    function h(d) {
      l.load(t[d], function(u) {
        const p = s.parse(u, !0);
        o[d] = {
          width: p.width,
          height: p.height,
          format: p.format,
          mipmaps: p.mipmaps
        }, c += 1, c === 6 && (p.mipmapCount === 1 && (a.minFilter = Ht), a.image = o, a.format = p.format, a.needsUpdate = !0, e && e(a));
      }, n, r);
    }
    if (Array.isArray(t))
      for (let d = 0, u = t.length; d < u; ++d)
        h(d);
    else
      l.load(t, function(d) {
        const u = s.parse(d, !0);
        if (u.isCubemap) {
          const p = u.mipmaps.length / u.mipmapCount;
          for (let f = 0; f < p; f++) {
            o[f] = { mipmaps: [] };
            for (let m = 0; m < u.mipmapCount; m++)
              o[f].mipmaps.push(u.mipmaps[f * u.mipmapCount + m]), o[f].format = u.format, o[f].width = u.width, o[f].height = u.height;
          }
          a.image = o;
        } else
          a.image.width = u.width, a.image.height = u.height, a.mipmaps = u.mipmaps;
        u.mipmapCount === 1 && (a.minFilter = Ht), a.format = u.format, a.needsUpdate = !0, e && e(a);
      }, n, r);
    return a;
  }
});
function Sh(t) {
  dt.call(this, t);
}
Sh.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Sh,
  load: function(t, e, n, r) {
    this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const s = this, o = zo.get(t);
    if (o !== void 0)
      return s.manager.itemStart(t), setTimeout(function() {
        e && e(o), s.manager.itemEnd(t);
      }, 0), o;
    const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function l() {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1), zo.add(t, this), e && e(this), s.manager.itemEnd(t);
    }
    function c(h) {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1), r && r(h), s.manager.itemError(t), s.manager.itemEnd(t);
    }
    return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), t.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(t), a.src = t, a;
  }
});
function qd(t) {
  dt.call(this, t);
}
qd.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: qd,
  load: function(t, e, n, r) {
    const s = new Vr(), o = new Sh(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(c) {
      o.load(t[c], function(h) {
        s.images[c] = h, a++, a === 6 && (s.needsUpdate = !0, e && e(s));
      }, void 0, r);
    }
    for (let c = 0; c < t.length; ++c)
      l(c);
    return s;
  }
});
function Rm(t) {
  dt.call(this, t);
}
Rm.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Rm,
  load: function(t, e, n, r) {
    const s = this, o = new Co(), a = new Si(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(t, function(l) {
      const c = s.parse(l);
      c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : an, o.wrapT = c.wrapT !== void 0 ? c.wrapT : an, o.magFilter = c.magFilter !== void 0 ? c.magFilter : Ht, o.minFilter = c.minFilter !== void 0 ? c.minFilter : Ht, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = Il), c.mipmapCount === 1 && (o.minFilter = Ht), o.needsUpdate = !0, e && e(o, c));
    }, n, r), o;
  }
});
function Eh(t) {
  dt.call(this, t);
}
Eh.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Eh,
  load: function(t, e, n, r) {
    const s = new ft(), o = new Sh(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(a) {
      s.image = a;
      const l = t.search(/\.jpe?g($|\?)/i) > 0 || t.search(/^data\:image\/jpeg/) === 0;
      s.format = l ? Dr : ri, s.needsUpdate = !0, e !== void 0 && e(s);
    }, n, r), s;
  }
});
function Oe() {
  this.type = "Curve", this.arcLengthDivisions = 200;
}
Object.assign(Oe.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getPoint(n, e);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPoint(n / t));
    return e;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPointAt(n / t));
    return e;
  },
  // Get total curve arc length
  getLength: function() {
    const t = this.getLengths();
    return t[t.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function(t) {
    if (t === void 0 && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let n, r = this.getPoint(0), s = 0;
    e.push(0);
    for (let o = 1; o <= t; o++)
      n = this.getPoint(o / t), s += n.distanceTo(r), e.push(s), r = n;
    return this.cacheArcLengths = e, e;
  },
  updateArcLengths: function() {
    this.needsUpdate = !0, this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function(t, e) {
    const n = this.getLengths();
    let r = 0;
    const s = n.length;
    let o;
    e ? o = e : o = t * n[s - 1];
    let a = 0, l = s - 1, c;
    for (; a <= l; )
      if (r = Math.floor(a + (l - a) / 2), c = n[r] - o, c < 0)
        a = r + 1;
      else if (c > 0)
        l = r - 1;
      else {
        l = r;
        break;
      }
    if (r = l, n[r] === o)
      return r / (s - 1);
    const h = n[r], u = n[r + 1] - h, p = (o - h) / u;
    return (r + p) / (s - 1);
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function(t, e) {
    let r = t - 1e-4, s = t + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r), a = this.getPoint(s), l = e || (o.isVector2 ? new ye() : new z());
    return l.copy(a).sub(o).normalize(), l;
  },
  getTangentAt: function(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getTangent(n, e);
  },
  computeFrenetFrames: function(t, e) {
    const n = new z(), r = [], s = [], o = [], a = new z(), l = new Je();
    for (let p = 0; p <= t; p++) {
      const f = p / t;
      r[p] = this.getTangentAt(f, new z()), r[p].normalize();
    }
    s[0] = new z(), o[0] = new z();
    let c = Number.MAX_VALUE;
    const h = Math.abs(r[0].x), d = Math.abs(r[0].y), u = Math.abs(r[0].z);
    h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), u <= c && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]);
    for (let p = 1; p <= t; p++) {
      if (s[p] = s[p - 1].clone(), o[p] = o[p - 1].clone(), a.crossVectors(r[p - 1], r[p]), a.length() > Number.EPSILON) {
        a.normalize();
        const f = Math.acos($e.clamp(r[p - 1].dot(r[p]), -1, 1));
        s[p].applyMatrix4(l.makeRotationAxis(a, f));
      }
      o[p].crossVectors(r[p], s[p]);
    }
    if (e === !0) {
      let p = Math.acos($e.clamp(s[0].dot(s[t]), -1, 1));
      p /= t, r[0].dot(a.crossVectors(s[0], s[t])) > 0 && (p = -p);
      for (let f = 1; f <= t; f++)
        s[f].applyMatrix4(l.makeRotationAxis(r[f], p * f)), o[f].crossVectors(r[f], s[f]);
    }
    return {
      tangents: r,
      normals: s,
      binormals: o
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
  },
  fromJSON: function(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
});
function zn(t, e, n, r, s, o, a, l) {
  Oe.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = s || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = l || 0;
}
zn.prototype = Object.create(Oe.prototype);
zn.prototype.constructor = zn;
zn.prototype.isEllipseCurve = !0;
zn.prototype.getPoint = function(t, e) {
  const n = e || new ye(), r = Math.PI * 2;
  let s = this.aEndAngle - this.aStartAngle;
  const o = Math.abs(s) < Number.EPSILON;
  for (; s < 0; ) s += r;
  for (; s > r; ) s -= r;
  s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
  const a = this.aStartAngle + t * s;
  let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
  if (this.aRotation !== 0) {
    const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), u = l - this.aX, p = c - this.aY;
    l = u * h - p * d + this.aX, c = u * d + p * h + this.aY;
  }
  return n.set(l, c);
};
zn.prototype.copy = function(t) {
  return Oe.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
};
zn.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
};
zn.prototype.fromJSON = function(t) {
  return Oe.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
};
function hl(t, e, n, r, s, o) {
  zn.call(this, t, e, n, n, r, s, o), this.type = "ArcCurve";
}
hl.prototype = Object.create(zn.prototype);
hl.prototype.constructor = hl;
hl.prototype.isArcCurve = !0;
function Jf() {
  let t = 0, e = 0, n = 0, r = 0;
  function s(o, a, l, c) {
    t = o, e = l, n = -3 * o + 3 * a - 2 * l - c, r = 2 * o - 2 * a + l + c;
  }
  return {
    initCatmullRom: function(o, a, l, c, h) {
      s(a, l, h * (l - o), h * (c - a));
    },
    initNonuniformCatmullRom: function(o, a, l, c, h, d, u) {
      let p = (a - o) / h - (l - o) / (h + d) + (l - a) / d, f = (l - a) / d - (c - a) / (d + u) + (c - l) / u;
      p *= d, f *= d, s(a, l, p, f);
    },
    calc: function(o) {
      const a = o * o, l = a * o;
      return t + e * o + n * a + r * l;
    }
  };
}
const mc = new z(), Uu = new Jf(), Hu = new Jf(), Gu = new Jf();
function En(t = [], e = !1, n = "centripetal", r = 0.5) {
  Oe.call(this), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r;
}
En.prototype = Object.create(Oe.prototype);
En.prototype.constructor = En;
En.prototype.isCatmullRomCurve3 = !0;
En.prototype.getPoint = function(t, e = new z()) {
  const n = e, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * t;
  let a = Math.floor(o), l = o - a;
  this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
  let c, h;
  this.closed || a > 0 ? c = r[(a - 1) % s] : (mc.subVectors(r[0], r[1]).add(r[0]), c = mc);
  const d = r[a % s], u = r[(a + 1) % s];
  if (this.closed || a + 2 < s ? h = r[(a + 2) % s] : (mc.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), h = mc), this.curveType === "centripetal" || this.curveType === "chordal") {
    const p = this.curveType === "chordal" ? 0.5 : 0.25;
    let f = Math.pow(c.distanceToSquared(d), p), m = Math.pow(d.distanceToSquared(u), p), y = Math.pow(u.distanceToSquared(h), p);
    m < 1e-4 && (m = 1), f < 1e-4 && (f = m), y < 1e-4 && (y = m), Uu.initNonuniformCatmullRom(c.x, d.x, u.x, h.x, f, m, y), Hu.initNonuniformCatmullRom(c.y, d.y, u.y, h.y, f, m, y), Gu.initNonuniformCatmullRom(c.z, d.z, u.z, h.z, f, m, y);
  } else this.curveType === "catmullrom" && (Uu.initCatmullRom(c.x, d.x, u.x, h.x, this.tension), Hu.initCatmullRom(c.y, d.y, u.y, h.y, this.tension), Gu.initCatmullRom(c.z, d.z, u.z, h.z, this.tension));
  return n.set(
    Uu.calc(l),
    Hu.calc(l),
    Gu.calc(l)
  ), n;
};
En.prototype.copy = function(t) {
  Oe.prototype.copy.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const r = t.points[e];
    this.points.push(r.clone());
  }
  return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
};
En.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  t.points = [];
  for (let e = 0, n = this.points.length; e < n; e++) {
    const r = this.points[e];
    t.points.push(r.toArray());
  }
  return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
};
En.prototype.fromJSON = function(t) {
  Oe.prototype.fromJSON.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const r = t.points[e];
    this.points.push(new z().fromArray(r));
  }
  return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
};
function Pm(t, e, n, r, s) {
  const o = (r - e) * 0.5, a = (s - n) * 0.5, l = t * t, c = t * l;
  return (2 * n - 2 * r + o + a) * c + (-3 * n + 3 * r - 2 * o - a) * l + o * t + n;
}
function y1(t, e) {
  const n = 1 - t;
  return n * n * e;
}
function x1(t, e) {
  return 2 * (1 - t) * t * e;
}
function _1(t, e) {
  return t * t * e;
}
function Ua(t, e, n, r) {
  return y1(t, e) + x1(t, n) + _1(t, r);
}
function b1(t, e) {
  const n = 1 - t;
  return n * n * n * e;
}
function w1(t, e) {
  const n = 1 - t;
  return 3 * n * n * t * e;
}
function M1(t, e) {
  return 3 * (1 - t) * t * t * e;
}
function S1(t, e) {
  return t * t * t * e;
}
function Ha(t, e, n, r, s) {
  return b1(t, e) + w1(t, n) + M1(t, r) + S1(t, s);
}
function Ei(t = new ye(), e = new ye(), n = new ye(), r = new ye()) {
  Oe.call(this), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r;
}
Ei.prototype = Object.create(Oe.prototype);
Ei.prototype.constructor = Ei;
Ei.prototype.isCubicBezierCurve = !0;
Ei.prototype.getPoint = function(t, e = new ye()) {
  const n = e, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
  return n.set(
    Ha(t, r.x, s.x, o.x, a.x),
    Ha(t, r.y, s.y, o.y, a.y)
  ), n;
};
Ei.prototype.copy = function(t) {
  return Oe.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
};
Ei.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
};
Ei.prototype.fromJSON = function(t) {
  return Oe.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
};
function Ji(t = new z(), e = new z(), n = new z(), r = new z()) {
  Oe.call(this), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r;
}
Ji.prototype = Object.create(Oe.prototype);
Ji.prototype.constructor = Ji;
Ji.prototype.isCubicBezierCurve3 = !0;
Ji.prototype.getPoint = function(t, e = new z()) {
  const n = e, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
  return n.set(
    Ha(t, r.x, s.x, o.x, a.x),
    Ha(t, r.y, s.y, o.y, a.y),
    Ha(t, r.z, s.z, o.z, a.z)
  ), n;
};
Ji.prototype.copy = function(t) {
  return Oe.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
};
Ji.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
};
Ji.prototype.fromJSON = function(t) {
  return Oe.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
};
function Tn(t = new ye(), e = new ye()) {
  Oe.call(this), this.type = "LineCurve", this.v1 = t, this.v2 = e;
}
Tn.prototype = Object.create(Oe.prototype);
Tn.prototype.constructor = Tn;
Tn.prototype.isLineCurve = !0;
Tn.prototype.getPoint = function(t, e = new ye()) {
  const n = e;
  return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
};
Tn.prototype.getPointAt = function(t, e) {
  return this.getPoint(t, e);
};
Tn.prototype.getTangent = function(t, e) {
  const n = e || new ye();
  return n.copy(this.v2).sub(this.v1).normalize(), n;
};
Tn.prototype.copy = function(t) {
  return Oe.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Tn.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Tn.prototype.fromJSON = function(t) {
  return Oe.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Ti(t = new z(), e = new z()) {
  Oe.call(this), this.type = "LineCurve3", this.v1 = t, this.v2 = e;
}
Ti.prototype = Object.create(Oe.prototype);
Ti.prototype.constructor = Ti;
Ti.prototype.isLineCurve3 = !0;
Ti.prototype.getPoint = function(t, e = new z()) {
  const n = e;
  return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
};
Ti.prototype.getPointAt = function(t, e) {
  return this.getPoint(t, e);
};
Ti.prototype.copy = function(t) {
  return Oe.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Ti.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Ti.prototype.fromJSON = function(t) {
  return Oe.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Ai(t = new ye(), e = new ye(), n = new ye()) {
  Oe.call(this), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n;
}
Ai.prototype = Object.create(Oe.prototype);
Ai.prototype.constructor = Ai;
Ai.prototype.isQuadraticBezierCurve = !0;
Ai.prototype.getPoint = function(t, e = new ye()) {
  const n = e, r = this.v0, s = this.v1, o = this.v2;
  return n.set(
    Ua(t, r.x, s.x, o.x),
    Ua(t, r.y, s.y, o.y)
  ), n;
};
Ai.prototype.copy = function(t) {
  return Oe.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Ai.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Ai.prototype.fromJSON = function(t) {
  return Oe.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Ki(t = new z(), e = new z(), n = new z()) {
  Oe.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n;
}
Ki.prototype = Object.create(Oe.prototype);
Ki.prototype.constructor = Ki;
Ki.prototype.isQuadraticBezierCurve3 = !0;
Ki.prototype.getPoint = function(t, e = new z()) {
  const n = e, r = this.v0, s = this.v1, o = this.v2;
  return n.set(
    Ua(t, r.x, s.x, o.x),
    Ua(t, r.y, s.y, o.y),
    Ua(t, r.z, s.z, o.z)
  ), n;
};
Ki.prototype.copy = function(t) {
  return Oe.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Ki.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Ki.prototype.fromJSON = function(t) {
  return Oe.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Li(t = []) {
  Oe.call(this), this.type = "SplineCurve", this.points = t;
}
Li.prototype = Object.create(Oe.prototype);
Li.prototype.constructor = Li;
Li.prototype.isSplineCurve = !0;
Li.prototype.getPoint = function(t, e = new ye()) {
  const n = e, r = this.points, s = (r.length - 1) * t, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], c = r[o], h = r[o > r.length - 2 ? r.length - 1 : o + 1], d = r[o > r.length - 3 ? r.length - 1 : o + 2];
  return n.set(
    Pm(a, l.x, c.x, h.x, d.x),
    Pm(a, l.y, c.y, h.y, d.y)
  ), n;
};
Li.prototype.copy = function(t) {
  Oe.prototype.copy.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const r = t.points[e];
    this.points.push(r.clone());
  }
  return this;
};
Li.prototype.toJSON = function() {
  const t = Oe.prototype.toJSON.call(this);
  t.points = [];
  for (let e = 0, n = this.points.length; e < n; e++) {
    const r = this.points[e];
    t.points.push(r.toArray());
  }
  return t;
};
Li.prototype.fromJSON = function(t) {
  Oe.prototype.fromJSON.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const r = t.points[e];
    this.points.push(new ye().fromArray(r));
  }
  return this;
};
var E1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: hl,
  CatmullRomCurve3: En,
  CubicBezierCurve: Ei,
  CubicBezierCurve3: Ji,
  EllipseCurve: zn,
  LineCurve: Tn,
  LineCurve3: Ti,
  QuadraticBezierCurve: Ai,
  QuadraticBezierCurve3: Ki,
  SplineCurve: Li
});
function Pr() {
  Oe.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
}
Pr.prototype = Object.assign(Object.create(Oe.prototype), {
  constructor: Pr,
  add: function(t) {
    this.curves.push(t);
  },
  closePath: function() {
    const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new Tn(e, t));
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function(t) {
    const e = t * this.getLength(), n = this.getCurveLengths();
    let r = 0;
    for (; r < n.length; ) {
      if (n[r] >= e) {
        const s = n[r] - e, o = this.curves[r], a = o.getLength(), l = a === 0 ? 0 : 1 - s / a;
        return o.getPointAt(l);
      }
      r++;
    }
    return null;
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      e += this.curves[n].getLength(), t.push(e);
    return this.cacheLengths = t, t;
  },
  getSpacedPoints: function(t = 40) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPoint(n / t));
    return this.autoClose && e.push(e[0]), e;
  },
  getPoints: function(t = 12) {
    const e = [];
    let n;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r], a = o && o.isEllipseCurve ? t * 2 : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        n && n.equals(h) || (e.push(h), n = h);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  },
  copy: function(t) {
    Oe.prototype.copy.call(this, t), this.curves = [];
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const r = t.curves[e];
      this.curves.push(r.clone());
    }
    return this.autoClose = t.autoClose, this;
  },
  toJSON: function() {
    const t = Oe.prototype.toJSON.call(this);
    t.autoClose = this.autoClose, t.curves = [];
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const r = this.curves[e];
      t.curves.push(r.toJSON());
    }
    return t;
  },
  fromJSON: function(t) {
    Oe.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const r = t.curves[e];
      this.curves.push(new E1[r.type]().fromJSON(r));
    }
    return this;
  }
});
function yi(t) {
  Pr.call(this), this.type = "Path", this.currentPoint = new ye(), t && this.setFromPoints(t);
}
yi.prototype = Object.assign(Object.create(Pr.prototype), {
  constructor: yi,
  setFromPoints: function(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, n = t.length; e < n; e++)
      this.lineTo(t[e].x, t[e].y);
    return this;
  },
  moveTo: function(t, e) {
    return this.currentPoint.set(t, e), this;
  },
  lineTo: function(t, e) {
    const n = new Tn(this.currentPoint.clone(), new ye(t, e));
    return this.curves.push(n), this.currentPoint.set(t, e), this;
  },
  quadraticCurveTo: function(t, e, n, r) {
    const s = new Ai(
      this.currentPoint.clone(),
      new ye(t, e),
      new ye(n, r)
    );
    return this.curves.push(s), this.currentPoint.set(n, r), this;
  },
  bezierCurveTo: function(t, e, n, r, s, o) {
    const a = new Ei(
      this.currentPoint.clone(),
      new ye(t, e),
      new ye(n, r),
      new ye(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  },
  splineThru: function(t) {
    const e = [this.currentPoint.clone()].concat(t), n = new Li(e);
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
  },
  arc: function(t, e, n, r, s, o) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      t + a,
      e + l,
      n,
      r,
      s,
      o
    ), this;
  },
  absarc: function(t, e, n, r, s, o) {
    return this.absellipse(t, e, n, n, r, s, o), this;
  },
  ellipse: function(t, e, n, r, s, o, a, l) {
    const c = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(t + c, e + h, n, r, s, o, a, l), this;
  },
  absellipse: function(t, e, n, r, s, o, a, l) {
    const c = new zn(t, e, n, r, s, o, a, l);
    if (this.curves.length > 0) {
      const d = c.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  },
  copy: function(t) {
    return Pr.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
  },
  toJSON: function() {
    const t = Pr.prototype.toJSON.call(this);
    return t.currentPoint = this.currentPoint.toArray(), t;
  },
  fromJSON: function(t) {
    return Pr.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
  }
});
function So(t) {
  yi.call(this, t), this.uuid = $e.generateUUID(), this.type = "Shape", this.holes = [];
}
So.prototype = Object.assign(Object.create(yi.prototype), {
  constructor: So,
  getPointsHoles: function(t) {
    const e = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      e[n] = this.holes[n].getPoints(t);
    return e;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function(t) {
    return {
      shape: this.getPoints(t),
      holes: this.getPointsHoles(t)
    };
  },
  copy: function(t) {
    yi.prototype.copy.call(this, t), this.holes = [];
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const r = t.holes[e];
      this.holes.push(r.clone());
    }
    return this;
  },
  toJSON: function() {
    const t = yi.prototype.toJSON.call(this);
    t.uuid = this.uuid, t.holes = [];
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const r = this.holes[e];
      t.holes.push(r.toJSON());
    }
    return t;
  },
  fromJSON: function(t) {
    yi.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const r = t.holes[e];
      this.holes.push(new yi().fromJSON(r));
    }
    return this;
  }
});
function yt(t, e = 1) {
  He.call(this), this.type = "Light", this.color = new Ne(t), this.intensity = e;
}
yt.prototype = Object.assign(Object.create(He.prototype), {
  constructor: yt,
  isLight: !0,
  copy: function(t) {
    return He.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
  },
  toJSON: function(t) {
    const e = He.prototype.toJSON.call(this, t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
  }
});
function Im(t, e, n) {
  yt.call(this, t, n), this.type = "HemisphereLight", this.position.copy(He.DefaultUp), this.updateMatrix(), this.groundColor = new Ne(e);
}
Im.prototype = Object.assign(Object.create(yt.prototype), {
  constructor: Im,
  isHemisphereLight: !0,
  copy: function(t) {
    return yt.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
  }
});
function Qi(t) {
  this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new ye(512, 512), this.map = null, this.mapPass = null, this.matrix = new Je(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Kh(), this._frameExtents = new ye(1, 1), this._viewportCount = 1, this._viewports = [
    new ht(0, 0, 1, 1)
  ];
}
Object.assign(Qi.prototype, {
  _projScreenMatrix: new Je(),
  _lightPositionWorld: new z(),
  _lookTarget: new z(),
  getViewportCount: function() {
    return this._viewportCount;
  },
  getFrustum: function() {
    return this._frustum;
  },
  updateMatrices: function(t) {
    const e = this.camera, n = this.matrix, r = this._projScreenMatrix, s = this._lookTarget, o = this._lightPositionWorld;
    o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), s.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(s), e.updateMatrixWorld(), r.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse);
  },
  getViewport: function(t) {
    return this._viewports[t];
  },
  getFrameExtents: function() {
    return this._frameExtents;
  },
  copy: function(t) {
    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const t = {};
    return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
  }
});
function Xd() {
  Qi.call(this, new Nt(50, 1, 0.5, 500)), this.focus = 1;
}
Xd.prototype = Object.assign(Object.create(Qi.prototype), {
  constructor: Xd,
  isSpotLightShadow: !0,
  updateMatrices: function(t) {
    const e = this.camera, n = $e.RAD2DEG * 2 * t.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = t.distance || e.far;
    (n !== e.fov || r !== e.aspect || s !== e.far) && (e.fov = n, e.aspect = r, e.far = s, e.updateProjectionMatrix()), Qi.prototype.updateMatrices.call(this, t);
  }
});
function Yd(t, e, n, r, s, o) {
  yt.call(this, t, e), this.type = "SpotLight", this.position.copy(He.DefaultUp), this.updateMatrix(), this.target = new He(), Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(a) {
      this.intensity = a / Math.PI;
    }
  }), this.distance = n !== void 0 ? n : 0, this.angle = r !== void 0 ? r : Math.PI / 3, this.penumbra = s !== void 0 ? s : 0, this.decay = o !== void 0 ? o : 1, this.shadow = new Xd();
}
Yd.prototype = Object.assign(Object.create(yt.prototype), {
  constructor: Yd,
  isSpotLight: !0,
  copy: function(t) {
    return yt.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
});
function Zd() {
  Qi.call(this, new Nt(90, 1, 0.5, 500)), this._frameExtents = new ye(4, 2), this._viewportCount = 6, this._viewports = [
    // These viewports map a cube-map onto a 2D texture with the
    // following orientation:
    //
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction
    // positive X
    new ht(2, 1, 1, 1),
    // negative X
    new ht(0, 1, 1, 1),
    // positive Z
    new ht(3, 1, 1, 1),
    // negative Z
    new ht(1, 1, 1, 1),
    // positive Y
    new ht(3, 0, 1, 1),
    // negative Y
    new ht(1, 0, 1, 1)
  ], this._cubeDirections = [
    new z(1, 0, 0),
    new z(-1, 0, 0),
    new z(0, 0, 1),
    new z(0, 0, -1),
    new z(0, 1, 0),
    new z(0, -1, 0)
  ], this._cubeUps = [
    new z(0, 1, 0),
    new z(0, 1, 0),
    new z(0, 1, 0),
    new z(0, 1, 0),
    new z(0, 0, 1),
    new z(0, 0, -1)
  ];
}
Zd.prototype = Object.assign(Object.create(Qi.prototype), {
  constructor: Zd,
  isPointLightShadow: !0,
  updateMatrices: function(t, e = 0) {
    const n = this.camera, r = this.matrix, s = this._lightPositionWorld, o = this._lookTarget, a = this._projScreenMatrix;
    s.setFromMatrixPosition(t.matrixWorld), n.position.copy(s), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), r.makeTranslation(-s.x, -s.y, -s.z), a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(a);
  }
});
function Jd(t, e, n, r) {
  yt.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(s) {
      this.intensity = s / (4 * Math.PI);
    }
  }), this.distance = n !== void 0 ? n : 0, this.decay = r !== void 0 ? r : 1, this.shadow = new Zd();
}
Jd.prototype = Object.assign(Object.create(yt.prototype), {
  constructor: Jd,
  isPointLight: !0,
  copy: function(t) {
    return yt.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
  }
});
function Th(t = -1, e = 1, n = 1, r = -1, s = 0.1, o = 2e3) {
  Gr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix();
}
Th.prototype = Object.assign(Object.create(Gr.prototype), {
  constructor: Th,
  isOrthographicCamera: !0,
  copy: function(t, e) {
    return Gr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  },
  setViewOffset: function(t, e, n, r, s, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = n - t, o = n + t, a = r + e, l = r - e;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += c * this.view.offsetX, o = s + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(t) {
    const e = He.prototype.toJSON.call(this, t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
});
function Kd() {
  Qi.call(this, new Th(-5, 5, 5, -5, 0.5, 500));
}
Kd.prototype = Object.assign(Object.create(Qi.prototype), {
  constructor: Kd,
  isDirectionalLightShadow: !0,
  updateMatrices: function(t) {
    Qi.prototype.updateMatrices.call(this, t);
  }
});
function Qd(t, e) {
  yt.call(this, t, e), this.type = "DirectionalLight", this.position.copy(He.DefaultUp), this.updateMatrix(), this.target = new He(), this.shadow = new Kd();
}
Qd.prototype = Object.assign(Object.create(yt.prototype), {
  constructor: Qd,
  isDirectionalLight: !0,
  copy: function(t) {
    return yt.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
});
function Dm(t, e) {
  yt.call(this, t, e), this.type = "AmbientLight";
}
Dm.prototype = Object.assign(Object.create(yt.prototype), {
  constructor: Dm,
  isAmbientLight: !0
});
function Nm(t, e, n, r) {
  yt.call(this, t, e), this.type = "RectAreaLight", this.width = n !== void 0 ? n : 10, this.height = r !== void 0 ? r : 10;
}
Nm.prototype = Object.assign(Object.create(yt.prototype), {
  constructor: Nm,
  isRectAreaLight: !0,
  copy: function(t) {
    return yt.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
  },
  toJSON: function(t) {
    const e = yt.prototype.toJSON.call(this, t);
    return e.object.width = this.width, e.object.height = this.height, e;
  }
});
let T1 = class {
  constructor() {
    Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }), this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new z());
  }
  set(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].copy(e[n]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, n) {
    const r = e.x, s = e.y, o = e.z, a = this.coefficients;
    return n.copy(a[0]).multiplyScalar(0.282095), n.addScaledVector(a[1], 0.488603 * s), n.addScaledVector(a[2], 0.488603 * o), n.addScaledVector(a[3], 0.488603 * r), n.addScaledVector(a[4], 1.092548 * (r * s)), n.addScaledVector(a[5], 1.092548 * (s * o)), n.addScaledVector(a[6], 0.315392 * (3 * o * o - 1)), n.addScaledVector(a[7], 1.092548 * (r * o)), n.addScaledVector(a[8], 0.546274 * (r * r - s * s)), n;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, n) {
    const r = e.x, s = e.y, o = e.z, a = this.coefficients;
    return n.copy(a[0]).multiplyScalar(0.886227), n.addScaledVector(a[1], 2 * 0.511664 * s), n.addScaledVector(a[2], 2 * 0.511664 * o), n.addScaledVector(a[3], 2 * 0.511664 * r), n.addScaledVector(a[4], 2 * 0.429043 * r * s), n.addScaledVector(a[5], 2 * 0.429043 * s * o), n.addScaledVector(a[6], 0.743125 * o * o - 0.247708), n.addScaledVector(a[7], 2 * 0.429043 * r * o), n.addScaledVector(a[8], 0.429043 * (r * r - s * s)), n;
  }
  add(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].add(e.coefficients[n]);
    return this;
  }
  addScaledSH(e, n) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], n);
    return this;
  }
  scale(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].multiplyScalar(e);
    return this;
  }
  lerp(e, n) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].lerp(e.coefficients[r], n);
    return this;
  }
  equals(e) {
    for (let n = 0; n < 9; n++)
      if (!this.coefficients[n].equals(e.coefficients[n]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, n = 0) {
    const r = this.coefficients;
    for (let s = 0; s < 9; s++)
      r[s].fromArray(e, n + s * 3);
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.coefficients;
    for (let s = 0; s < 9; s++)
      r[s].toArray(e, n + s * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, n) {
    const r = e.x, s = e.y, o = e.z;
    n[0] = 0.282095, n[1] = 0.488603 * s, n[2] = 0.488603 * o, n[3] = 0.488603 * r, n[4] = 1.092548 * r * s, n[5] = 1.092548 * s * o, n[6] = 0.315392 * (3 * o * o - 1), n[7] = 1.092548 * r * o, n[8] = 0.546274 * (r * r - s * s);
  }
};
function _i(t, e) {
  yt.call(this, void 0, e), this.type = "LightProbe", this.sh = t !== void 0 ? t : new T1();
}
_i.prototype = Object.assign(Object.create(yt.prototype), {
  constructor: _i,
  isLightProbe: !0,
  copy: function(t) {
    return yt.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
  },
  fromJSON: function(t) {
    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
  },
  toJSON: function(t) {
    const e = yt.prototype.toJSON.call(this, t);
    return e.object.sh = this.sh.toArray(), e;
  }
});
function Om(t) {
  dt.call(this, t), this.textures = {};
}
Om.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Om,
  load: function(t, e, n, r) {
    const s = this, o = new Si(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      try {
        e(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  },
  parse: function(t) {
    const e = this.textures;
    function n(s) {
      return e[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), e[s];
    }
    const r = new f1[t.type]();
    if (t.uuid !== void 0 && (r.uuid = t.uuid), t.name !== void 0 && (r.name = t.name), t.color !== void 0 && r.color !== void 0 && r.color.setHex(t.color), t.roughness !== void 0 && (r.roughness = t.roughness), t.metalness !== void 0 && (r.metalness = t.metalness), t.sheen !== void 0 && (r.sheen = new Ne().setHex(t.sheen)), t.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(t.emissive), t.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(t.specular), t.shininess !== void 0 && (r.shininess = t.shininess), t.clearcoat !== void 0 && (r.clearcoat = t.clearcoat), t.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = t.clearcoatRoughness), t.fog !== void 0 && (r.fog = t.fog), t.flatShading !== void 0 && (r.flatShading = t.flatShading), t.blending !== void 0 && (r.blending = t.blending), t.combine !== void 0 && (r.combine = t.combine), t.side !== void 0 && (r.side = t.side), t.opacity !== void 0 && (r.opacity = t.opacity), t.transparent !== void 0 && (r.transparent = t.transparent), t.alphaTest !== void 0 && (r.alphaTest = t.alphaTest), t.depthTest !== void 0 && (r.depthTest = t.depthTest), t.depthWrite !== void 0 && (r.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (r.colorWrite = t.colorWrite), t.stencilWrite !== void 0 && (r.stencilWrite = t.stencilWrite), t.stencilWriteMask !== void 0 && (r.stencilWriteMask = t.stencilWriteMask), t.stencilFunc !== void 0 && (r.stencilFunc = t.stencilFunc), t.stencilRef !== void 0 && (r.stencilRef = t.stencilRef), t.stencilFuncMask !== void 0 && (r.stencilFuncMask = t.stencilFuncMask), t.stencilFail !== void 0 && (r.stencilFail = t.stencilFail), t.stencilZFail !== void 0 && (r.stencilZFail = t.stencilZFail), t.stencilZPass !== void 0 && (r.stencilZPass = t.stencilZPass), t.wireframe !== void 0 && (r.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (r.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (r.rotation = t.rotation), t.linewidth !== 1 && (r.linewidth = t.linewidth), t.dashSize !== void 0 && (r.dashSize = t.dashSize), t.gapSize !== void 0 && (r.gapSize = t.gapSize), t.scale !== void 0 && (r.scale = t.scale), t.polygonOffset !== void 0 && (r.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = t.polygonOffsetUnits), t.skinning !== void 0 && (r.skinning = t.skinning), t.morphTargets !== void 0 && (r.morphTargets = t.morphTargets), t.morphNormals !== void 0 && (r.morphNormals = t.morphNormals), t.dithering !== void 0 && (r.dithering = t.dithering), t.vertexTangents !== void 0 && (r.vertexTangents = t.vertexTangents), t.visible !== void 0 && (r.visible = t.visible), t.toneMapped !== void 0 && (r.toneMapped = t.toneMapped), t.userData !== void 0 && (r.userData = t.userData), t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors), t.uniforms !== void 0)
      for (const s in t.uniforms) {
        const o = t.uniforms[s];
        switch (r.uniforms[s] = {}, o.type) {
          case "t":
            r.uniforms[s].value = n(o.value);
            break;
          case "c":
            r.uniforms[s].value = new Ne().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new ye().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new z().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new ht().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new ln().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new Je().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (t.defines !== void 0 && (r.defines = t.defines), t.vertexShader !== void 0 && (r.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (r.fragmentShader = t.fragmentShader), t.extensions !== void 0)
      for (const s in t.extensions)
        r.extensions[s] = t.extensions[s];
    if (t.shading !== void 0 && (r.flatShading = t.shading === 1), t.size !== void 0 && (r.size = t.size), t.sizeAttenuation !== void 0 && (r.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (r.map = n(t.map)), t.matcap !== void 0 && (r.matcap = n(t.matcap)), t.alphaMap !== void 0 && (r.alphaMap = n(t.alphaMap)), t.bumpMap !== void 0 && (r.bumpMap = n(t.bumpMap)), t.bumpScale !== void 0 && (r.bumpScale = t.bumpScale), t.normalMap !== void 0 && (r.normalMap = n(t.normalMap)), t.normalMapType !== void 0 && (r.normalMapType = t.normalMapType), t.normalScale !== void 0) {
      let s = t.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new ye().fromArray(s);
    }
    return t.displacementMap !== void 0 && (r.displacementMap = n(t.displacementMap)), t.displacementScale !== void 0 && (r.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (r.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (r.roughnessMap = n(t.roughnessMap)), t.metalnessMap !== void 0 && (r.metalnessMap = n(t.metalnessMap)), t.emissiveMap !== void 0 && (r.emissiveMap = n(t.emissiveMap)), t.emissiveIntensity !== void 0 && (r.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (r.specularMap = n(t.specularMap)), t.envMap !== void 0 && (r.envMap = n(t.envMap)), t.envMapIntensity !== void 0 && (r.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (r.reflectivity = t.reflectivity), t.refractionRatio !== void 0 && (r.refractionRatio = t.refractionRatio), t.lightMap !== void 0 && (r.lightMap = n(t.lightMap)), t.lightMapIntensity !== void 0 && (r.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (r.aoMap = n(t.aoMap)), t.aoMapIntensity !== void 0 && (r.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (r.gradientMap = n(t.gradientMap)), t.clearcoatMap !== void 0 && (r.clearcoatMap = n(t.clearcoatMap)), t.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), t.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(t.clearcoatNormalMap)), t.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new ye().fromArray(t.clearcoatNormalScale)), t.transmission !== void 0 && (r.transmission = t.transmission), t.transmissionMap !== void 0 && (r.transmissionMap = n(t.transmissionMap)), r;
  },
  setTextures: function(t) {
    return this.textures = t, this;
  }
});
const Ny = {
  decodeText: function(t) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(t);
    let e = "";
    for (let n = 0, r = t.length; n < r; n++)
      e += String.fromCharCode(t[n]);
    try {
      return decodeURIComponent(escape(e));
    } catch {
      return e;
    }
  },
  extractUrlBase: function(t) {
    const e = t.lastIndexOf("/");
    return e === -1 ? "./" : t.substr(0, e + 1);
  }
};
function ul() {
  it.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
}
ul.prototype = Object.assign(Object.create(it.prototype), {
  constructor: ul,
  isInstancedBufferGeometry: !0,
  copy: function(t) {
    return it.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const t = it.prototype.toJSON.call(this);
    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t;
  }
});
function ef(t, e, n, r) {
  typeof n == "number" && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), We.call(this, t, e, n), this.meshPerAttribute = r || 1;
}
ef.prototype = Object.assign(Object.create(We.prototype), {
  constructor: ef,
  isInstancedBufferAttribute: !0,
  copy: function(t) {
    return We.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
  },
  toJSON: function() {
    const t = We.prototype.toJSON.call(this);
    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
  }
});
function Fm(t) {
  dt.call(this, t);
}
Fm.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Fm,
  load: function(t, e, n, r) {
    const s = this, o = new Si(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      try {
        e(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  },
  parse: function(t) {
    const e = {}, n = {};
    function r(p, f) {
      if (e[f] !== void 0) return e[f];
      const y = p.interleavedBuffers[f], x = s(p, y.buffer), v = Xl(y.type, x), g = new xn(v, y.stride);
      return g.uuid = y.uuid, e[f] = g, g;
    }
    function s(p, f) {
      if (n[f] !== void 0) return n[f];
      const y = p.arrayBuffers[f], x = new Uint32Array(y).buffer;
      return n[f] = x, x;
    }
    const o = t.isInstancedBufferGeometry ? new ul() : new it(), a = t.data.index;
    if (a !== void 0) {
      const p = Xl(a.type, a.array);
      o.setIndex(new We(p, 1));
    }
    const l = t.data.attributes;
    for (const p in l) {
      const f = l[p];
      let m;
      if (f.isInterleavedBufferAttribute) {
        const y = r(t.data, f.data);
        m = new wi(y, f.itemSize, f.offset, f.normalized);
      } else {
        const y = Xl(f.type, f.array), x = f.isInstancedBufferAttribute ? ef : We;
        m = new x(y, f.itemSize, f.normalized);
      }
      f.name !== void 0 && (m.name = f.name), o.setAttribute(p, m);
    }
    const c = t.data.morphAttributes;
    if (c)
      for (const p in c) {
        const f = c[p], m = [];
        for (let y = 0, x = f.length; y < x; y++) {
          const v = f[y];
          let g;
          if (v.isInterleavedBufferAttribute) {
            const S = r(t.data, v.data);
            g = new wi(S, v.itemSize, v.offset, v.normalized);
          } else {
            const S = Xl(v.type, v.array);
            g = new We(S, v.itemSize, v.normalized);
          }
          v.name !== void 0 && (g.name = v.name), m.push(g);
        }
        o.morphAttributes[p] = m;
      }
    t.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = t.data.groups || t.data.drawcalls || t.data.offsets;
    if (d !== void 0)
      for (let p = 0, f = d.length; p !== f; ++p) {
        const m = d[p];
        o.addGroup(m.start, m.count, m.materialIndex);
      }
    const u = t.data.boundingSphere;
    if (u !== void 0) {
      const p = new z();
      u.center !== void 0 && p.fromArray(u.center), o.boundingSphere = new hi(p, u.radius);
    }
    return t.name && (o.name = t.name), t.userData && (o.userData = t.userData), o;
  }
});
function tf(t) {
  typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), dt.call(this, t), this.options = { premultiplyAlpha: "none" };
}
tf.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: tf,
  isImageBitmapLoader: !0,
  setOptions: function(e) {
    return this.options = e, this;
  },
  load: function(t, e, n, r) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const s = this, o = zo.get(t);
    if (o !== void 0)
      return s.manager.itemStart(t), setTimeout(function() {
        e && e(o), s.manager.itemEnd(t);
      }, 0), o;
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", fetch(t, a).then(function(l) {
      return l.blob();
    }).then(function(l) {
      return createImageBitmap(l, s.options);
    }).then(function(l) {
      zo.add(t, l), e && e(l), s.manager.itemEnd(t);
    }).catch(function(l) {
      r && r(l), s.manager.itemError(t), s.manager.itemEnd(t);
    }), s.manager.itemStart(t);
  }
});
function Oy() {
  this.type = "ShapePath", this.color = new Ne(), this.subPaths = [], this.currentPath = null;
}
Object.assign(Oy.prototype, {
  moveTo: function(t, e) {
    return this.currentPath = new yi(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
  },
  lineTo: function(t, e) {
    return this.currentPath.lineTo(t, e), this;
  },
  quadraticCurveTo: function(t, e, n, r) {
    return this.currentPath.quadraticCurveTo(t, e, n, r), this;
  },
  bezierCurveTo: function(t, e, n, r, s, o) {
    return this.currentPath.bezierCurveTo(t, e, n, r, s, o), this;
  },
  splineThru: function(t) {
    return this.currentPath.splineThru(t), this;
  },
  toShapes: function(t, e) {
    function n(v) {
      const g = [];
      for (let S = 0, T = v.length; S < T; S++) {
        const E = v[S], w = new So();
        w.curves = E.curves, g.push(w);
      }
      return g;
    }
    function r(v, g) {
      const S = g.length;
      let T = !1;
      for (let E = S - 1, w = 0; w < S; E = w++) {
        let C = g[E], ee = g[w], Y = ee.x - C.x, le = ee.y - C.y;
        if (Math.abs(le) > Number.EPSILON) {
          if (le < 0 && (C = g[w], Y = -Y, ee = g[E], le = -le), v.y < C.y || v.y > ee.y) continue;
          if (v.y === C.y) {
            if (v.x === C.x) return !0;
          } else {
            const B = le * (v.x - C.x) - Y * (v.y - C.y);
            if (B === 0) return !0;
            if (B < 0) continue;
            T = !T;
          }
        } else {
          if (v.y !== C.y) continue;
          if (ee.x <= v.x && v.x <= C.x || C.x <= v.x && v.x <= ee.x) return !0;
        }
      }
      return T;
    }
    const s = Or.isClockWise, o = this.subPaths;
    if (o.length === 0) return [];
    if (e === !0) return n(o);
    let a, l, c;
    const h = [];
    if (o.length === 1)
      return l = o[0], c = new So(), c.curves = l.curves, h.push(c), h;
    let d = !s(o[0].getPoints());
    d = t ? !d : d;
    const u = [], p = [];
    let f = [], m = 0, y;
    p[m] = void 0, f[m] = [];
    for (let v = 0, g = o.length; v < g; v++)
      l = o[v], y = l.getPoints(), a = s(y), a = t ? !a : a, a ? (!d && p[m] && m++, p[m] = { s: new So(), p: y }, p[m].s.curves = l.curves, d && m++, f[m] = []) : f[m].push({ h: l, p: y[0] });
    if (!p[0]) return n(o);
    if (p.length > 1) {
      let v = !1;
      const g = [];
      for (let S = 0, T = p.length; S < T; S++)
        u[S] = [];
      for (let S = 0, T = p.length; S < T; S++) {
        const E = f[S];
        for (let w = 0; w < E.length; w++) {
          const C = E[w];
          let ee = !0;
          for (let Y = 0; Y < p.length; Y++)
            r(C.p, p[Y].p) && (S !== Y && g.push({ froms: S, tos: Y, hole: w }), ee ? (ee = !1, u[Y].push(C)) : v = !0);
          ee && u[S].push(C);
        }
      }
      g.length > 0 && (v || (f = u));
    }
    let x;
    for (let v = 0, g = p.length; v < g; v++) {
      c = p[v].s, h.push(c), x = f[v];
      for (let S = 0, T = x.length; S < T; S++)
        c.holes.push(x[S].h);
    }
    return h;
  }
});
function Fy(t) {
  this.type = "Font", this.data = t;
}
Object.assign(Fy.prototype, {
  isFont: !0,
  generateShapes: function(t, e = 100) {
    const n = [], r = A1(t, e, this.data);
    for (let s = 0, o = r.length; s < o; s++)
      Array.prototype.push.apply(n, r[s].toShapes());
    return n;
  }
});
function A1(t, e, n) {
  const r = Array.from ? Array.from(t) : String(t).split(""), s = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * s, a = [];
  let l = 0, c = 0;
  for (let h = 0; h < r.length; h++) {
    const d = r[h];
    if (d === `
`)
      l = 0, c -= o;
    else {
      const u = L1(d, s, l, c, n);
      l += u.offsetX, a.push(u.path);
    }
  }
  return a;
}
function L1(t, e, n, r, s) {
  const o = s.glyphs[t] || s.glyphs["?"];
  if (!o) {
    console.error('THREE.Font: character "' + t + '" does not exists in font family ' + s.familyName + ".");
    return;
  }
  const a = new Oy();
  let l, c, h, d, u, p, f, m;
  if (o.o) {
    const y = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
    for (let x = 0, v = y.length; x < v; )
      switch (y[x++]) {
        case "m":
          l = y[x++] * e + n, c = y[x++] * e + r, a.moveTo(l, c);
          break;
        case "l":
          l = y[x++] * e + n, c = y[x++] * e + r, a.lineTo(l, c);
          break;
        case "q":
          h = y[x++] * e + n, d = y[x++] * e + r, u = y[x++] * e + n, p = y[x++] * e + r, a.quadraticCurveTo(u, p, h, d);
          break;
        case "b":
          h = y[x++] * e + n, d = y[x++] * e + r, u = y[x++] * e + n, p = y[x++] * e + r, f = y[x++] * e + n, m = y[x++] * e + r, a.bezierCurveTo(u, p, f, m, h, d);
          break;
      }
  }
  return { offsetX: o.ha * e, path: a };
}
function Bm(t) {
  dt.call(this, t);
}
Bm.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: Bm,
  load: function(t, e, n, r) {
    const s = this, o = new Si(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      let l;
      try {
        l = JSON.parse(a);
      } catch {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), l = JSON.parse(a.substring(65, a.length - 2));
      }
      const c = s.parse(l);
      e && e(c);
    }, n, r);
  },
  parse: function(t) {
    return new Fy(t);
  }
});
let gc;
const C1 = {
  getContext: function() {
    return gc === void 0 && (gc = new (window.AudioContext || window.webkitAudioContext)()), gc;
  },
  setContext: function(t) {
    gc = t;
  }
};
function zm(t) {
  dt.call(this, t);
}
zm.prototype = Object.assign(Object.create(dt.prototype), {
  constructor: zm,
  load: function(t, e, n, r) {
    const s = this, o = new Si(s.manager);
    o.setResponseType("arraybuffer"), o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      try {
        const l = a.slice(0);
        C1.getContext().decodeAudioData(l, function(h) {
          e(h);
        });
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  }
});
function Um(t, e, n) {
  _i.call(this, void 0, n);
  const r = new Ne().set(t), s = new Ne().set(e), o = new z(r.r, r.g, r.b), a = new z(s.r, s.g, s.b), l = Math.sqrt(Math.PI), c = l * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
}
Um.prototype = Object.assign(Object.create(_i.prototype), {
  constructor: Um,
  isHemisphereLightProbe: !0,
  copy: function(t) {
    return _i.prototype.copy.call(this, t), this;
  },
  toJSON: function(t) {
    return _i.prototype.toJSON.call(this, t);
  }
});
function Hm(t, e) {
  _i.call(this, void 0, e);
  const n = new Ne().set(t);
  this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
Hm.prototype = Object.assign(Object.create(_i.prototype), {
  constructor: Hm,
  isAmbientLightProbe: !0,
  copy: function(t) {
    return _i.prototype.copy.call(this, t), this;
  },
  toJSON: function(t) {
    return _i.prototype.toJSON.call(this, t);
  }
});
const Gm = new Je(), Vm = new Je();
function R1() {
  this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Nt(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Nt(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}
Object.assign(R1.prototype, {
  update: function(t) {
    const e = this._cache;
    if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
      e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
      const r = t.projectionMatrix.clone(), s = e.eyeSep / 2, o = s * e.near / e.focus, a = e.near * Math.tan($e.DEG2RAD * e.fov * 0.5) / e.zoom;
      let l, c;
      Vm.elements[12] = -s, Gm.elements[12] = s, l = -a * e.aspect + o, c = a * e.aspect + o, r.elements[0] = 2 * e.near / (c - l), r.elements[8] = (c + l) / (c - l), this.cameraL.projectionMatrix.copy(r), l = -a * e.aspect - o, c = a * e.aspect - o, r.elements[0] = 2 * e.near / (c - l), r.elements[8] = (c + l) / (c - l), this.cameraR.projectionMatrix.copy(r);
    }
    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Vm), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Gm);
  }
});
function By(t, e, n) {
  this.binding = t, this.valueSize = n;
  let r, s, o;
  switch (e) {
    case "quaternion":
      r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
      break;
    case "string":
    case "bool":
      r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
      break;
    default:
      r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
  }
  this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
}
Object.assign(By.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function(t, e) {
    const n = this.buffer, r = this.valueSize, s = t * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a)
        n[s + a] = n[a];
      o = e;
    } else {
      o += e;
      const a = e / o;
      this._mixBufferRegion(n, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  },
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive: function(t) {
    const e = this.buffer, n = this.valueSize, r = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function(t) {
    const e = this.valueSize, n = this.buffer, r = t * e + e, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = e * this._origIndex;
      this._mixBufferRegion(
        n,
        r,
        l,
        1 - s,
        e
      );
    }
    o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
    for (let l = e, c = e + e; l !== c; ++l)
      if (n[l] !== n[l + e]) {
        a.setValue(n, r);
        break;
      }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function() {
    const t = this.binding, e = this.buffer, n = this.valueSize, r = n * this._origIndex;
    t.getValue(e, r);
    for (let s = n, o = r; s !== o; ++s)
      e[s] = e[r + s % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function() {
    const t = this.valueSize * 3;
    this.binding.setValue(this.buffer, t);
  },
  _setAdditiveIdentityNumeric: function() {
    const t = this._addIndex * this.valueSize, e = t + this.valueSize;
    for (let n = t; n < e; n++)
      this.buffer[n] = 0;
  },
  _setAdditiveIdentityQuaternion: function() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  },
  _setAdditiveIdentityOther: function() {
    const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n];
  },
  // mix functions
  _select: function(t, e, n, r, s) {
    if (r >= 0.5)
      for (let o = 0; o !== s; ++o)
        t[e + o] = t[n + o];
  },
  _slerp: function(t, e, n, r) {
    bn.slerpFlat(t, e, t, e, t, n, r);
  },
  _slerpAdditive: function(t, e, n, r, s) {
    const o = this._workIndex * s;
    bn.multiplyQuaternionsFlat(t, o, t, e, t, n), bn.slerpFlat(t, e, t, e, t, o, r);
  },
  _lerp: function(t, e, n, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = e + a;
      t[l] = t[l] * o + t[n + a] * r;
    }
  },
  _lerpAdditive: function(t, e, n, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = e + o;
      t[a] = t[a] + t[n + o] * r;
    }
  }
});
const Kf = "\\[\\]\\.:\\/", P1 = new RegExp("[" + Kf + "]", "g"), Qf = "[^" + Kf + "]", I1 = "[^" + Kf.replace("\\.", "") + "]", D1 = /((?:WC+[\/:])*)/.source.replace("WC", Qf), N1 = /(WCOD+)?/.source.replace("WCOD", I1), O1 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Qf), F1 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Qf), B1 = new RegExp(
  "^" + D1 + N1 + O1 + F1 + "$"
), z1 = ["material", "materials", "bones"];
function zy(t, e, n) {
  const r = n || Zt.parseTrackName(e);
  this._targetGroup = t, this._bindings = t.subscribe_(e, r);
}
Object.assign(zy.prototype, {
  getValue: function(t, e) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, r = this._bindings[n];
    r !== void 0 && r.getValue(t, e);
  },
  setValue: function(t, e) {
    const n = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = n.length; r !== s; ++r)
      n[r].setValue(t, e);
  },
  bind: function() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind();
  },
  unbind: function() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind();
  }
});
function Zt(t, e, n) {
  this.path = e, this.parsedPath = n || Zt.parseTrackName(e), this.node = Zt.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
}
Object.assign(Zt, {
  Composite: zy,
  create: function(t, e, n) {
    return t && t.isAnimationObjectGroup ? new Zt.Composite(t, e, n) : new Zt(t, e, n);
  },
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function(t) {
    return t.replace(/\s/g, "_").replace(P1, "");
  },
  parseTrackName: function(t) {
    const e = B1.exec(t);
    if (!e)
      throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: e[2],
      objectName: e[3],
      objectIndex: e[4],
      propertyName: e[5],
      // required
      propertyIndex: e[6]
    }, r = n.nodeName && n.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = n.nodeName.substring(r + 1);
      z1.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
    return n;
  },
  findNode: function(t, e) {
    if (!e || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid)
      return t;
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e);
      if (n !== void 0)
        return n;
    }
    if (t.children) {
      const n = function(s) {
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          if (a.name === e || a.uuid === e)
            return a;
          const l = n(a.children);
          if (l) return l;
        }
        return null;
      }, r = n(t.children);
      if (r)
        return r;
    }
    return null;
  }
});
Object.assign(Zt.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function(e, n) {
      e[n] = this.node[this.propertyName];
    },
    function(e, n) {
      const r = this.resolvedProperty;
      for (let s = 0, o = r.length; s !== o; ++s)
        e[n++] = r[s];
    },
    function(e, n) {
      e[n] = this.resolvedProperty[this.propertyIndex];
    },
    function(e, n) {
      this.resolvedProperty.toArray(e, n);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      // Direct
      function(e, n) {
        this.targetObject[this.propertyName] = e[n];
      },
      function(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // EntireArray
      function(e, n) {
        const r = this.resolvedProperty;
        for (let s = 0, o = r.length; s !== o; ++s)
          r[s] = e[n++];
      },
      function(e, n) {
        const r = this.resolvedProperty;
        for (let s = 0, o = r.length; s !== o; ++s)
          r[s] = e[n++];
        this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        const r = this.resolvedProperty;
        for (let s = 0, o = r.length; s !== o; ++s)
          r[s] = e[n++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // ArrayElement
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n];
      },
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // HasToFromArray
      function(e, n) {
        this.resolvedProperty.fromArray(e, n);
      },
      function(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ]
  ],
  getValue: function(e, n) {
    this.bind(), this.getValue(e, n);
  },
  setValue: function(e, n) {
    this.bind(), this.setValue(e, n);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function() {
    let t = this.node;
    const e = this.parsedPath, n = e.objectName, r = e.propertyName;
    let s = e.propertyIndex;
    if (t || (t = Zt.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (n) {
      let c = e.objectIndex;
      switch (n) {
        case "materials":
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          t = t.skeleton.bones;
          for (let h = 0; h < t.length; h++)
            if (t[h].name === c) {
              c = h;
              break;
            }
          break;
        default:
          if (t[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          t = t[n];
      }
      if (c !== void 0) {
        if (t[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          return;
        }
        t = t[c];
      }
    }
    const o = t[r];
    if (o === void 0) {
      const c = e.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", t);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = t, t.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (t.geometry.isBufferGeometry) {
          if (!t.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          t.morphTargetDictionary[s] !== void 0 && (s = t.morphTargetDictionary[s]);
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  },
  unbind: function() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
});
Object.assign(Zt.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: Zt.prototype.getValue,
  _setValue_unbound: Zt.prototype.setValue
});
function U1() {
  this.uuid = $e.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
  const t = {};
  this._indicesByUUID = t;
  for (let n = 0, r = arguments.length; n !== r; ++n)
    t[arguments[n].uuid] = n;
  this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
  const e = this;
  this.stats = {
    objects: {
      get total() {
        return e._objects.length;
      },
      get inUse() {
        return this.total - e.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return e._bindings.length;
    }
  };
}
Object.assign(U1.prototype, {
  isAnimationObjectGroup: !0,
  add: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length;
    let a, l = t.length, c = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const u = arguments[h], p = u.uuid;
      let f = e[p];
      if (f === void 0) {
        f = l++, e[p] = f, t.push(u);
        for (let m = 0, y = o; m !== y; ++m)
          s[m].push(new Zt(u, n[m], r[m]));
      } else if (f < c) {
        a = t[f];
        const m = --c, y = t[m];
        e[y.uuid] = f, t[f] = y, e[p] = m, t[m] = u;
        for (let x = 0, v = o; x !== v; ++x) {
          const g = s[x], S = g[m];
          let T = g[f];
          g[f] = S, T === void 0 && (T = new Zt(u, n[x], r[x])), g[m] = T;
        }
      } else t[f] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  },
  remove: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._bindings, r = n.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o], c = l.uuid, h = e[c];
      if (h !== void 0 && h >= s) {
        const d = s++, u = t[d];
        e[u.uuid] = h, t[h] = u, e[c] = d, t[d] = l;
        for (let p = 0, f = r; p !== f; ++p) {
          const m = n[p], y = m[d], x = m[h];
          m[h] = y, m[d] = x;
        }
      }
    }
    this.nCachedObjects_ = s;
  },
  // remove & forget
  uncache: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._bindings, r = n.length;
    let s = this.nCachedObjects_, o = t.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a], h = c.uuid, d = e[h];
      if (d !== void 0)
        if (delete e[h], d < s) {
          const u = --s, p = t[u], f = --o, m = t[f];
          e[p.uuid] = d, t[d] = p, e[m.uuid] = u, t[u] = m, t.pop();
          for (let y = 0, x = r; y !== x; ++y) {
            const v = n[y], g = v[u], S = v[f];
            v[d] = g, v[u] = S, v.pop();
          }
        } else {
          const u = --o, p = t[u];
          u > 0 && (e[p.uuid] = d), t[d] = p, t.pop();
          for (let f = 0, m = r; f !== m; ++f) {
            const y = n[f];
            y[d] = y[u], y.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function(t, e) {
    const n = this._bindingsIndicesByPath;
    let r = n[t];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, h = this.nCachedObjects_, d = new Array(c);
    r = s.length, n[t] = r, o.push(t), a.push(e), s.push(d);
    for (let u = h, p = l.length; u !== p; ++u) {
      const f = l[u];
      d[u] = new Zt(f, t, e);
    }
    return d;
  },
  unsubscribe_: function(t) {
    const e = this._bindingsIndicesByPath, n = e[t];
    if (n !== void 0) {
      const r = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], c = t[a];
      e[c] = n, o[n] = l, o.pop(), s[n] = s[a], s.pop(), r[n] = r[a], r.pop();
    }
  }
});
let H1 = class {
  constructor(e, n, r = null, s = n.blendMode) {
    this._mixer = e, this._clip = n, this._localRoot = r, this.blendMode = s;
    const o = n.tracks, a = o.length, l = new Array(a), c = {
      endingStart: co,
      endingEnd: co
    };
    for (let h = 0; h !== a; ++h) {
      const d = o[h].createInterpolant(null);
      l[h] = d, d.settings = c;
    }
    this._interpolantSettings = c, this._interpolants = l, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = s_, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, n) {
    return this.loop = e, this.repetitions = n, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, n, r) {
    if (e.fadeOut(n), this.fadeIn(n), r) {
      const s = this._clip.duration, o = e._clip.duration, a = o / s, l = s / o;
      e.warp(1, a, n), this.warp(l, 1, n);
    }
    return this;
  }
  crossFadeTo(e, n, r) {
    return e.crossFadeFrom(this, n, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, n, r) {
    const s = this._mixer, o = s.time, a = this.timeScale;
    let l = this._timeScaleInterpolant;
    l === null && (l = s._lendControlInterpolant(), this._timeScaleInterpolant = l);
    const c = l.parameterPositions, h = l.sampleValues;
    return c[0] = o, c[1] = o + r, h[0] = e / a, h[1] = n / a, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, n, r, s) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const c = (e - o) * r;
      if (c < 0 || r === 0)
        return;
      this._startTime = null, n = r * c;
    }
    n *= this._updateTimeScale(e);
    const a = this._updateTime(n), l = this._updateWeight(e);
    if (l > 0) {
      const c = this._interpolants, h = this._propertyBindings;
      switch (this.blendMode) {
        case uy:
          for (let d = 0, u = c.length; d !== u; ++d)
            c[d].evaluate(a), h[d].accumulateAdditive(l);
          break;
        case jf:
        default:
          for (let d = 0, u = c.length; d !== u; ++d)
            c[d].evaluate(a), h[d].accumulate(s, l);
      }
    }
  }
  _updateWeight(e) {
    let n = 0;
    if (this.enabled) {
      n = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const s = r.evaluate(e)[0];
        n *= s, e > r.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = n, n;
  }
  _updateTimeScale(e) {
    let n = 0;
    if (!this.paused) {
      n = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const s = r.evaluate(e)[0];
        n *= s, e > r.parameterPositions[1] && (this.stopWarping(), n === 0 ? this.paused = !0 : this.timeScale = n);
      }
    }
    return this._effectiveTimeScale = n, n;
  }
  _updateTime(e) {
    const n = this._clip.duration, r = this.loop;
    let s = this.time + e, o = this._loopCount;
    const a = r === o_;
    if (e === 0)
      return o === -1 ? s : a && (o & 1) === 1 ? n - s : s;
    if (r === r_) {
      o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (s >= n)
          s = n;
        else if (s < 0)
          s = 0;
        else {
          this.time = s;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), s >= n || s < 0) {
        const l = Math.floor(s / n);
        s -= n * l, o += Math.abs(l);
        const c = this.repetitions - o;
        if (c <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = e > 0 ? n : 0, this.time = s, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (c === 1) {
            const h = e < 0;
            this._setEndings(h, !h, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = o, this.time = s, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: l
          });
        }
      } else
        this.time = s;
      if (a && (o & 1) === 1)
        return n - s;
    }
    return s;
  }
  _setEndings(e, n, r) {
    const s = this._interpolantSettings;
    r ? (s.endingStart = ho, s.endingEnd = ho) : (e ? s.endingStart = this.zeroSlopeAtStart ? ho : co : s.endingStart = mh, n ? s.endingEnd = this.zeroSlopeAtEnd ? ho : co : s.endingEnd = mh);
  }
  _scheduleFading(e, n, r) {
    const s = this._mixer, o = s.time;
    let a = this._weightInterpolant;
    a === null && (a = s._lendControlInterpolant(), this._weightInterpolant = a);
    const l = a.parameterPositions, c = a.sampleValues;
    return l[0] = o, c[0] = n, l[1] = o + e, c[1] = r, this;
  }
};
function km(t) {
  this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
}
km.prototype = Object.assign(Object.create(ar.prototype), {
  constructor: km,
  _bindAction: function(t, e) {
    const n = t._localRoot || this._root, r = t._clip.tracks, s = r.length, o = t._propertyBindings, a = t._interpolants, l = n.uuid, c = this._bindingsByRootAndName;
    let h = c[l];
    h === void 0 && (h = {}, c[l] = h);
    for (let d = 0; d !== s; ++d) {
      const u = r[d], p = u.name;
      let f = h[p];
      if (f !== void 0)
        o[d] = f;
      else {
        if (f = o[d], f !== void 0) {
          f._cacheIndex === null && (++f.referenceCount, this._addInactiveBinding(f, l, p));
          continue;
        }
        const m = e && e._propertyBindings[d].binding.parsedPath;
        f = new By(
          Zt.create(n, p, m),
          u.ValueTypeName,
          u.getValueSize()
        ), ++f.referenceCount, this._addInactiveBinding(f, l, p), o[d] = f;
      }
      a[d].resultBuffer = f.buffer;
    }
  },
  _activateAction: function(t) {
    if (!this._isActiveAction(t)) {
      if (t._cacheIndex === null) {
        const n = (t._localRoot || this._root).uuid, r = t._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(
          t,
          s && s.knownActions[0]
        ), this._addInactiveAction(t, r, n);
      }
      const e = t._propertyBindings;
      for (let n = 0, r = e.length; n !== r; ++n) {
        const s = e[n];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(t);
    }
  },
  _deactivateAction: function(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let n = 0, r = e.length; n !== r; ++n) {
        const s = e[n];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(t);
    }
  },
  // Memory manager
  _initMemoryManager: function() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },
        get inUse() {
          return t._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return t._bindings.length;
        },
        get inUse() {
          return t._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },
        get inUse() {
          return t._nActiveControlInterpolants;
        }
      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function(t) {
    const e = t._cacheIndex;
    return e !== null && e < this._nActiveActions;
  },
  _addInactiveAction: function(t, e, n) {
    const r = this._actions, s = this._actionsByClip;
    let o = s[e];
    if (o === void 0)
      o = {
        knownActions: [t],
        actionByRoot: {}
      }, t._byClipCacheIndex = 0, s[e] = o;
    else {
      const a = o.knownActions;
      t._byClipCacheIndex = a.length, a.push(t);
    }
    t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t;
  },
  _removeInactiveAction: function(t) {
    const e = this._actions, n = e[e.length - 1], r = t._cacheIndex;
    n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
    const s = t._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, c = l[l.length - 1], h = t._byClipCacheIndex;
    c._byClipCacheIndex = h, l[h] = c, l.pop(), t._byClipCacheIndex = null;
    const d = a.actionByRoot, u = (t._localRoot || this._root).uuid;
    delete d[u], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(t);
  },
  _removeInactiveBindingsForAction: function(t) {
    const e = t._propertyBindings;
    for (let n = 0, r = e.length; n !== r; ++n) {
      const s = e[n];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  },
  _lendAction: function(t) {
    const e = this._actions, n = t._cacheIndex, r = this._nActiveActions++, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  },
  _takeBackAction: function(t) {
    const e = this._actions, n = t._cacheIndex, r = --this._nActiveActions, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function(t, e, n) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let o = r[e];
    o === void 0 && (o = {}, r[e] = o), o[n] = t, t._cacheIndex = s.length, s.push(t);
  },
  _removeInactiveBinding: function(t) {
    const e = this._bindings, n = t.binding, r = n.rootNode.uuid, s = n.path, o = this._bindingsByRootAndName, a = o[r], l = e[e.length - 1], c = t._cacheIndex;
    l._cacheIndex = c, e[c] = l, e.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r];
  },
  _lendBinding: function(t) {
    const e = this._bindings, n = t._cacheIndex, r = this._nActiveBindings++, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  },
  _takeBackBinding: function(t) {
    const e = this._bindings, n = t._cacheIndex, r = --this._nActiveBindings, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function() {
    const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
    let n = t[e];
    return n === void 0 && (n = new Mh(
      new Float32Array(2),
      new Float32Array(2),
      1,
      this._controlInterpolantsResultBuffer
    ), n.__cacheIndex = e, t[e] = n), n;
  },
  _takeBackControlInterpolant: function(t) {
    const e = this._controlInterpolants, n = t.__cacheIndex, r = --this._nActiveControlInterpolants, s = e[r];
    t.__cacheIndex = r, e[r] = t, s.__cacheIndex = n, e[n] = s;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function(t, e, n) {
    const r = e || this._root, s = r.uuid;
    let o = typeof t == "string" ? Pn.findByName(r, t) : t;
    const a = o !== null ? o.uuid : t, l = this._actionsByClip[a];
    let c = null;
    if (n === void 0 && (o !== null ? n = o.blendMode : n = jf), l !== void 0) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === n)
        return d;
      c = l.knownActions[0], o === null && (o = c._clip);
    }
    if (o === null) return null;
    const h = new H1(this, o, e, n);
    return this._bindAction(h, c), this._addInactiveAction(h, a, s), h;
  },
  // get an existing action
  existingAction: function(t, e) {
    const n = e || this._root, r = n.uuid, s = typeof t == "string" ? Pn.findByName(n, t) : t, o = s ? s.uuid : t, a = this._actionsByClip[o];
    return a !== void 0 && a.actionByRoot[r] || null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function() {
    const t = this._actions, e = this._nActiveActions;
    for (let n = e - 1; n >= 0; --n)
      t[n].stop();
    return this;
  },
  // advance the time and update apply the animation
  update: function(t) {
    t *= this.timeScale;
    const e = this._actions, n = this._nActiveActions, r = this.time += t, s = Math.sign(t), o = this._accuIndex ^= 1;
    for (let c = 0; c !== n; ++c)
      e[c]._update(r, t, s, o);
    const a = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      a[c].apply(o);
    return this;
  },
  // Allows you to seek to a specific time in an animation.
  setTime: function(t) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++)
      this._actions[e].time = 0;
    return this.update(t);
  },
  // return this mixer's root target object
  getRoot: function() {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function(t) {
    const e = this._actions, n = t.uuid, r = this._actionsByClip, s = r[n];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const h = c._cacheIndex, d = e[e.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, d._cacheIndex = h, e[h] = d, e.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete r[n];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function(t) {
    const e = t.uuid, n = this._actionsByClip;
    for (const o in n) {
      const a = n[o].actionByRoot, l = a[e];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName, s = r[e];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  },
  // remove a targeted clip from the cache
  uncacheAction: function(t, e) {
    const n = this.existingAction(t, e);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
});
function Ah(t, e, n) {
  xn.call(this, t, e), this.meshPerAttribute = n || 1;
}
Ah.prototype = Object.assign(Object.create(xn.prototype), {
  constructor: Ah,
  isInstancedInterleavedBuffer: !0,
  copy: function(t) {
    return xn.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
  },
  clone: function(t) {
    const e = xn.prototype.clone.call(this, t);
    return e.meshPerAttribute = this.meshPerAttribute, e;
  },
  toJSON: function(t) {
    const e = xn.prototype.toJSON.call(this, t);
    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e;
  }
});
function Uy(t, e, n, r, s) {
  this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = s, this.version = 0;
}
Object.defineProperty(Uy.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
Object.assign(Uy.prototype, {
  isGLBufferAttribute: !0,
  setBuffer: function(t) {
    return this.buffer = t, this;
  },
  setType: function(t, e) {
    return this.type = t, this.elementSize = e, this;
  },
  setItemSize: function(t) {
    return this.itemSize = t, this;
  },
  setCount: function(t) {
    return this.count = t, this;
  }
});
function tu(t, e, n, r) {
  this.ray = new Nl(t, e), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.layers = new py(), this.params = {
    Mesh: {},
    Line: { threshold: 1 },
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  }, Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
      }
    }
  });
}
function Wm(t, e) {
  return t.distance - e.distance;
}
function nf(t, e, n, r) {
  if (t.layers.test(e.layers) && t.raycast(e, n), r === !0) {
    const s = t.children;
    for (let o = 0, a = s.length; o < a; o++)
      nf(s[o], e, n, !0);
  }
}
Object.assign(tu.prototype, {
  set: function(t, e) {
    this.ray.set(t, e);
  },
  setFromCamera: function(t, e) {
    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  },
  intersectObject: function(t, e, n) {
    const r = n || [];
    return nf(t, this, r, e), r.sort(Wm), r;
  },
  intersectObjects: function(t, e, n) {
    const r = n || [];
    if (Array.isArray(t) === !1)
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
    for (let s = 0, o = t.length; s < o; s++)
      nf(t[s], this, r, e);
    return r.sort(Wm), r;
  }
});
const $m = /* @__PURE__ */ new ye();
let G1 = class {
  constructor(e, n) {
    Object.defineProperty(this, "isBox2", { value: !0 }), this.min = e !== void 0 ? e : new ye(1 / 0, 1 / 0), this.max = n !== void 0 ? n : new ye(-1 / 0, -1 / 0);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = $m.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new ye()), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), e = new ye()), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, n) {
    return n === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), n = new ye()), n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, n) {
    return n === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), n = new ye()), n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return $m.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
};
const jm = /* @__PURE__ */ new z(), vc = /* @__PURE__ */ new z();
let ep = class {
  constructor(e, n) {
    this.start = e !== void 0 ? e : new z(), this.end = n !== void 0 ? n : new z();
  }
  set(e, n) {
    return this.start.copy(e), this.end.copy(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new z()), e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), e = new z()), e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, n) {
    return n === void 0 && (console.warn("THREE.Line3: .at() target is now required"), n = new z()), this.delta(n).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, n) {
    jm.subVectors(e, this.start), vc.subVectors(this.end, this.start);
    const r = vc.dot(vc);
    let o = vc.dot(jm) / r;
    return n && (o = $e.clamp(o, 0, 1)), o;
  }
  closestPointToPoint(e, n, r) {
    const s = this.closestPointToPointParameter(e, n);
    return r === void 0 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), r = new z()), this.delta(r).multiplyScalar(s).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
};
function Lh(t) {
  He.call(this), this.material = t, this.render = function() {
  }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
}
Lh.prototype = Object.create(He.prototype);
Lh.prototype.constructor = Lh;
Lh.prototype.isImmediateRenderObject = !0;
const yr = /* @__PURE__ */ new z(), yc = /* @__PURE__ */ new Je(), Vu = /* @__PURE__ */ new Je();
let V1 = class extends nl {
  constructor(e) {
    const n = Hy(e), r = new it(), s = [], o = [], a = new Ne(0, 0, 1), l = new Ne(0, 1, 0);
    for (let h = 0; h < n.length; h++) {
      const d = n[h];
      d.parent && d.parent.isBone && (s.push(0, 0, 0), s.push(0, 0, 0), o.push(a.r, a.g, a.b), o.push(l.r, l.g, l.b));
    }
    r.setAttribute("position", new Ke(s, 3)), r.setAttribute("color", new Ke(o, 3));
    const c = new un({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(r, c), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = n, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const n = this.bones, r = this.geometry, s = r.getAttribute("position");
    Vu.copy(this.root.matrixWorld).invert();
    for (let o = 0, a = 0; o < n.length; o++) {
      const l = n[o];
      l.parent && l.parent.isBone && (yc.multiplyMatrices(Vu, l.matrixWorld), yr.setFromMatrixPosition(yc), s.setXYZ(a, yr.x, yr.y, yr.z), yc.multiplyMatrices(Vu, l.parent.matrixWorld), yr.setFromMatrixPosition(yc), s.setXYZ(a + 1, yr.x, yr.y, yr.z), a += 2);
    }
    r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
};
function Hy(t) {
  const e = [];
  t && t.isBone && e.push(t);
  for (let n = 0; n < t.children.length; n++)
    e.push.apply(e, Hy(t.children[n]));
  return e;
}
let k1 = class extends nl {
  constructor(e = 10, n = 10, r = 4473924, s = 8947848) {
    r = new Ne(r), s = new Ne(s);
    const o = n / 2, a = e / n, l = e / 2, c = [], h = [];
    for (let p = 0, f = 0, m = -l; p <= n; p++, m += a) {
      c.push(-l, 0, m, l, 0, m), c.push(m, 0, -l, m, 0, l);
      const y = p === o ? r : s;
      y.toArray(h, f), f += 3, y.toArray(h, f), f += 3, y.toArray(h, f), f += 3, y.toArray(h, f), f += 3;
    }
    const d = new it();
    d.setAttribute("position", new Ke(c, 3)), d.setAttribute("color", new Ke(h, 3));
    const u = new un({ vertexColors: !0, toneMapped: !1 });
    super(d, u), this.type = "GridHelper";
  }
};
const W1 = new Float32Array(1);
new Int32Array(W1.buffer);
Oe.create = function(t, e) {
  return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Oe.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
};
Object.assign(Pr.prototype, {
  createPointsGeometry: function(t) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = this.getPoints(t);
    return this.createGeometry(e);
  },
  createSpacedPointsGeometry: function(t) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = this.getSpacedPoints(t);
    return this.createGeometry(e);
  },
  createGeometry: function(t) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = new cn();
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.vertices.push(new z(s.x, s.y, s.z || 0));
    }
    return e;
  }
});
Object.assign(yi.prototype, {
  fromPoints: function(t) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
  }
});
Object.create(En.prototype);
Object.create(En.prototype);
function Gy(t) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), En.call(this, t), this.type = "catmullrom";
}
Gy.prototype = Object.create(En.prototype);
Object.assign(Gy.prototype, {
  initFromArray: function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
k1.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
V1.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Object.assign(dt.prototype, {
  extractUrlBase: function(t) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ny.extractUrlBase(t);
  }
});
dt.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Object.assign(G1.prototype, {
  center: function(t) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
  },
  empty: function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(t) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  size: function(t) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
  }
});
Object.assign(kt.prototype, {
  center: function(t) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  },
  empty: function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(t) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  isIntersectionSphere: function(t) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
  },
  size: function(t) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
  }
});
Object.assign(hi.prototype, {
  empty: function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }
});
Kh.prototype.setFromMatrix = function(t) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
};
ep.prototype.center = function(t) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
};
Object.assign($e, {
  random16: function() {
    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
  },
  nearestPowerOfTwo: function(t) {
    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), $e.floorPowerOfTwo(t);
  },
  nextPowerOfTwo: function(t) {
    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), $e.ceilPowerOfTwo(t);
  }
});
Object.assign(ln.prototype, {
  flattenToArrayOffset: function(t, e) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
  },
  multiplyVector3: function(t) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBufferAttribute: function(t) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  },
  getInverse: function(t) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
  }
});
Object.assign(Je.prototype, {
  extractPosition: function(t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
  },
  flattenToArrayOffset: function(t, e) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
  },
  getPosition: function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new z().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function(t) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  multiplyVector4: function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(t) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
  },
  crossVector: function(t) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBufferAttribute: function(t) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(t, e, n, r, s, o) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, s, o);
  },
  getInverse: function(t) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
  }
});
ti.prototype.isIntersectionLine = function(t) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
};
Object.assign(bn.prototype, {
  multiplyVector3: function(t) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
  },
  inverse: function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
  }
});
Object.assign(Nl.prototype, {
  isIntersectionBox: function(t) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  isIntersectionPlane: function(t) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
  },
  isIntersectionSphere: function(t) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
  }
});
Object.assign(oi.prototype, {
  area: function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  },
  barycoordFromPoint: function(t, e) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
  },
  midpoint: function(t) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
  },
  normal: function(t) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
  },
  plane: function(t) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
  }
});
Object.assign(oi, {
  barycoordFromPoint: function(t, e, n, r, s) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), oi.getBarycoord(t, e, n, r, s);
  },
  normal: function(t, e, n, r) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), oi.getNormal(t, e, n, r);
  }
});
Object.assign(So.prototype, {
  extractAllPoints: function(t) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
  },
  extrude: function(t) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new r1(this, t);
  },
  makeGeometry: function(t) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new l1(this, t);
  }
});
Object.assign(ye.prototype, {
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  distanceToManhattan: function(t) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(z.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(t) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
  },
  getScaleFromMatrix: function(t) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
  },
  getColumnFromMatrix: function(t, e) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
  },
  applyProjection: function(t) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
  },
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  distanceToManhattan: function(t) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(ht.prototype, {
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(cn.prototype, {
  computeTangents: function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  },
  applyMatrix: function(t) {
    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.assign(He.prototype, {
  getChildByName: function(t) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(t, e) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
  },
  getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  },
  applyMatrix: function(t) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.defineProperties(He.prototype, {
  eulerOrder: {
    get: function() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function(t) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.assign(Tt.prototype, {
  setDrawMode: function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }
});
Object.defineProperties(Tt.prototype, {
  drawMode: {
    get: function() {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), a_;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
Object.defineProperties(Od.prototype, {
  objects: {
    get: function() {
      return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
    }
  }
});
Object.defineProperty(_h.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
yh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Oe.prototype, "__arcLengthDivisions", {
  get: function() {
    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
  },
  set: function(t) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t;
  }
});
Nt.prototype.setLens = function(t, e) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e !== void 0 && (this.filmGauge = e), this.setFocalLength(t);
};
Object.defineProperties(yt.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
    }
  },
  shadowCameraLeft: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
    }
  },
  shadowCameraRight: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
    }
  },
  shadowCameraTop: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
    }
  },
  shadowCameraBottom: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
    }
  },
  shadowCameraNear: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
    }
  },
  shadowCameraFar: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(t) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(t) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
    }
  },
  shadowMapHeight: {
    set: function(t) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
    }
  }
});
Object.defineProperties(We.prototype, {
  length: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  dynamic: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Ja;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Ja);
    }
  }
});
Object.assign(We.prototype, {
  setDynamic: function(t) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t === !0 ? Ja : Jh), this;
  },
  copyIndicesArray: function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  },
  setArray: function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
});
Object.assign(it.prototype, {
  addIndex: function(t) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
  },
  addAttribute: function(t, e) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new We(arguments[1], arguments[2]))) : t === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e);
  },
  addDrawCall: function(t, e, n) {
    n !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  },
  removeAttribute: function(t) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
  },
  applyMatrix: function(t) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.defineProperties(it.prototype, {
  drawcalls: {
    get: function() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
});
Object.defineProperties(ul.prototype, {
  maxInstancedCount: {
    get: function() {
      return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount;
    },
    set: function(t) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t;
    }
  }
});
Object.defineProperties(tu.prototype, {
  linePrecision: {
    get: function() {
      return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold;
    },
    set: function(t) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t;
    }
  }
});
Object.defineProperties(xn.prototype, {
  dynamic: {
    get: function() {
      return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === Ja;
    },
    set: function(t) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t);
    }
  }
});
Object.assign(xn.prototype, {
  setDynamic: function(t) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t === !0 ? Ja : Jh), this;
  },
  setArray: function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
});
Object.assign(Dy.prototype, {
  getArrays: function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
});
Object.assign(Zf.prototype, {
  dispose: function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  }
});
Object.defineProperties(Ve.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new Ne();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(t) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === oy;
    }
  },
  stencilMask: {
    get: function() {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    },
    set: function(t) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
    }
  }
});
Object.defineProperties(ys.prototype, {
  metal: {
    get: function() {
      return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(jr.prototype, {
  transparency: {
    get: function() {
      return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission;
    },
    set: function(t) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t;
    }
  }
});
Object.defineProperties(rn.prototype, {
  derivatives: {
    get: function() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function(t) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
    }
  }
});
Object.assign(Qh.prototype, {
  clearTarget: function(t, e, n, r) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r);
  },
  animate: function(t) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
  },
  getCurrentRenderTarget: function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  },
  getMaxAnisotropy: function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  },
  resetGLState: function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  },
  supportsFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(t) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  },
  allocTextureUnit: function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  },
  setTexture: function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  },
  setTexture2D: function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  },
  setTextureCube: function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  },
  getActiveMipMapLevel: function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }
});
Object.defineProperties(Qh.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }
  },
  vr: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }
  },
  gammaInput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = t === !0 ? qf : Dl;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(Ay.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(si.prototype, {
  wrapS: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
    }
  },
  wrapT: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
    }
  },
  magFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
    }
  },
  minFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
    }
  },
  anisotropy: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
    }
  },
  offset: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
    }
  },
  repeat: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
    }
  },
  format: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
    }
  },
  type: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
    }
  },
  generateMipmaps: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
    }
  }
});
Lo.prototype.updateCubeMap = function(t, e) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
};
Lo.prototype.clear = function(t, e, n, r) {
  return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r);
};
Jo.crossOrigin = void 0;
Jo.loadTexture = function(t, e, n, r) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const s = new Eh();
  s.setCrossOrigin(this.crossOrigin);
  const o = s.load(t, n, void 0, r);
  return e && (o.mapping = e), o;
};
Jo.loadTextureCube = function(t, e, n, r) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const s = new qd();
  s.setCrossOrigin(this.crossOrigin);
  const o = s.load(t, n, void 0, r);
  return e && (o.mapping = e), o;
};
Jo.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
Jo.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Bx
} }));
let fs = null, Ce = null;
function $1() {
  fs = window.Potree, Ce = new fs.Viewer(document.getElementById("potree_render_area")), window.viewer = Ce;
}
let Vy = class {
  constructor() {
    this.domElement = document.createElement("div");
  }
  addEventListener(e, n) {
    this.domElement.addEventListener(e, n);
  }
  removeEventListener(e, n) {
    this.domElement.removeEventListener(e, n);
  }
  dispatchEvent(e) {
    this.domElement.dispatchEvent(e);
  }
};
class nu extends Vy {
  constructor(n) {
    super();
    Ue(this, "attached", !1);
    Ue(this, "name", "");
    this.name = n.name;
  }
  attach() {
    throw "Attach function must be overridden.";
  }
  detach() {
    throw "Detach function must be overridden.";
  }
  show() {
    throw "Show function must be overridden.";
  }
  hide() {
    throw "Hide function must be overridden.";
  }
  updateVisibility() {
    throw "Visibility update function must be overridden.";
  }
}
class qm extends nu {
  constructor(n) {
    super(n);
    Ue(this, "visible", !0);
    Ue(this, "urls", []);
    Ue(this, "material", null);
    Ue(this, "pointclouds", []);
    Ue(this, "attached", !1);
    Ue(this, "type", "PointcloudLayer");
    n.urls && (this.urls = n.urls), n.material && (this.material = n.material);
  }
  async attach() {
    for (let n of this.urls) await this.add(n, this.material);
    this.attached = !0;
  }
  detach() {
    for (let n of this.pointclouds) this.remove(n);
  }
  async add(n, r) {
    return new Promise((s, o) => {
      fs.loadPointCloud(n, "", (a) => {
        let l = a.pointcloud, c = l.material;
        r && r.material ? (c.size = r.material.size, c.pointSizeType = r.material.pointSizeType, c.shape = r.material.shape) : (c.size = 1, c.pointSizeType = fs.PointSizeType.ADAPTIVE, c.shape = fs.PointShape.SQUARE), this.attached && this.urls.push(n), this.pointclouds.push(l), Ce.scene.addPointCloud(l), Ce.fitToScreen(), this.updateVisibility(), s();
      });
    });
  }
  remove(n) {
    if (Ce.scene.scenePointCloud.remove(n), this.pointclouds.indexOf(n) > -1) {
      let r = this.pointclouds.indexOf(n);
      this.pointclouds.splice(r, 1), this.urls.splice(r, 1);
    }
  }
  updateVisibility() {
    for (let n of this.pointclouds) n.visible = this.visible;
  }
  show() {
    this.visible = !0, this.updateVisibility();
  }
  hide() {
    this.visible = !1, this.updateVisibility();
  }
  bbox() {
    let n = new kt();
    for (let r of this.pointclouds)
      n.union(r.boundingBox.clone().translate(r.position));
    return n;
  }
}
let iu = class {
  constructor() {
    Ue(this, "vectors", []);
  }
  construtor() {
  }
};
const ah = ni, j1 = rn, lh = Ae, ky = yy, q1 = ye;
lh.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new q1(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ah.line = {
  uniforms: ky.merge([
    lh.common,
    lh.fog,
    lh.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
let Ol = class extends j1 {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: ky.clone(ah.line.uniforms),
      vertexShader: ah.line.vertexShader,
      fragmentShader: ah.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), Object.defineProperties(this, {
      color: {
        enumerable: !0,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(n) {
          this.uniforms.diffuse.value = n;
        }
      },
      worldUnits: {
        enumerable: !0,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(n) {
          n === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
        }
      },
      linewidth: {
        enumerable: !0,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(n) {
          this.uniforms.linewidth.value = n;
        }
      },
      dashed: {
        enumerable: !0,
        get: function() {
          return "USE_DASH" in this.defines;
        },
        set(n) {
          !!n != "USE_DASH" in this.defines && (this.needsUpdate = !0), n === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
        }
      },
      dashScale: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(n) {
          this.uniforms.dashScale.value = n;
        }
      },
      dashSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(n) {
          this.uniforms.dashSize.value = n;
        }
      },
      dashOffset: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(n) {
          this.uniforms.dashOffset.value = n;
        }
      },
      gapSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(n) {
          this.uniforms.gapSize.value = n;
        }
      },
      opacity: {
        enumerable: !0,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(n) {
          this.uniforms.opacity.value = n;
        }
      },
      resolution: {
        enumerable: !0,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(n) {
          this.uniforms.resolution.value.copy(n);
        }
      },
      alphaToCoverage: {
        enumerable: !0,
        get: function() {
          return "USE_ALPHA_TO_COVERAGE" in this.defines;
        },
        set: function(n) {
          !!n != "USE_ALPHA_TO_COVERAGE" in this.defines && (this.needsUpdate = !0), n === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
        }
      }
    }), this.setValues(e);
  }
};
Ol.prototype.isLineMaterial = !0;
const Wy = kt, Xm = Ke, X1 = ul, Ym = Ah, xc = wi, Y1 = hi, Z1 = z, J1 = d1, Zm = new Wy(), _c = new Z1();
let tp = class extends X1 {
  constructor() {
    super(), this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], n = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r), this.setAttribute("position", new Xm(e, 3)), this.setAttribute("uv", new Xm(n, 2));
  }
  applyMatrix4(e) {
    const n = this.attributes.instanceStart, r = this.attributes.instanceEnd;
    return n !== void 0 && (n.applyMatrix4(e), r.applyMatrix4(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let n;
    e instanceof Float32Array ? n = e : Array.isArray(e) && (n = new Float32Array(e));
    const r = new Ym(n, 6, 1);
    return this.setAttribute("instanceStart", new xc(r, 3, 0)), this.setAttribute("instanceEnd", new xc(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let n;
    e instanceof Float32Array ? n = e : Array.isArray(e) && (n = new Float32Array(e));
    const r = new Ym(n, 6, 1);
    return this.setAttribute("instanceColorStart", new xc(r, 3, 0)), this.setAttribute("instanceColorEnd", new xc(r, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new J1(e.geometry)), this;
  }
  fromLineSegments(e) {
    const n = e.geometry;
    if (n.isGeometry) {
      console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");
      return;
    } else n.isBufferGeometry && this.setPositions(n.attributes.position.array);
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Wy());
    const e = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    e !== void 0 && n !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Zm.setFromBufferAttribute(n), this.boundingBox.union(Zm));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Y1()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    if (e !== void 0 && n !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let s = 0;
      for (let o = 0, a = e.count; o < a; o++)
        _c.fromBufferAttribute(e, o), s = Math.max(s, r.distanceToSquared(_c)), _c.fromBufferAttribute(n, o), s = Math.max(s, r.distanceToSquared(_c));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
};
tp.prototype.isLineSegmentsGeometry = !0;
let np = class extends tp {
  constructor() {
    super(), this.type = "LineGeometry";
  }
  setPositions(e) {
    let n = e.length - 3, r = new Float32Array(2 * n);
    for (let s = 0; s < n; s += 3)
      r[2 * s] = e[s], r[2 * s + 1] = e[s + 1], r[2 * s + 2] = e[s + 2], r[2 * s + 3] = e[s + 3], r[2 * s + 4] = e[s + 4], r[2 * s + 5] = e[s + 5];
    return super.setPositions(r), this;
  }
  setColors(e) {
    let n = e.length - 3, r = new Float32Array(2 * n);
    for (let s = 0; s < n; s += 3)
      r[2 * s] = e[s], r[2 * s + 1] = e[s + 1], r[2 * s + 2] = e[s + 2], r[2 * s + 3] = e[s + 3], r[2 * s + 4] = e[s + 4], r[2 * s + 5] = e[s + 5];
    return super.setColors(r), this;
  }
  fromLine(e) {
    let n = e.geometry;
    if (n.isGeometry) {
      console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");
      return;
    } else n.isBufferGeometry && this.setPositions(n.attributes.position.array);
    return this;
  }
};
np.prototype.isLineGeometry = !0;
const K1 = kt, Q1 = Ah, Jm = wi, eE = ep, tE = $e, nE = Je, iE = Tt, rE = hi, Uo = z, ru = ht, Km = new Uo(), Qm = new Uo(), Ot = new ru(), Ft = new ru(), fi = new ru(), ku = new Uo(), Wu = new nE(), Rn = new eE(), eg = new Uo(), Wi = new K1(), bc = new rE(), pi = new ru();
function tg(t, e, n, r) {
  return pi.set(0, 0, -e, 1).applyMatrix4(t.projectionMatrix), pi.multiplyScalar(1 / pi.w), pi.x = n / r.width, pi.y = n / r.height, pi.applyMatrix4(t.projectionMatrixInverse), pi.multiplyScalar(1 / pi.w), Math.abs(Math.max(pi.x, pi.y));
}
let $y = class extends iE {
  constructor(e = new tp(), n = new Ol({ color: Math.random() * 16777215 })) {
    super(e, n), this.type = "LineSegments2";
  }
  // for backwards-compatability, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, n = e.attributes.instanceStart, r = e.attributes.instanceEnd, s = new Float32Array(2 * n.count);
    for (let a = 0, l = 0, c = n.count; a < c; a++, l += 2)
      Km.fromBufferAttribute(n, a), Qm.fromBufferAttribute(r, a), s[l] = l === 0 ? 0 : s[l - 1], s[l + 1] = s[l] + Km.distanceTo(Qm);
    const o = new Q1(s, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Jm(o, 1, 0)), e.setAttribute("instanceDistanceEnd", new Jm(o, 1, 1)), this;
  }
  raycast(e, n) {
    e.camera === null && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
    const r = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0, s = e.ray, o = e.camera, a = o.projectionMatrix, l = this.matrixWorld, c = this.geometry, h = this.material, d = h.resolution, u = h.linewidth + r, p = c.attributes.instanceStart, f = c.attributes.instanceEnd, m = -o.near;
    c.boundingSphere === null && c.computeBoundingSphere(), bc.copy(c.boundingSphere).applyMatrix4(l);
    const y = Math.max(o.near, bc.distanceToPoint(s.origin)), x = tg(o, y, u, d);
    if (bc.radius += x, e.ray.intersectsSphere(bc) === !1)
      return;
    c.boundingBox === null && c.computeBoundingBox(), Wi.copy(c.boundingBox).applyMatrix4(l);
    const v = Math.max(o.near, Wi.distanceToPoint(s.origin)), g = tg(o, v, u, d);
    if (Wi.max.x += g, Wi.max.y += g, Wi.max.z += g, Wi.min.x -= g, Wi.min.y -= g, Wi.min.z -= g, e.ray.intersectsBox(Wi) !== !1) {
      s.at(1, fi), fi.w = 1, fi.applyMatrix4(o.matrixWorldInverse), fi.applyMatrix4(a), fi.multiplyScalar(1 / fi.w), fi.x *= d.x / 2, fi.y *= d.y / 2, fi.z = 0, ku.copy(fi), Wu.multiplyMatrices(o.matrixWorldInverse, l);
      for (let T = 0, E = p.count; T < E; T++) {
        Ot.fromBufferAttribute(p, T), Ft.fromBufferAttribute(f, T), Ot.w = 1, Ft.w = 1, Ot.applyMatrix4(Wu), Ft.applyMatrix4(Wu);
        var S = Ot.z > m && Ft.z > m;
        if (S)
          continue;
        if (Ot.z > m) {
          const le = Ot.z - Ft.z, B = (Ot.z - m) / le;
          Ot.lerp(Ft, B);
        } else if (Ft.z > m) {
          const le = Ft.z - Ot.z, B = (Ft.z - m) / le;
          Ft.lerp(Ot, B);
        }
        Ot.applyMatrix4(a), Ft.applyMatrix4(a), Ot.multiplyScalar(1 / Ot.w), Ft.multiplyScalar(1 / Ft.w), Ot.x *= d.x / 2, Ot.y *= d.y / 2, Ft.x *= d.x / 2, Ft.y *= d.y / 2, Rn.start.copy(Ot), Rn.start.z = 0, Rn.end.copy(Ft), Rn.end.z = 0;
        const w = Rn.closestPointToPointParameter(ku, !0);
        Rn.at(w, eg);
        const C = tE.lerp(Ot.z, Ft.z, w), ee = C >= -1 && C <= 1, Y = ku.distanceTo(eg) < u * 0.5;
        if (ee && Y) {
          Rn.start.fromBufferAttribute(p, T), Rn.end.fromBufferAttribute(f, T), Rn.start.applyMatrix4(l), Rn.end.applyMatrix4(l);
          const le = new Uo(), B = new Uo();
          s.distanceSqToSegment(Rn.start, Rn.end, B, le), n.push({
            point: B,
            pointOnLine: le,
            distance: s.origin.distanceTo(B),
            object: this,
            face: null,
            faceIndex: T,
            uv: null,
            uv2: null
          });
        }
      }
    }
  }
};
$y.prototype.isLineSegments2 = !0;
let jy = class extends $y {
  constructor(e = new np(), n = new Ol({ color: Math.random() * 16777215 })) {
    super(e, n), this.type = "Line2";
  }
};
jy.prototype.isLine2 = !0;
var ds;
let Zi = (ds = class extends iu {
  constructor(n, r) {
    super();
    Ue(this, "type", "Line");
    this.vectors = n, r && r.material ? this.material = r.material : this.material = ds.material, this.update(), this.model.userData = this;
  }
  flattenVectors(n) {
    let r = [];
    for (let [s, o, a] of n) r.push(s, o, a);
    return r;
  }
  localizeVectors(n) {
    let r = [0, 0, 0], s = new z(n[0], n[1], n[2]);
    for (let o = 3; o < n.length; o += 3) {
      let a = new z(n[o], n[o + 1], n[o + 2]);
      a = a.clone().sub(s).toArray(), r.push(a[0], a[1], a[2]);
    }
    return r;
  }
  update() {
    let n = this.localizeVectors(this.flattenVectors(this.vectors)), r = new np();
    r.setPositions(n), this.model ? (this.model.geometry.dispose(), this.model.material.dispose(), this.model.geometry = r) : (this.model = new jy(r, this.material), this.model.computeLineDistances(), this.model.scale.set(1, 1, 1), this.model.position.set(...this.vectors[0]));
  }
}, Ue(ds, "material", new Ol({
  color: 16711680,
  linewidth: 3,
  resolution: new ye(1e3, 1e3),
  dashed: !1,
  depthTest: !0,
  depthWrite: !0
})), ds);
const sE = ep, oE = ti, aE = oi, qy = z;
new qy();
new sE();
new oE();
new qy();
new aE();
function lE(t, e, n = 2) {
  const r = e && e.length, s = r ? e[0] * n : t.length;
  let o = Xy(t, 0, s, n, !0);
  const a = [];
  if (!o || o.next === o.prev) return a;
  let l, c, h;
  if (r && (o = fE(t, e, o, n)), t.length > 80 * n) {
    l = 1 / 0, c = 1 / 0;
    let d = -1 / 0, u = -1 / 0;
    for (let p = n; p < s; p += n) {
      const f = t[p], m = t[p + 1];
      f < l && (l = f), m < c && (c = m), f > d && (d = f), m > u && (u = m);
    }
    h = Math.max(d - l, u - c), h = h !== 0 ? 32767 / h : 0;
  }
  return dl(o, a, n, l, c, h, 0), a;
}
function Xy(t, e, n, r, s) {
  let o;
  if (s === SE(t, e, n, r) > 0)
    for (let a = e; a < n; a += r) o = ng(a / r | 0, t[a], t[a + 1], o);
  else
    for (let a = n - r; a >= e; a -= r) o = ng(a / r | 0, t[a], t[a + 1], o);
  return o && Ho(o, o.next) && (pl(o), o = o.next), o;
}
function _s(t, e) {
  if (!t) return t;
  e || (e = t);
  let n = t, r;
  do
    if (r = !1, !n.steiner && (Ho(n, n.next) || Mt(n.prev, n, n.next) === 0)) {
      if (pl(n), n = e = n.prev, n === n.next) break;
      r = !0;
    } else
      n = n.next;
  while (r || n !== e);
  return e;
}
function dl(t, e, n, r, s, o, a) {
  if (!t) return;
  !a && o && yE(t, r, s, o);
  let l = t;
  for (; t.prev !== t.next; ) {
    const c = t.prev, h = t.next;
    if (o ? hE(t, r, s, o) : cE(t)) {
      e.push(c.i, t.i, h.i), pl(t), t = h.next, l = h.next;
      continue;
    }
    if (t = h, t === l) {
      a ? a === 1 ? (t = uE(_s(t), e), dl(t, e, n, r, s, o, 2)) : a === 2 && dE(t, e, n, r, s, o) : dl(_s(t), e, n, r, s, o, 1);
      break;
    }
  }
}
function cE(t) {
  const e = t.prev, n = t, r = t.next;
  if (Mt(e, n, r) >= 0) return !1;
  const s = e.x, o = n.x, a = r.x, l = e.y, c = n.y, h = r.y, d = Math.min(s, o, a), u = Math.min(l, c, h), p = Math.max(s, o, a), f = Math.max(l, c, h);
  let m = r.next;
  for (; m !== e; ) {
    if (m.x >= d && m.x <= p && m.y >= u && m.y <= f && Ca(s, l, o, c, a, h, m.x, m.y) && Mt(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function hE(t, e, n, r) {
  const s = t.prev, o = t, a = t.next;
  if (Mt(s, o, a) >= 0) return !1;
  const l = s.x, c = o.x, h = a.x, d = s.y, u = o.y, p = a.y, f = Math.min(l, c, h), m = Math.min(d, u, p), y = Math.max(l, c, h), x = Math.max(d, u, p), v = rf(f, m, e, n, r), g = rf(y, x, e, n, r);
  let S = t.prevZ, T = t.nextZ;
  for (; S && S.z >= v && T && T.z <= g; ) {
    if (S.x >= f && S.x <= y && S.y >= m && S.y <= x && S !== s && S !== a && Ca(l, d, c, u, h, p, S.x, S.y) && Mt(S.prev, S, S.next) >= 0 || (S = S.prevZ, T.x >= f && T.x <= y && T.y >= m && T.y <= x && T !== s && T !== a && Ca(l, d, c, u, h, p, T.x, T.y) && Mt(T.prev, T, T.next) >= 0)) return !1;
    T = T.nextZ;
  }
  for (; S && S.z >= v; ) {
    if (S.x >= f && S.x <= y && S.y >= m && S.y <= x && S !== s && S !== a && Ca(l, d, c, u, h, p, S.x, S.y) && Mt(S.prev, S, S.next) >= 0) return !1;
    S = S.prevZ;
  }
  for (; T && T.z <= g; ) {
    if (T.x >= f && T.x <= y && T.y >= m && T.y <= x && T !== s && T !== a && Ca(l, d, c, u, h, p, T.x, T.y) && Mt(T.prev, T, T.next) >= 0) return !1;
    T = T.nextZ;
  }
  return !0;
}
function uE(t, e) {
  let n = t;
  do {
    const r = n.prev, s = n.next.next;
    !Ho(r, s) && Zy(r, n, n.next, s) && fl(r, s) && fl(s, r) && (e.push(r.i, n.i, s.i), pl(n), pl(n.next), n = t = s), n = n.next;
  } while (n !== t);
  return _s(n);
}
function dE(t, e, n, r, s, o) {
  let a = t;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && bE(a, l)) {
        let c = Jy(a, l);
        a = _s(a, a.next), c = _s(c, c.next), dl(a, e, n, r, s, o, 0), dl(c, e, n, r, s, o, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== t);
}
function fE(t, e, n, r) {
  const s = [];
  for (let o = 0, a = e.length; o < a; o++) {
    const l = e[o] * r, c = o < a - 1 ? e[o + 1] * r : t.length, h = Xy(t, l, c, r, !1);
    h === h.next && (h.steiner = !0), s.push(_E(h));
  }
  s.sort(pE);
  for (let o = 0; o < s.length; o++)
    n = mE(s[o], n);
  return n;
}
function pE(t, e) {
  let n = t.x - e.x;
  if (n === 0 && (n = t.y - e.y, n === 0)) {
    const r = (t.next.y - t.y) / (t.next.x - t.x), s = (e.next.y - e.y) / (e.next.x - e.x);
    n = r - s;
  }
  return n;
}
function mE(t, e) {
  const n = gE(t, e);
  if (!n)
    return e;
  const r = Jy(n, t);
  return _s(r, r.next), _s(n, n.next);
}
function gE(t, e) {
  let n = e;
  const r = t.x, s = t.y;
  let o = -1 / 0, a;
  if (Ho(t, n)) return n;
  do {
    if (Ho(t, n.next)) return n.next;
    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
      const u = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (u <= r && u > o && (o = u, a = n.x < n.next.x ? n : n.next, u === r))
        return a;
    }
    n = n.next;
  } while (n !== e);
  if (!a) return null;
  const l = a, c = a.x, h = a.y;
  let d = 1 / 0;
  n = a;
  do {
    if (r >= n.x && n.x >= c && r !== n.x && Yy(s < h ? r : o, s, c, h, s < h ? o : r, s, n.x, n.y)) {
      const u = Math.abs(s - n.y) / (r - n.x);
      fl(n, t) && (u < d || u === d && (n.x > a.x || n.x === a.x && vE(a, n))) && (a = n, d = u);
    }
    n = n.next;
  } while (n !== l);
  return a;
}
function vE(t, e) {
  return Mt(t.prev, t, e.prev) < 0 && Mt(e.next, t, t.next) < 0;
}
function yE(t, e, n, r) {
  let s = t;
  do
    s.z === 0 && (s.z = rf(s.x, s.y, e, n, r)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== t);
  s.prevZ.nextZ = null, s.prevZ = null, xE(s);
}
function xE(t) {
  let e, n = 1;
  do {
    let r = t, s;
    t = null;
    let o = null;
    for (e = 0; r; ) {
      e++;
      let a = r, l = 0;
      for (let h = 0; h < n && (l++, a = a.nextZ, !!a); h++)
        ;
      let c = n;
      for (; l > 0 || c > 0 && a; )
        l !== 0 && (c === 0 || !a || r.z <= a.z) ? (s = r, r = r.nextZ, l--) : (s = a, a = a.nextZ, c--), o ? o.nextZ = s : t = s, s.prevZ = o, o = s;
      r = a;
    }
    o.nextZ = null, n *= 2;
  } while (e > 1);
  return t;
}
function rf(t, e, n, r, s) {
  return t = (t - n) * s | 0, e = (e - r) * s | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1;
}
function _E(t) {
  let e = t, n = t;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== t);
  return n;
}
function Yy(t, e, n, r, s, o, a, l) {
  return (s - a) * (e - l) >= (t - a) * (o - l) && (t - a) * (r - l) >= (n - a) * (e - l) && (n - a) * (o - l) >= (s - a) * (r - l);
}
function Ca(t, e, n, r, s, o, a, l) {
  return !(t === a && e === l) && Yy(t, e, n, r, s, o, a, l);
}
function bE(t, e) {
  return t.next.i !== e.i && t.prev.i !== e.i && !wE(t, e) && // dones't intersect other edges
  (fl(t, e) && fl(e, t) && ME(t, e) && // locally visible
  (Mt(t.prev, t, e.prev) || Mt(t, e.prev, e)) || // does not create opposite-facing sectors
  Ho(t, e) && Mt(t.prev, t, t.next) > 0 && Mt(e.prev, e, e.next) > 0);
}
function Mt(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function Ho(t, e) {
  return t.x === e.x && t.y === e.y;
}
function Zy(t, e, n, r) {
  const s = Mc(Mt(t, e, n)), o = Mc(Mt(t, e, r)), a = Mc(Mt(n, r, t)), l = Mc(Mt(n, r, e));
  return !!(s !== o && a !== l || s === 0 && wc(t, n, e) || o === 0 && wc(t, r, e) || a === 0 && wc(n, t, r) || l === 0 && wc(n, e, r));
}
function wc(t, e, n) {
  return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
}
function Mc(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function wE(t, e) {
  let n = t;
  do {
    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Zy(n, n.next, t, e)) return !0;
    n = n.next;
  } while (n !== t);
  return !1;
}
function fl(t, e) {
  return Mt(t.prev, t, t.next) < 0 ? Mt(t, e, t.next) >= 0 && Mt(t, t.prev, e) >= 0 : Mt(t, e, t.prev) < 0 || Mt(t, t.next, e) < 0;
}
function ME(t, e) {
  let n = t, r = !1;
  const s = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && s < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next;
  while (n !== t);
  return r;
}
function Jy(t, e) {
  const n = sf(t.i, t.x, t.y), r = sf(e.i, e.x, e.y), s = t.next, o = e.prev;
  return t.next = e, e.prev = t, n.next = s, s.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r;
}
function ng(t, e, n, r) {
  const s = sf(t, e, n);
  return r ? (s.next = r.next, s.prev = r, r.next.prev = s, r.next = s) : (s.prev = s, s.next = s), s;
}
function pl(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function sf(t, e, n) {
  return {
    i: t,
    // vertex index in coordinates array
    x: e,
    y: n,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function SE(t, e, n, r) {
  let s = 0;
  for (let o = e, a = n - r; o < n; o += r)
    s += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
  return s;
}
function EE(t) {
  const e = [], n = [], r = t[0][0].length;
  let s = 0, o = 0;
  for (const a of t) {
    for (const l of a)
      for (let c = 0; c < r; c++) e.push(l[c]);
    o && (s += o, n.push(s)), o = a.length;
  }
  return { vertices: e, holes: n, dimensions: r };
}
const jh = class jh extends iu {
  constructor(n, r) {
    super();
    Ue(this, "type", "Polygon");
    Ue(this, "vectors", []);
    Ue(this, "holes", []);
    this.vectors = n[0], this.holes = this.getHoles(n), r && r.material ? this.material = r.material : this.material = jh.material, this.model = new Tt(this.generateGeometry(n), this.material), this.model.position.set(n[0][0][0], n[0][0][1], n[0][0][2]), this.model.userData = this;
  }
  getHoles(n) {
    let r = [];
    for (let s = 1; s < n.length; s++) r.push(n[s]);
    return r;
  }
  localizeVectors(n) {
    let r = new z(n[0][0][0], n[0][0][1], n[0][0][2]), s = [];
    for (let o = 0; o < n.length; o++) {
      let a = n[o];
      s.push([]);
      for (let l = 0; l < a.length; l++) {
        let [c, h, d] = a[l], u = new z(c, h, d);
        u = u.sub(r).toArray(), s[o].push(u);
      }
    }
    return s;
  }
  generateGeometry(n) {
    let r = this.localizeVectors(n), s = EE(r), o = lE(s.vertices, s.holes, s.dimensions), a = new cn();
    for (let l = 0; l < s.vertices.length; l += 3)
      a.vertices.push(new z(s.vertices[l], s.vertices[l + 1], s.vertices[l + 2]));
    for (let l = 0; l < o.length; l += 3)
      a.faces.push(new gh(o[l], o[l + 1], o[l + 2]));
    return a.computeFaceNormals(), a;
  }
  update() {
    let n = this.generateGeometry([this.vectors, ...this.holes]);
    this.model.geometry.dispose(), this.model.geometry = n, this.model.position.set(this.vectors[0][0], this.vectors[0][1], this.vectors[0][2]);
  }
};
Ue(jh, "material", new Fn({ color: "purple", side: Zo }));
let Dn = jh;
class Fr extends iu {
  constructor(n) {
    super();
    Ue(this, "type", "Point");
    this.vectors = n;
  }
}
let Go = class extends nu {
  constructor(n) {
    super(n);
    Ue(this, "visible", !0);
    Ue(this, "geometries", []);
    Ue(this, "models", []);
    Ue(this, "points", []);
    // TODO: maybe make the point a nice round image?
    Ue(this, "pointscloud", new Ro(new it(), new li({ color: "#C41E3A", size: 0.5, sizeAttenuation: !0 })));
    Ue(this, "pointvertices", []);
    Ue(this, "type", "GeometryLayer");
    this.geometries = n.geometries;
    for (let r of this.geometries) this.add(r);
  }
  updatePoints() {
    this.pointvertices = [], this.points = [];
    let n = [], r = !0;
    for (let s of this.geometries)
      if (s instanceof Fr) {
        r == !0 && (n = s.vectors, r = !1);
        let o = [s.vectors[0] - n[0], s.vectors[1] - n[1], s.vectors[2] - n[2]];
        this.points.push(s), this.pointvertices.push(...o);
      }
    Ce.scene.scene.remove(this.pointscloud), this.pointvertices.length > 0 ? (this.pointscloud.geometry.setAttribute("position", new Ke(this.pointvertices, 3)), this.pointscloud.geometry.setDrawRange(0, this.pointvertices.length), this.pointscloud.geometry.verticesNeedUpdate = !0, this.pointscloud.geometry.computeBoundingSphere(), this.pointscloud.position.set(...n), Ce.scene.scene.add(this.pointscloud)) : (this.pointscloud.geometry.dispose(), this.pointscloud.material.dispose());
  }
  async attach() {
    for (let n of this.geometries) this.add(n);
    this.attached = !0;
  }
  detach() {
    for (let n of this.geometries) this.remove(n);
    this.attached = !1;
  }
  add(n) {
    this.attached && this.geometries.push(n), n instanceof Zi || n instanceof Dn ? (this.models.push(n.model), Ce.scene.scene.add(n.model)) : n instanceof Fr && (this.points.push(n), this.updatePoints());
  }
  remove(n) {
    if ((n instanceof Zi || n instanceof Dn) && this.geometries.indexOf(n) > -1) {
      let r = this.geometries.indexOf(n);
      Ce.scene.scene.remove(this.models[r]), this.models.splice(r, 1), this.geometries.splice(r, 1);
    }
  }
  updateVisibility() {
    for (let n of this.models) n.visible = this.visible;
  }
  show() {
    this.visible = !0, this.updateVisibility();
  }
  hide() {
    this.visible = !1, this.updateVisibility();
  }
  bbox() {
    let n = new kt();
    for (let r of this.geometries)
      if (r instanceof Zi)
        for (let s of r.vectors)
          n.expandByPoint(new z(...s));
      else if (r instanceof Dn)
        for (let s of r.vectors)
          n.expandByPoint(new z(...s));
      else r instanceof Fr && n.expandByPoint(new z(r.vectors));
    return n;
  }
};
class TE extends nu {
  constructor(n) {
    super(n);
    Ue(this, "overlays", []);
    Ue(this, "models", []);
    Ue(this, "UseVisibilityDistance", !0);
    Ue(this, "attached", !1);
    Ue(this, "type", "OverlayLayer");
    n && n.overlays && (this.overlays = n.overlays);
  }
  async attach() {
    for (let n of this.overlays) this.add(n);
    this.attached = !0;
  }
  detach() {
    for (let n of this.overlays) this.remove(n);
    this.attached = !1;
  }
  async add(n) {
    this.attached && this.overlays.push(n), n.attachToScene(), this.models.push(n.model), this.updateVisibility();
  }
  remove(n) {
    n.removeFromScene(), this.overlays.indexOf(n) != -1 && this.overlays.splice(this.overlays.indexOf(n), 1), this.models.indexOf(n.model) != -1 && this.models.splice(this.models.indexOf(n.model), 1);
  }
  updateVisibility() {
    for (let n of this.models) n.visible = this.visible;
  }
  show() {
    this.visible = !0, this.updateVisibility();
  }
  hide() {
    this.visible = !1, this.updateVisibility();
  }
  bbox() {
    let n = new kt();
    for (let r of this.overlays)
      for (let s of r.vectors)
        n.expandByPoint(new z(...s));
    return n;
  }
}
const AE = Pn, LE = xh, CE = kt, ig = We, RE = it, PE = rl, IE = an, xr = Ne, DE = Qd, NE = Zo, rg = Si, OE = Pl, $u = us, FE = tf, BE = xn, zE = wi, sg = wn, UE = Za, og = Fa, HE = Wr, GE = un, VE = Fd, kE = nl, ag = Ht, lg = Il, WE = hy, cg = dt, ma = Ny, hg = Ve, $E = $e, ug = Je, jE = Tt, ga = Fn, dg = jr, va = Mi, qE = dh, XE = qt, YE = Ed, ZE = Sd, JE = Fo, KE = He, QE = Th, eT = Nt, tT = Jd, nT = Ro, iT = li, rT = Zt, sT = cl, oT = Dr, ju = uh, aT = _h, lT = yh, cT = hi, hT = Yd, uT = As, dT = Eh, fg = c_, fT = l_, pg = ye, Sc = z, pT = Bo, mg = qf;
var mT = function() {
  function t(I) {
    cg.call(this, I), this.dracoLoader = null, this.ddsLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(L) {
      return new a(L);
    }), this.register(function(L) {
      return new c(L);
    }), this.register(function(L) {
      return new h(L);
    }), this.register(function(L) {
      return new l(L);
    }), this.register(function(L) {
      return new s(L);
    }), this.register(function(L) {
      return new d(L);
    });
  }
  t.prototype = Object.assign(Object.create(cg.prototype), {
    constructor: t,
    load: function(I, L, U, N) {
      var V = this, W;
      this.resourcePath !== "" ? W = this.resourcePath : this.path !== "" ? W = this.path : W = ma.extractUrlBase(I), this.manager.itemStart(I);
      var R = function(H) {
        N ? N(H) : console.error(H), V.manager.itemError(I), V.manager.itemEnd(I);
      }, D = new rg(this.manager);
      D.setPath(this.path), D.setResponseType("arraybuffer"), D.setRequestHeader(this.requestHeader), D.setWithCredentials(this.withCredentials), D.load(I, function(H) {
        try {
          V.parse(H, W, function(ne) {
            L(ne), V.manager.itemEnd(I);
          }, R);
        } catch (ne) {
          R(ne);
        }
      }, U, R);
    },
    setDRACOLoader: function(I) {
      return this.dracoLoader = I, this;
    },
    setDDSLoader: function(I) {
      return this.ddsLoader = I, this;
    },
    setKTX2Loader: function(I) {
      return this.ktx2Loader = I, this;
    },
    setMeshoptDecoder: function(I) {
      return this.meshoptDecoder = I, this;
    },
    register: function(I) {
      return this.pluginCallbacks.indexOf(I) === -1 && this.pluginCallbacks.push(I), this;
    },
    unregister: function(I) {
      return this.pluginCallbacks.indexOf(I) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(I), 1), this;
    },
    parse: function(I, L, U, N) {
      var V, W = {}, R = {};
      if (typeof I == "string")
        V = I;
      else {
        var D = ma.decodeText(new Uint8Array(I, 0, 4));
        if (D === u) {
          try {
            W[n.KHR_BINARY_GLTF] = new m(I);
          } catch (X) {
            N && N(X);
            return;
          }
          V = W[n.KHR_BINARY_GLTF].content;
        } else
          V = ma.decodeText(new Uint8Array(I));
      }
      var H = JSON.parse(V);
      if (H.asset === void 0 || H.asset.version[0] < 2) {
        N && N(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      var ne = new ge(H, {
        path: L || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      ne.fileLoader.setRequestHeader(this.requestHeader);
      for (var J = 0; J < this.pluginCallbacks.length; J++) {
        var b = this.pluginCallbacks[J](ne);
        R[b.name] = b, W[b.name] = !0;
      }
      if (H.extensionsUsed)
        for (var J = 0; J < H.extensionsUsed.length; ++J) {
          var _ = H.extensionsUsed[J], Q = H.extensionsRequired || [];
          switch (_) {
            case n.KHR_MATERIALS_UNLIT:
              W[_] = new o();
              break;
            case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              W[_] = new g();
              break;
            case n.KHR_DRACO_MESH_COMPRESSION:
              W[_] = new y(H, this.dracoLoader);
              break;
            case n.MSFT_TEXTURE_DDS:
              W[_] = new r(this.ddsLoader);
              break;
            case n.KHR_TEXTURE_TRANSFORM:
              W[_] = new x();
              break;
            case n.KHR_MESH_QUANTIZATION:
              W[_] = new S();
              break;
            default:
              Q.indexOf(_) >= 0 && R[_] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + _ + '".');
          }
        }
      ne.setExtensions(W), ne.setPlugins(R), ne.parse(U, N);
    }
  });
  function e() {
    var I = {};
    return {
      get: function(L) {
        return I[L];
      },
      add: function(L, U) {
        I[L] = U;
      },
      remove: function(L) {
        delete I[L];
      },
      removeAll: function() {
        I = {};
      }
    };
  }
  var n = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    MSFT_TEXTURE_DDS: "MSFT_texture_dds"
  };
  function r(I) {
    if (!I)
      throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
    this.name = n.MSFT_TEXTURE_DDS, this.ddsLoader = I;
  }
  function s(I) {
    this.parser = I, this.name = n.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  s.prototype._markDefs = function() {
    for (var I = this.parser, L = this.parser.json.nodes || [], U = 0, N = L.length; U < N; U++) {
      var V = L[U];
      V.extensions && V.extensions[this.name] && V.extensions[this.name].light !== void 0 && I._addNodeRef(this.cache, V.extensions[this.name].light);
    }
  }, s.prototype._loadLight = function(I) {
    var L = this.parser, U = "light:" + I, N = L.cache.get(U);
    if (N) return N;
    var V = L.json, W = V.extensions && V.extensions[this.name] || {}, R = W.lights || [], D = R[I], H, ne = new xr(16777215);
    D.color !== void 0 && ne.fromArray(D.color);
    var J = D.range !== void 0 ? D.range : 0;
    switch (D.type) {
      case "directional":
        H = new DE(ne), H.target.position.set(0, 0, -1), H.add(H.target);
        break;
      case "point":
        H = new tT(ne), H.distance = J;
        break;
      case "spot":
        H = new hT(ne), H.distance = J, D.spot = D.spot || {}, D.spot.innerConeAngle = D.spot.innerConeAngle !== void 0 ? D.spot.innerConeAngle : 0, D.spot.outerConeAngle = D.spot.outerConeAngle !== void 0 ? D.spot.outerConeAngle : Math.PI / 4, H.angle = D.spot.outerConeAngle, H.penumbra = 1 - D.spot.innerConeAngle / D.spot.outerConeAngle, H.target.position.set(0, 0, -1), H.add(H.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + D.type);
    }
    return H.position.set(0, 0, 0), H.decay = 2, D.intensity !== void 0 && (H.intensity = D.intensity), H.name = L.createUniqueName(D.name || "light_" + I), N = Promise.resolve(H), L.cache.add(U, N), N;
  }, s.prototype.createNodeAttachment = function(I) {
    var L = this, U = this.parser, N = U.json, V = N.nodes[I], W = V.extensions && V.extensions[this.name] || {}, R = W.light;
    return R === void 0 ? null : this._loadLight(R).then(function(D) {
      return U._getNodeRef(L.cache, R, D);
    });
  };
  function o() {
    this.name = n.KHR_MATERIALS_UNLIT;
  }
  o.prototype.getMaterialType = function() {
    return ga;
  }, o.prototype.extendParams = function(I, L, U) {
    var N = [];
    I.color = new xr(1, 1, 1), I.opacity = 1;
    var V = L.pbrMetallicRoughness;
    if (V) {
      if (Array.isArray(V.baseColorFactor)) {
        var W = V.baseColorFactor;
        I.color.fromArray(W), I.opacity = W[3];
      }
      V.baseColorTexture !== void 0 && N.push(U.assignTexture(I, "map", V.baseColorTexture));
    }
    return Promise.all(N);
  };
  function a(I) {
    this.parser = I, this.name = n.KHR_MATERIALS_CLEARCOAT;
  }
  a.prototype.getMaterialType = function(I) {
    var L = this.parser, U = L.json.materials[I];
    return !U.extensions || !U.extensions[this.name] ? null : dg;
  }, a.prototype.extendMaterialParams = function(I, L) {
    var U = this.parser, N = U.json.materials[I];
    if (!N.extensions || !N.extensions[this.name])
      return Promise.resolve();
    var V = [], W = N.extensions[this.name];
    if (W.clearcoatFactor !== void 0 && (L.clearcoat = W.clearcoatFactor), W.clearcoatTexture !== void 0 && V.push(U.assignTexture(L, "clearcoatMap", W.clearcoatTexture)), W.clearcoatRoughnessFactor !== void 0 && (L.clearcoatRoughness = W.clearcoatRoughnessFactor), W.clearcoatRoughnessTexture !== void 0 && V.push(U.assignTexture(L, "clearcoatRoughnessMap", W.clearcoatRoughnessTexture)), W.clearcoatNormalTexture !== void 0 && (V.push(U.assignTexture(L, "clearcoatNormalMap", W.clearcoatNormalTexture)), W.clearcoatNormalTexture.scale !== void 0)) {
      var R = W.clearcoatNormalTexture.scale;
      L.clearcoatNormalScale = new pg(R, R);
    }
    return Promise.all(V);
  };
  function l(I) {
    this.parser = I, this.name = n.KHR_MATERIALS_TRANSMISSION;
  }
  l.prototype.getMaterialType = function(I) {
    var L = this.parser, U = L.json.materials[I];
    return !U.extensions || !U.extensions[this.name] ? null : dg;
  }, l.prototype.extendMaterialParams = function(I, L) {
    var U = this.parser, N = U.json.materials[I];
    if (!N.extensions || !N.extensions[this.name])
      return Promise.resolve();
    var V = [], W = N.extensions[this.name];
    return W.transmissionFactor !== void 0 && (L.transmission = W.transmissionFactor), W.transmissionTexture !== void 0 && V.push(U.assignTexture(L, "transmissionMap", W.transmissionTexture)), Promise.all(V);
  };
  function c(I) {
    this.parser = I, this.name = n.KHR_TEXTURE_BASISU;
  }
  c.prototype.loadTexture = function(I) {
    var L = this.parser, U = L.json, N = U.textures[I];
    if (!N.extensions || !N.extensions[this.name])
      return null;
    var V = N.extensions[this.name], W = U.images[V.source], R = L.options.ktx2Loader;
    if (!R) {
      if (U.extensionsRequired && U.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return L.loadTextureImage(I, W, R);
  };
  function h(I) {
    this.parser = I, this.name = n.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  h.prototype.loadTexture = function(I) {
    var L = this.name, U = this.parser, N = U.json, V = N.textures[I];
    if (!V.extensions || !V.extensions[L])
      return null;
    var W = V.extensions[L], R = N.images[W.source], D = R.uri ? U.options.manager.getHandler(R.uri) : U.textureLoader;
    return this.detectSupport().then(function(H) {
      if (H) return U.loadTextureImage(I, R, D);
      if (N.extensionsRequired && N.extensionsRequired.indexOf(L) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return U.loadTexture(I);
    });
  }, h.prototype.detectSupport = function() {
    return this.isSupported || (this.isSupported = new Promise(function(I) {
      var L = new Image();
      L.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", L.onload = L.onerror = function() {
        I(L.height === 1);
      };
    })), this.isSupported;
  };
  function d(I) {
    this.name = n.EXT_MESHOPT_COMPRESSION, this.parser = I;
  }
  d.prototype.loadBufferView = function(I) {
    var L = this.parser.json, U = L.bufferViews[I];
    if (U.extensions && U.extensions[this.name]) {
      var N = U.extensions[this.name], V = this.parser.getDependency("buffer", N.buffer), W = this.parser.options.meshoptDecoder;
      if (!W || !W.supported) {
        if (L.extensionsRequired && L.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return Promise.all([V, W.ready]).then(function(R) {
        var D = N.byteOffset || 0, H = N.byteLength || 0, ne = N.count, J = N.byteStride, b = new ArrayBuffer(ne * J), _ = new Uint8Array(R[0], D, H);
        return W.decodeGltfBuffer(new Uint8Array(b), ne, J, _, N.mode, N.filter), b;
      });
    } else
      return null;
  };
  var u = "glTF", p = 12, f = { JSON: 1313821514, BIN: 5130562 };
  function m(I) {
    this.name = n.KHR_BINARY_GLTF, this.content = null, this.body = null;
    var L = new DataView(I, 0, p);
    if (this.header = {
      magic: ma.decodeText(new Uint8Array(I.slice(0, 4))),
      version: L.getUint32(4, !0),
      length: L.getUint32(8, !0)
    }, this.header.magic !== u)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    for (var U = new DataView(I, p), N = 0; N < U.byteLength; ) {
      var V = U.getUint32(N, !0);
      N += 4;
      var W = U.getUint32(N, !0);
      if (N += 4, W === f.JSON) {
        var R = new Uint8Array(I, p + N, V);
        this.content = ma.decodeText(R);
      } else if (W === f.BIN) {
        var D = p + N;
        this.body = I.slice(D, D + V);
      }
      N += V;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
  function y(I, L) {
    if (!L)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = n.KHR_DRACO_MESH_COMPRESSION, this.json = I, this.dracoLoader = L, this.dracoLoader.preload();
  }
  y.prototype.decodePrimitive = function(I, L) {
    var U = this.json, N = this.dracoLoader, V = I.extensions[this.name].bufferView, W = I.extensions[this.name].attributes, R = {}, D = {}, H = {};
    for (var ne in W) {
      var J = le[ne] || ne.toLowerCase();
      R[J] = W[ne];
    }
    for (ne in I.attributes) {
      var J = le[ne] || ne.toLowerCase();
      if (W[ne] !== void 0) {
        var b = U.accessors[I.attributes[ne]], _ = w[b.componentType];
        H[J] = _, D[J] = b.normalized === !0;
      }
    }
    return L.getDependency("bufferView", V).then(function(Q) {
      return new Promise(function(X) {
        N.decodeDracoFile(Q, function(A) {
          for (var ie in A.attributes) {
            var oe = A.attributes[ie], he = D[ie];
            he !== void 0 && (oe.normalized = he);
          }
          X(A);
        }, R, H);
      });
    });
  };
  function x() {
    this.name = n.KHR_TEXTURE_TRANSFORM;
  }
  x.prototype.extendTexture = function(I, L) {
    return I = I.clone(), L.offset !== void 0 && I.offset.fromArray(L.offset), L.rotation !== void 0 && (I.rotation = L.rotation), L.scale !== void 0 && I.repeat.fromArray(L.scale), L.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), I.needsUpdate = !0, I;
  };
  function v(I) {
    va.call(this), this.isGLTFSpecularGlossinessMaterial = !0;
    var L = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join(`
`), U = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join(`
`), N = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join(`
`), V = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join(`
`), W = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.specularRoughness += geometryRoughness;",
      "material.specularRoughness = min( material.specularRoughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join(`
`), R = {
      specular: { value: new xr().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null }
    };
    this._extraUniforms = R, this.onBeforeCompile = function(D) {
      for (var H in R)
        D.uniforms[H] = R[H];
      D.fragmentShader = D.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", L).replace("#include <metalnessmap_pars_fragment>", U).replace("#include <roughnessmap_fragment>", N).replace("#include <metalnessmap_fragment>", V).replace("#include <lights_physical_fragment>", W);
    }, Object.defineProperties(this, {
      specular: {
        get: function() {
          return R.specular.value;
        },
        set: function(D) {
          R.specular.value = D;
        }
      },
      specularMap: {
        get: function() {
          return R.specularMap.value;
        },
        set: function(D) {
          R.specularMap.value = D, D ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
        }
      },
      glossiness: {
        get: function() {
          return R.glossiness.value;
        },
        set: function(D) {
          R.glossiness.value = D;
        }
      },
      glossinessMap: {
        get: function() {
          return R.glossinessMap.value;
        },
        set: function(D) {
          R.glossinessMap.value = D, D ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
        }
      }
    }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(I);
  }
  v.prototype = Object.create(va.prototype), v.prototype.constructor = v, v.prototype.copy = function(I) {
    return va.prototype.copy.call(this, I), this.specularMap = I.specularMap, this.specular.copy(I.specular), this.glossinessMap = I.glossinessMap, this.glossiness = I.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
  };
  function g() {
    return {
      name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
      specularGlossinessParams: [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio"
      ],
      getMaterialType: function() {
        return v;
      },
      extendParams: function(I, L, U) {
        var N = L.extensions[this.name];
        I.color = new xr(1, 1, 1), I.opacity = 1;
        var V = [];
        if (Array.isArray(N.diffuseFactor)) {
          var W = N.diffuseFactor;
          I.color.fromArray(W), I.opacity = W[3];
        }
        if (N.diffuseTexture !== void 0 && V.push(U.assignTexture(I, "map", N.diffuseTexture)), I.emissive = new xr(0, 0, 0), I.glossiness = N.glossinessFactor !== void 0 ? N.glossinessFactor : 1, I.specular = new xr(1, 1, 1), Array.isArray(N.specularFactor) && I.specular.fromArray(N.specularFactor), N.specularGlossinessTexture !== void 0) {
          var R = N.specularGlossinessTexture;
          V.push(U.assignTexture(I, "glossinessMap", R)), V.push(U.assignTexture(I, "specularMap", R));
        }
        return Promise.all(V);
      },
      createMaterial: function(I) {
        var L = new v(I);
        return L.fog = !0, L.color = I.color, L.map = I.map === void 0 ? null : I.map, L.lightMap = null, L.lightMapIntensity = 1, L.aoMap = I.aoMap === void 0 ? null : I.aoMap, L.aoMapIntensity = 1, L.emissive = I.emissive, L.emissiveIntensity = 1, L.emissiveMap = I.emissiveMap === void 0 ? null : I.emissiveMap, L.bumpMap = I.bumpMap === void 0 ? null : I.bumpMap, L.bumpScale = 1, L.normalMap = I.normalMap === void 0 ? null : I.normalMap, L.normalMapType = uT, I.normalScale && (L.normalScale = I.normalScale), L.displacementMap = null, L.displacementScale = 1, L.displacementBias = 0, L.specularMap = I.specularMap === void 0 ? null : I.specularMap, L.specular = I.specular, L.glossinessMap = I.glossinessMap === void 0 ? null : I.glossinessMap, L.glossiness = I.glossiness, L.alphaMap = null, L.envMap = I.envMap === void 0 ? null : I.envMap, L.envMapIntensity = 1, L.refractionRatio = 0.98, L;
      }
    };
  }
  function S() {
    this.name = n.KHR_MESH_QUANTIZATION;
  }
  function T(I, L, U, N) {
    sg.call(this, I, L, U, N);
  }
  T.prototype = Object.create(sg.prototype), T.prototype.constructor = T, T.prototype.copySampleValue_ = function(I) {
    for (var L = this.resultBuffer, U = this.sampleValues, N = this.valueSize, V = I * N * 3 + N, W = 0; W !== N; W++)
      L[W] = U[V + W];
    return L;
  }, T.prototype.beforeStart_ = T.prototype.copySampleValue_, T.prototype.afterEnd_ = T.prototype.copySampleValue_, T.prototype.interpolate_ = function(I, L, U, N) {
    for (var V = this.resultBuffer, W = this.sampleValues, R = this.valueSize, D = R * 2, H = R * 3, ne = N - L, J = (U - L) / ne, b = J * J, _ = b * J, Q = I * H, X = Q - H, A = -2 * _ + 3 * b, ie = _ - b, oe = 1 - A, he = ie - b + J, se = 0; se !== R; se++) {
      var me = W[X + se + R], ve = W[X + se + D] * ne, be = W[Q + se + R], fe = W[Q + se] * ne;
      V[se] = oe * me + he * ve + A * be + ie * fe;
    }
    return V;
  };
  var E = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  }, w = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  }, C = {
    9728: XE,
    9729: ag,
    9984: ZE,
    9985: WE,
    9986: YE,
    9987: lg
  }, ee = {
    33071: IE,
    33648: qE,
    10497: ju
  }, Y = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  }, le = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  }, B = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  }, Z = {
    CUBICSPLINE: void 0,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: og,
    STEP: UE
  }, k = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  function O(I, L) {
    return typeof I != "string" || I === "" ? "" : (/^https?:\/\//i.test(L) && /^\//.test(I) && (L = L.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(I) || /^data:.*,.*$/i.test(I) || /^blob:.*$/i.test(I) ? I : L + I);
  }
  function P(I) {
    return I.DefaultMaterial === void 0 && (I.DefaultMaterial = new va({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: !1,
      depthTest: !0,
      side: OE
    })), I.DefaultMaterial;
  }
  function j(I, L, U) {
    for (var N in U.extensions)
      I[N] === void 0 && (L.userData.gltfExtensions = L.userData.gltfExtensions || {}, L.userData.gltfExtensions[N] = U.extensions[N]);
  }
  function re(I, L) {
    L.extras !== void 0 && (typeof L.extras == "object" ? Object.assign(I.userData, L.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + L.extras));
  }
  function ae(I, L, U) {
    for (var N = !1, V = !1, W = 0, R = L.length; W < R; W++) {
      var D = L[W];
      if (D.POSITION !== void 0 && (N = !0), D.NORMAL !== void 0 && (V = !0), N && V) break;
    }
    if (!N && !V) return Promise.resolve(I);
    for (var H = [], ne = [], W = 0, R = L.length; W < R; W++) {
      var D = L[W];
      if (N) {
        var J = D.POSITION !== void 0 ? U.getDependency("accessor", D.POSITION) : I.attributes.position;
        H.push(J);
      }
      if (V) {
        var J = D.NORMAL !== void 0 ? U.getDependency("accessor", D.NORMAL) : I.attributes.normal;
        ne.push(J);
      }
    }
    return Promise.all([
      Promise.all(H),
      Promise.all(ne)
    ]).then(function(b) {
      var _ = b[0], Q = b[1];
      return N && (I.morphAttributes.position = _), V && (I.morphAttributes.normal = Q), I.morphTargetsRelative = !0, I;
    });
  }
  function ce(I, L) {
    if (I.updateMorphTargets(), L.weights !== void 0)
      for (var U = 0, N = L.weights.length; U < N; U++)
        I.morphTargetInfluences[U] = L.weights[U];
    if (L.extras && Array.isArray(L.extras.targetNames)) {
      var V = L.extras.targetNames;
      if (I.morphTargetInfluences.length === V.length) {
        I.morphTargetDictionary = {};
        for (var U = 0, N = V.length; U < N; U++)
          I.morphTargetDictionary[V[U]] = U;
      } else
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function pe(I) {
    var L = I.extensions && I.extensions[n.KHR_DRACO_MESH_COMPRESSION], U;
    return L ? U = "draco:" + L.bufferView + ":" + L.indices + ":" + de(L.attributes) : U = I.indices + ":" + de(I.attributes) + ":" + I.mode, U;
  }
  function de(I) {
    for (var L = "", U = Object.keys(I).sort(), N = 0, V = U.length; N < V; N++)
      L += U[N] + ":" + I[U[N]] + ";";
    return L;
  }
  function ge(I, L) {
    this.json = I || {}, this.extensions = {}, this.plugins = {}, this.options = L || {}, this.cache = new e(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.nodeNamesUsed = {}, typeof createImageBitmap < "u" && /Firefox/.test(navigator.userAgent) === !1 ? this.textureLoader = new FE(this.options.manager) : this.textureLoader = new dT(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new rg(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  ge.prototype.setExtensions = function(I) {
    this.extensions = I;
  }, ge.prototype.setPlugins = function(I) {
    this.plugins = I;
  }, ge.prototype.parse = function(I, L) {
    var U = this, N = this.json, V = this.extensions;
    this.cache.removeAll(), this._invokeAll(function(W) {
      return W._markDefs && W._markDefs();
    }), Promise.all([
      this.getDependencies("scene"),
      this.getDependencies("animation"),
      this.getDependencies("camera")
    ]).then(function(W) {
      var R = {
        scene: W[0][N.scene || 0],
        scenes: W[0],
        animations: W[1],
        cameras: W[2],
        asset: N.asset,
        parser: U,
        userData: {}
      };
      j(V, R, N), re(R, N), I(R);
    }).catch(L);
  }, ge.prototype._markDefs = function() {
    for (var I = this.json.nodes || [], L = this.json.skins || [], U = this.json.meshes || [], N = 0, V = L.length; N < V; N++)
      for (var W = L[N].joints, R = 0, D = W.length; R < D; R++)
        I[W[R]].isBone = !0;
    for (var H = 0, ne = I.length; H < ne; H++) {
      var J = I[H];
      J.mesh !== void 0 && (this._addNodeRef(this.meshCache, J.mesh), J.skin !== void 0 && (U[J.mesh].isSkinnedMesh = !0)), J.camera !== void 0 && this._addNodeRef(this.cameraCache, J.camera);
    }
  }, ge.prototype._addNodeRef = function(I, L) {
    L !== void 0 && (I.refs[L] === void 0 && (I.refs[L] = I.uses[L] = 0), I.refs[L]++);
  }, ge.prototype._getNodeRef = function(I, L, U) {
    if (I.refs[L] <= 1) return U;
    var N = U.clone();
    return N.name += "_instance_" + I.uses[L]++, N;
  }, ge.prototype._invokeOne = function(I) {
    var L = Object.values(this.plugins);
    L.push(this);
    for (var U = 0; U < L.length; U++) {
      var N = I(L[U]);
      if (N) return N;
    }
  }, ge.prototype._invokeAll = function(I) {
    var L = Object.values(this.plugins);
    L.unshift(this);
    for (var U = [], N = 0; N < L.length; N++) {
      var V = I(L[N]);
      V && U.push(V);
    }
    return U;
  }, ge.prototype.getDependency = function(I, L) {
    var U = I + ":" + L, N = this.cache.get(U);
    if (!N) {
      switch (I) {
        case "scene":
          N = this.loadScene(L);
          break;
        case "node":
          N = this.loadNode(L);
          break;
        case "mesh":
          N = this._invokeOne(function(V) {
            return V.loadMesh && V.loadMesh(L);
          });
          break;
        case "accessor":
          N = this.loadAccessor(L);
          break;
        case "bufferView":
          N = this._invokeOne(function(V) {
            return V.loadBufferView && V.loadBufferView(L);
          });
          break;
        case "buffer":
          N = this.loadBuffer(L);
          break;
        case "material":
          N = this._invokeOne(function(V) {
            return V.loadMaterial && V.loadMaterial(L);
          });
          break;
        case "texture":
          N = this._invokeOne(function(V) {
            return V.loadTexture && V.loadTexture(L);
          });
          break;
        case "skin":
          N = this.loadSkin(L);
          break;
        case "animation":
          N = this.loadAnimation(L);
          break;
        case "camera":
          N = this.loadCamera(L);
          break;
        default:
          throw new Error("Unknown type: " + I);
      }
      this.cache.add(U, N);
    }
    return N;
  }, ge.prototype.getDependencies = function(I) {
    var L = this.cache.get(I);
    if (!L) {
      var U = this, N = this.json[I + (I === "mesh" ? "es" : "s")] || [];
      L = Promise.all(N.map(function(V, W) {
        return U.getDependency(I, W);
      })), this.cache.add(I, L);
    }
    return L;
  }, ge.prototype.loadBuffer = function(I) {
    var L = this.json.buffers[I], U = this.fileLoader;
    if (L.type && L.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + L.type + " buffer type is not supported.");
    if (L.uri === void 0 && I === 0)
      return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
    var N = this.options;
    return new Promise(function(V, W) {
      U.load(O(L.uri, N.path), V, void 0, function() {
        W(new Error('THREE.GLTFLoader: Failed to load buffer "' + L.uri + '".'));
      });
    });
  }, ge.prototype.loadBufferView = function(I) {
    var L = this.json.bufferViews[I];
    return this.getDependency("buffer", L.buffer).then(function(U) {
      var N = L.byteLength || 0, V = L.byteOffset || 0;
      return U.slice(V, V + N);
    });
  }, ge.prototype.loadAccessor = function(I) {
    var L = this, U = this.json, N = this.json.accessors[I];
    if (N.bufferView === void 0 && N.sparse === void 0)
      return Promise.resolve(null);
    var V = [];
    return N.bufferView !== void 0 ? V.push(this.getDependency("bufferView", N.bufferView)) : V.push(null), N.sparse !== void 0 && (V.push(this.getDependency("bufferView", N.sparse.indices.bufferView)), V.push(this.getDependency("bufferView", N.sparse.values.bufferView))), Promise.all(V).then(function(W) {
      var R = W[0], D = Y[N.type], H = w[N.componentType], ne = H.BYTES_PER_ELEMENT, J = ne * D, b = N.byteOffset || 0, _ = N.bufferView !== void 0 ? U.bufferViews[N.bufferView].byteStride : void 0, Q = N.normalized === !0, X, A;
      if (_ && _ !== J) {
        var ie = Math.floor(b / _), oe = "InterleavedBuffer:" + N.bufferView + ":" + N.componentType + ":" + ie + ":" + N.count, he = L.cache.get(oe);
        he || (X = new H(R, ie * _, N.count * _ / ne), he = new BE(X, _ / ne), L.cache.add(oe, he)), A = new zE(he, D, b % _ / ne, Q);
      } else
        R === null ? X = new H(N.count * D) : X = new H(R, b, N.count * D), A = new ig(X, D, Q);
      if (N.sparse !== void 0) {
        var se = Y.SCALAR, me = w[N.sparse.indices.componentType], ve = N.sparse.indices.byteOffset || 0, be = N.sparse.values.byteOffset || 0, fe = new me(W[1], ve, N.sparse.count * se), _e = new H(W[2], be, N.sparse.count * D);
        R !== null && (A = new ig(A.array.slice(), A.itemSize, A.normalized));
        for (var Pe = 0, rt = fe.length; Pe < rt; Pe++) {
          var dn = fe[Pe];
          if (A.setX(dn, _e[Pe * D]), D >= 2 && A.setY(dn, _e[Pe * D + 1]), D >= 3 && A.setZ(dn, _e[Pe * D + 2]), D >= 4 && A.setW(dn, _e[Pe * D + 3]), D >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return A;
    });
  }, ge.prototype.loadTexture = function(I) {
    var L = this, U = this.json, N = this.options, V = U.textures[I], W = V.extensions || {}, R;
    W[n.MSFT_TEXTURE_DDS] ? R = U.images[W[n.MSFT_TEXTURE_DDS].source] : R = U.images[V.source];
    var D;
    return R.uri && (D = N.manager.getHandler(R.uri)), D || (D = W[n.MSFT_TEXTURE_DDS] ? L.extensions[n.MSFT_TEXTURE_DDS].ddsLoader : this.textureLoader), this.loadTextureImage(I, R, D);
  }, ge.prototype.loadTextureImage = function(I, L, U) {
    var N = this, V = this.json, W = this.options, R = V.textures[I], D = self.URL || self.webkitURL, H = L.uri, ne = !1, J = !0;
    return L.mimeType === "image/jpeg" && (J = !1), L.bufferView !== void 0 && (H = N.getDependency("bufferView", L.bufferView).then(function(b) {
      if (L.mimeType === "image/png") {
        var _ = new DataView(b, 25, 1).getUint8(0, !1);
        J = _ === 6 || _ === 4 || _ === 3;
      }
      ne = !0;
      var Q = new Blob([b], { type: L.mimeType });
      return H = D.createObjectURL(Q), H;
    })), Promise.resolve(H).then(function(b) {
      return new Promise(function(_, Q) {
        var X = _;
        U.isImageBitmapLoader === !0 && (X = function(A) {
          _(new PE(A));
        }), U.load(O(b, W.path), X, void 0, Q);
      });
    }).then(function(b) {
      ne === !0 && D.revokeObjectURL(H), b.flipY = !1, R.name && (b.name = R.name), J || (b.format = oT);
      var _ = V.samplers || {}, Q = _[R.sampler] || {};
      return b.magFilter = C[Q.magFilter] || ag, b.minFilter = C[Q.minFilter] || lg, b.wrapS = ee[Q.wrapS] || ju, b.wrapT = ee[Q.wrapT] || ju, N.associations.set(b, {
        type: "textures",
        index: I
      }), b;
    });
  }, ge.prototype.assignTexture = function(I, L, U) {
    var N = this;
    return this.getDependency("texture", U.index).then(function(V) {
      if (U.texCoord !== void 0 && U.texCoord != 0 && !(L === "aoMap" && U.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + U.texCoord + " for texture " + L + " not yet supported."), N.extensions[n.KHR_TEXTURE_TRANSFORM]) {
        var W = U.extensions !== void 0 ? U.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0;
        if (W) {
          var R = N.associations.get(V);
          V = N.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(V, W), N.associations.set(V, R);
        }
      }
      I[L] = V;
    });
  }, ge.prototype.assignFinalMaterial = function(I) {
    var L = I.geometry, U = I.material, N = L.attributes.tangent !== void 0, V = L.attributes.color !== void 0, W = L.attributes.normal === void 0, R = I.isSkinnedMesh === !0, D = Object.keys(L.morphAttributes).length > 0, H = D && L.morphAttributes.normal !== void 0;
    if (I.isPoints) {
      var ne = "PointsMaterial:" + U.uuid, J = this.cache.get(ne);
      J || (J = new iT(), hg.prototype.copy.call(J, U), J.color.copy(U.color), J.map = U.map, J.sizeAttenuation = !1, this.cache.add(ne, J)), U = J;
    } else if (I.isLine) {
      var ne = "LineBasicMaterial:" + U.uuid, b = this.cache.get(ne);
      b || (b = new GE(), hg.prototype.copy.call(b, U), b.color.copy(U.color), this.cache.add(ne, b)), U = b;
    }
    if (N || V || W || R || D) {
      var ne = "ClonedMaterial:" + U.uuid + ":";
      U.isGLTFSpecularGlossinessMaterial && (ne += "specular-glossiness:"), R && (ne += "skinning:"), N && (ne += "vertex-tangents:"), V && (ne += "vertex-colors:"), W && (ne += "flat-shading:"), D && (ne += "morph-targets:"), H && (ne += "morph-normals:");
      var _ = this.cache.get(ne);
      _ || (_ = U.clone(), R && (_.skinning = !0), N && (_.vertexTangents = !0), V && (_.vertexColors = !0), W && (_.flatShading = !0), D && (_.morphTargets = !0), H && (_.morphNormals = !0), this.cache.add(ne, _), this.associations.set(_, this.associations.get(U))), U = _;
    }
    U.aoMap && L.attributes.uv2 === void 0 && L.attributes.uv !== void 0 && L.setAttribute("uv2", L.attributes.uv), U.normalScale && !N && (U.normalScale.y = -U.normalScale.y), U.clearcoatNormalScale && !N && (U.clearcoatNormalScale.y = -U.clearcoatNormalScale.y), I.material = U;
  }, ge.prototype.getMaterialType = function() {
    return va;
  }, ge.prototype.loadMaterial = function(I) {
    var L = this, U = this.json, N = this.extensions, V = U.materials[I], W, R = {}, D = V.extensions || {}, H = [];
    if (D[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      var ne = N[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      W = ne.getMaterialType(), H.push(ne.extendParams(R, V, L));
    } else if (D[n.KHR_MATERIALS_UNLIT]) {
      var J = N[n.KHR_MATERIALS_UNLIT];
      W = J.getMaterialType(), H.push(J.extendParams(R, V, L));
    } else {
      var b = V.pbrMetallicRoughness || {};
      if (R.color = new xr(1, 1, 1), R.opacity = 1, Array.isArray(b.baseColorFactor)) {
        var _ = b.baseColorFactor;
        R.color.fromArray(_), R.opacity = _[3];
      }
      b.baseColorTexture !== void 0 && H.push(L.assignTexture(R, "map", b.baseColorTexture)), R.metalness = b.metallicFactor !== void 0 ? b.metallicFactor : 1, R.roughness = b.roughnessFactor !== void 0 ? b.roughnessFactor : 1, b.metallicRoughnessTexture !== void 0 && (H.push(L.assignTexture(R, "metalnessMap", b.metallicRoughnessTexture)), H.push(L.assignTexture(R, "roughnessMap", b.metallicRoughnessTexture))), W = this._invokeOne(function(X) {
        return X.getMaterialType && X.getMaterialType(I);
      }), H.push(Promise.all(this._invokeAll(function(X) {
        return X.extendMaterialParams && X.extendMaterialParams(I, R);
      })));
    }
    V.doubleSided === !0 && (R.side = NE);
    var Q = V.alphaMode || k.OPAQUE;
    return Q === k.BLEND ? (R.transparent = !0, R.depthWrite = !1) : (R.transparent = !1, Q === k.MASK && (R.alphaTest = V.alphaCutoff !== void 0 ? V.alphaCutoff : 0.5)), V.normalTexture !== void 0 && W !== ga && (H.push(L.assignTexture(R, "normalMap", V.normalTexture)), R.normalScale = new pg(1, 1), V.normalTexture.scale !== void 0 && R.normalScale.set(V.normalTexture.scale, V.normalTexture.scale)), V.occlusionTexture !== void 0 && W !== ga && (H.push(L.assignTexture(R, "aoMap", V.occlusionTexture)), V.occlusionTexture.strength !== void 0 && (R.aoMapIntensity = V.occlusionTexture.strength)), V.emissiveFactor !== void 0 && W !== ga && (R.emissive = new xr().fromArray(V.emissiveFactor)), V.emissiveTexture !== void 0 && W !== ga && H.push(L.assignTexture(R, "emissiveMap", V.emissiveTexture)), Promise.all(H).then(function() {
      var X;
      return W === v ? X = N[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(R) : X = new W(R), V.name && (X.name = V.name), X.map && (X.map.encoding = mg), X.emissiveMap && (X.emissiveMap.encoding = mg), re(X, V), L.associations.set(X, { type: "materials", index: I }), V.extensions && j(N, X, V), X;
    });
  }, ge.prototype.createUniqueName = function(I) {
    for (var L = rT.sanitizeNodeName(I || ""), U = L, N = 1; this.nodeNamesUsed[U]; ++N)
      U = L + "_" + N;
    return this.nodeNamesUsed[U] = !0, U;
  };
  function we(I, L, U) {
    var N = L.attributes, V = new CE();
    if (N.POSITION !== void 0) {
      var W = U.json.accessors[N.POSITION], R = W.min, D = W.max;
      if (R !== void 0 && D !== void 0)
        V.set(
          new Sc(R[0], R[1], R[2]),
          new Sc(D[0], D[1], D[2])
        );
      else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else
      return;
    var H = L.targets;
    if (H !== void 0) {
      for (var ne = new Sc(), J = new Sc(), b = 0, _ = H.length; b < _; b++) {
        var Q = H[b];
        if (Q.POSITION !== void 0) {
          var W = U.json.accessors[Q.POSITION], R = W.min, D = W.max;
          R !== void 0 && D !== void 0 ? (J.setX(Math.max(Math.abs(R[0]), Math.abs(D[0]))), J.setY(Math.max(Math.abs(R[1]), Math.abs(D[1]))), J.setZ(Math.max(Math.abs(R[2]), Math.abs(D[2]))), ne.max(J)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      V.expandByVector(ne);
    }
    I.boundingBox = V;
    var X = new cT();
    V.getCenter(X.center), X.radius = V.min.distanceTo(V.max) / 2, I.boundingSphere = X;
  }
  function Ge(I, L, U) {
    var N = L.attributes, V = [];
    function W(ne, J) {
      return U.getDependency("accessor", ne).then(function(b) {
        I.setAttribute(J, b);
      });
    }
    for (var R in N) {
      var D = le[R] || R.toLowerCase();
      D in I.attributes || V.push(W(N[R], D));
    }
    if (L.indices !== void 0 && !I.index) {
      var H = U.getDependency("accessor", L.indices).then(function(ne) {
        I.setIndex(ne);
      });
      V.push(H);
    }
    return re(I, L), we(I, L, U), Promise.all(V).then(function() {
      return L.targets !== void 0 ? ae(I, L.targets, U) : I;
    });
  }
  function te(I, L) {
    var U = I.getIndex();
    if (U === null) {
      var N = [], V = I.getAttribute("position");
      if (V !== void 0) {
        for (var W = 0; W < V.count; W++)
          N.push(W);
        I.setIndex(N), U = I.getIndex();
      } else
        return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), I;
    }
    var R = U.count - 2, D = [];
    if (L === fg)
      for (var W = 1; W <= R; W++)
        D.push(U.getX(0)), D.push(U.getX(W)), D.push(U.getX(W + 1));
    else
      for (var W = 0; W < R; W++)
        W % 2 === 0 ? (D.push(U.getX(W)), D.push(U.getX(W + 1)), D.push(U.getX(W + 2))) : (D.push(U.getX(W + 2)), D.push(U.getX(W + 1)), D.push(U.getX(W)));
    D.length / 3 !== R && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    var H = I.clone();
    return H.setIndex(D), H;
  }
  return ge.prototype.loadGeometries = function(I) {
    var L = this, U = this.extensions, N = this.primitiveCache;
    function V(_) {
      return U[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(_, L).then(function(Q) {
        return Ge(Q, _, L);
      });
    }
    for (var W = [], R = 0, D = I.length; R < D; R++) {
      var H = I[R], ne = pe(H), J = N[ne];
      if (J)
        W.push(J.promise);
      else {
        var b;
        H.extensions && H.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? b = V(H) : b = Ge(new RE(), H, L), N[ne] = { primitive: H, promise: b }, W.push(b);
      }
    }
    return Promise.all(W);
  }, ge.prototype.loadMesh = function(I) {
    for (var L = this, U = this.json, N = this.extensions, V = U.meshes[I], W = V.primitives, R = [], D = 0, H = W.length; D < H; D++) {
      var ne = W[D].material === void 0 ? P(this.cache) : this.getDependency("material", W[D].material);
      R.push(ne);
    }
    return R.push(L.loadGeometries(W)), Promise.all(R).then(function(J) {
      for (var b = J.slice(0, J.length - 1), _ = J[J.length - 1], Q = [], X = 0, A = _.length; X < A; X++) {
        var ie = _[X], oe = W[X], he, se = b[X];
        if (oe.mode === E.TRIANGLES || oe.mode === E.TRIANGLE_STRIP || oe.mode === E.TRIANGLE_FAN || oe.mode === void 0)
          he = V.isSkinnedMesh === !0 ? new lT(ie, se) : new jE(ie, se), he.isSkinnedMesh === !0 && !he.geometry.attributes.skinWeight.normalized && he.normalizeSkinWeights(), oe.mode === E.TRIANGLE_STRIP ? he.geometry = te(he.geometry, fT) : oe.mode === E.TRIANGLE_FAN && (he.geometry = te(he.geometry, fg));
        else if (oe.mode === E.LINES)
          he = new kE(ie, se);
        else if (oe.mode === E.LINE_STRIP)
          he = new HE(ie, se);
        else if (oe.mode === E.LINE_LOOP)
          he = new VE(ie, se);
        else if (oe.mode === E.POINTS)
          he = new nT(ie, se);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + oe.mode);
        Object.keys(he.geometry.morphAttributes).length > 0 && ce(he, V), he.name = L.createUniqueName(V.name || "mesh_" + I), re(he, V), oe.extensions && j(N, he, oe), L.assignFinalMaterial(he), Q.push(he);
      }
      if (Q.length === 1)
        return Q[0];
      for (var me = new $u(), X = 0, A = Q.length; X < A; X++)
        me.add(Q[X]);
      return me;
    });
  }, ge.prototype.loadCamera = function(I) {
    var L, U = this.json.cameras[I], N = U[U.type];
    if (!N) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return U.type === "perspective" ? L = new eT($E.radToDeg(N.yfov), N.aspectRatio || 1, N.znear || 1, N.zfar || 2e6) : U.type === "orthographic" && (L = new QE(-N.xmag, N.xmag, N.ymag, -N.ymag, N.znear, N.zfar)), U.name && (L.name = this.createUniqueName(U.name)), re(L, U), Promise.resolve(L);
  }, ge.prototype.loadSkin = function(I) {
    var L = this.json.skins[I], U = { joints: L.joints };
    return L.inverseBindMatrices === void 0 ? Promise.resolve(U) : this.getDependency("accessor", L.inverseBindMatrices).then(function(N) {
      return U.inverseBindMatrices = N, U;
    });
  }, ge.prototype.loadAnimation = function(I) {
    for (var L = this.json, U = L.animations[I], N = [], V = [], W = [], R = [], D = [], H = 0, ne = U.channels.length; H < ne; H++) {
      var J = U.channels[H], b = U.samplers[J.sampler], _ = J.target, Q = _.node !== void 0 ? _.node : _.id, X = U.parameters !== void 0 ? U.parameters[b.input] : b.input, A = U.parameters !== void 0 ? U.parameters[b.output] : b.output;
      N.push(this.getDependency("node", Q)), V.push(this.getDependency("accessor", X)), W.push(this.getDependency("accessor", A)), R.push(b), D.push(_);
    }
    return Promise.all([
      Promise.all(N),
      Promise.all(V),
      Promise.all(W),
      Promise.all(R),
      Promise.all(D)
    ]).then(function(ie) {
      for (var oe = ie[0], he = ie[1], se = ie[2], me = ie[3], ve = ie[4], be = [], fe = 0, _e = oe.length; fe < _e; fe++) {
        var Pe = oe[fe], rt = he[fe], dn = se[fe], es = me[fe], Fi = ve[fe];
        if (Pe !== void 0) {
          Pe.updateMatrix(), Pe.matrixAutoUpdate = !0;
          var cr;
          switch (B[Fi.path]) {
            case B.weights:
              cr = JE;
              break;
            case B.rotation:
              cr = sT;
              break;
            case B.position:
            case B.scale:
            default:
              cr = pT;
              break;
          }
          var Bi = Pe.name ? Pe.name : Pe.uuid, ra = es.interpolation !== void 0 ? Z[es.interpolation] : og, Wt = [];
          B[Fi.path] === B.weights ? Pe.traverse(function(M) {
            M.isMesh === !0 && M.morphTargetInfluences && Wt.push(M.name ? M.name : M.uuid);
          }) : Wt.push(Bi);
          var en = dn.array;
          if (dn.normalized) {
            var kn;
            if (en.constructor === Int8Array)
              kn = 1 / 127;
            else if (en.constructor === Uint8Array)
              kn = 1 / 255;
            else if (en.constructor == Int16Array)
              kn = 1 / 32767;
            else if (en.constructor === Uint16Array)
              kn = 1 / 65535;
            else
              throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
            for (var hr = new Float32Array(en.length), ct = 0, zi = en.length; ct < zi; ct++)
              hr[ct] = en[ct] * kn;
            en = hr;
          }
          for (var ct = 0, zi = Wt.length; ct < zi; ct++) {
            var ts = new cr(
              Wt[ct] + "." + B[Fi.path],
              rt.array,
              en,
              ra
            );
            es.interpolation === "CUBICSPLINE" && (ts.createInterpolant = function(K) {
              return new T(this.times, this.values, this.getValueSize() / 3, K);
            }, ts.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), be.push(ts);
          }
        }
      }
      var sa = U.name ? U.name : "animation_" + I;
      return new AE(sa, void 0, be);
    });
  }, ge.prototype.loadNode = function(I) {
    var L = this.json, U = this.extensions, N = this, V = L.nodes[I], W = V.name ? N.createUniqueName(V.name) : "";
    return function() {
      var R = [];
      return V.mesh !== void 0 && R.push(N.getDependency("mesh", V.mesh).then(function(D) {
        var H = N._getNodeRef(N.meshCache, V.mesh, D);
        return V.weights !== void 0 && H.traverse(function(ne) {
          if (ne.isMesh)
            for (var J = 0, b = V.weights.length; J < b; J++)
              ne.morphTargetInfluences[J] = V.weights[J];
        }), H;
      })), V.camera !== void 0 && R.push(N.getDependency("camera", V.camera).then(function(D) {
        return N._getNodeRef(N.cameraCache, V.camera, D);
      })), N._invokeAll(function(D) {
        return D.createNodeAttachment && D.createNodeAttachment(I);
      }).forEach(function(D) {
        R.push(D);
      }), Promise.all(R);
    }().then(function(R) {
      var D;
      if (V.isBone === !0 ? D = new LE() : R.length > 1 ? D = new $u() : R.length === 1 ? D = R[0] : D = new KE(), D !== R[0])
        for (var H = 0, ne = R.length; H < ne; H++)
          D.add(R[H]);
      if (V.name && (D.userData.name = V.name, D.name = W), re(D, V), V.extensions && j(U, D, V), V.matrix !== void 0) {
        var J = new ug();
        J.fromArray(V.matrix), D.applyMatrix4(J);
      } else
        V.translation !== void 0 && D.position.fromArray(V.translation), V.rotation !== void 0 && D.quaternion.fromArray(V.rotation), V.scale !== void 0 && D.scale.fromArray(V.scale);
      return N.associations.set(D, { type: "nodes", index: I }), D;
    });
  }, ge.prototype.loadScene = /* @__PURE__ */ function() {
    function I(L, U, N, V) {
      var W = N.nodes[L];
      return V.getDependency("node", L).then(function(R) {
        if (W.skin === void 0) return R;
        var D;
        return V.getDependency("skin", W.skin).then(function(H) {
          D = H;
          for (var ne = [], J = 0, b = D.joints.length; J < b; J++)
            ne.push(V.getDependency("node", D.joints[J]));
          return Promise.all(ne);
        }).then(function(H) {
          return R.traverse(function(ne) {
            if (ne.isMesh) {
              for (var J = [], b = [], _ = 0, Q = H.length; _ < Q; _++) {
                var X = H[_];
                if (X) {
                  J.push(X);
                  var A = new ug();
                  D.inverseBindMatrices !== void 0 && A.fromArray(D.inverseBindMatrices.array, _ * 16), b.push(A);
                } else
                  console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', D.joints[_]);
              }
              ne.bind(new aT(J, b), ne.matrixWorld);
            }
          }), R;
        });
      }).then(function(R) {
        U.add(R);
        var D = [];
        if (W.children)
          for (var H = W.children, ne = 0, J = H.length; ne < J; ne++) {
            var b = H[ne];
            D.push(I(b, R, N, V));
          }
        return Promise.all(D);
      });
    }
    return function(U) {
      var N = this.json, V = this.extensions, W = this.json.scenes[U], R = this, D = new $u();
      W.name && (D.name = R.createUniqueName(W.name)), re(D, W), W.extensions && j(V, D, W);
      for (var H = W.nodes || [], ne = [], J = 0, b = H.length; J < b; J++)
        ne.push(I(H[J], D, N, R));
      return Promise.all(ne).then(function() {
        return D;
      });
    };
  }(), t;
}();
const qh = class qh extends nu {
  constructor(n) {
    super(n);
    Ue(this, "visible", !0);
    Ue(this, "urls", []);
    Ue(this, "models", []);
    Ue(this, "attached", !1);
    Ue(this, "type", "GLTFLayer");
    n.urls && (this.urls = n.urls);
  }
  async attach() {
    for (let n of this.urls) await this.add(n);
    this.attached = !0;
  }
  detach() {
    for (let n of this.models) this.remove(n);
    this.attached = !1;
  }
  async add(n) {
    let r = this;
    return new Promise((s, o) => {
      qh.loader.load(
        n,
        function(a) {
          r.models.push(a.scene), Ce.scene.scene.add(a.scene), s();
        },
        function(a) {
        },
        function(a) {
          throw console.log(a), "Error loading gltf.";
        }
      );
    });
  }
  remove(n) {
    if (Ce.scene.remove(n), this.models.indexOf(n) > -1) {
      let r = this.models.indexOf(n);
      this.models.splice(r, 1), this.urls.splice(r, 1);
    }
  }
  updateVisibility() {
    for (let n of this.models) n.visible = this.visible;
  }
  show() {
    this.visible = !0, this.updateVisibility();
  }
  hide() {
    this.visible = !1, this.updateVisibility();
  }
  bbox() {
    let n = new kt();
    for (let r of this.models)
      for (let s of r.children) s.geometry && s.geometry.boundingBox && n.union(s.geometry.boundingBox);
    return n.expandByScalar(0.05);
  }
};
Ue(qh, "loader", new mT());
let gg = qh;
const Ky = Je, gT = He, ip = z;
class Ch extends gT {
  constructor(e = document.createElement("div")) {
    super(), this.element = e, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", function() {
      this.traverse(function(n) {
        n.element instanceof Element && n.element.parentNode !== null && n.element.parentNode.removeChild(n.element);
      });
    });
  }
  copy(e, n) {
    return super.copy(e, n), this.element = e.element.cloneNode(!0), this;
  }
}
Ch.prototype.isCSS2DObject = !0;
const _r = new ip(), vg = new Ky(), yg = new Ky(), xg = new ip(), _g = new ip();
class vT {
  constructor(e = {}) {
    const n = this;
    let r, s, o, a;
    const l = {
      objects: /* @__PURE__ */ new WeakMap()
    }, c = e.element !== void 0 ? e.element : document.createElement("div");
    c.style.overflow = "hidden", this.domElement = c, this.getSize = function() {
      return {
        width: r,
        height: s
      };
    }, this.render = function(f, m) {
      f.autoUpdate === !0 && f.updateMatrixWorld(), m.parent === null && m.updateMatrixWorld(), vg.copy(m.matrixWorldInverse), yg.multiplyMatrices(m.projectionMatrix, vg), h(f, f, m), p(f);
    }, this.setSize = function(f, m) {
      r = f, s = m, o = r / 2, a = s / 2, c.style.width = f + "px", c.style.height = m + "px";
    };
    function h(f, m, y) {
      if (f.isCSS2DObject) {
        f.onBeforeRender(n, m, y), _r.setFromMatrixPosition(f.matrixWorld), _r.applyMatrix4(yg);
        const x = f.element;
        /apple/i.test(navigator.vendor) ? x.style.transform = "translate(-50%,-50%) translate(" + Math.round(_r.x * o + o) + "px," + Math.round(-_r.y * a + a) + "px)" : x.style.transform = "translate(-50%,-50%) translate(" + (_r.x * o + o) + "px," + (-_r.y * a + a) + "px)", x.style.display = f.visible && _r.z >= -1 && _r.z <= 1 ? "" : "none";
        const v = {
          distanceToCameraSquared: d(y, f)
        };
        l.objects.set(f, v), x.parentNode !== c && c.appendChild(x), f.onAfterRender(n, m, y);
      }
      for (let x = 0, v = f.children.length; x < v; x++)
        h(f.children[x], m, y);
    }
    function d(f, m) {
      return xg.setFromMatrixPosition(f.matrixWorld), _g.setFromMatrixPosition(m.matrixWorld), xg.distanceToSquared(_g);
    }
    function u(f) {
      const m = [];
      return f.traverse(function(y) {
        y.isCSS2DObject && m.push(y);
      }), m;
    }
    function p(f) {
      const m = u(f).sort(function(x, v) {
        const g = l.objects.get(x).distanceToCameraSquared, S = l.objects.get(v).distanceToCameraSquared;
        return g - S;
      }), y = m.length;
      for (let x = 0, v = m.length; x < v; x++)
        m[x].element.style.zIndex = y - x;
    }
  }
}
class RI {
  constructor([e, n, r], s) {
    type = "Overlay", this.vectors = [[e, n, r]], s.element && (this.model = new Ch(s.element), this.model.position.set(e, n, r), this.element = s.element, this.model.userData = this), s.visibilityDistance && (this.VisibilityDistance = s.visibilityDistance), s.clickable == !1 && (this.element.style.pointerEvents = "none");
  }
  attachToScene() {
    Ce.scene.scene.add(this.model);
  }
  removeFromScene() {
    Ce.scene.scene.remove(this.model);
  }
  updateVectors() {
    this.vectors = [[this.model.position.x, this.model.position.y, this.model.position.z]];
  }
  updateModel() {
    this.model.position.set(this.vectors[0][0], this.vectors[0][1], this.vectors[0][2]);
  }
  setPosition([e, n, r]) {
    this.vectors = [[e, n, r]], this.model.position.set(e, n, r);
  }
}
class rp extends Vy {
  constructor() {
    super(), this.parent = void 0, this.domElement = Ce.renderer.domElement;
  }
  initialize() {
    throw "Must be overriden by child class";
  }
}
const Xh = class Xh extends iu {
  constructor(e, n) {
    super();
    let r = this.convertPositionsToVectors(e), s = new it().setFromPoints(r);
    this.model = new Wr(s, Xh.material), this.refersTo = n, this.model.userData = this;
  }
  convertPositionsToVectors(e) {
    let n = [];
    for (let [r, s, o] of e) n.push(new z(r, s, o));
    return n;
  }
  attachToScene() {
    Ce.scene.scene.add(this.model);
  }
  removeFromScene() {
    Ce.scene.scene.remove(this.model);
  }
};
Ue(Xh, "material", new un({ color: "yellow", transparent: !0, opacity: 0 }));
let Rh = Xh;
const Yh = class Yh extends rp {
  constructor(n) {
    super(n);
    Ue(this, "type", "Snap");
    this.parentSources = [], n && (n.sources && (this.parentSources = n.sources), n.target && (this.target = n.target)), this.snapPoints = [], this.snapPointCloud = new Ro(new it(), Yh.pointMaterial), this.snapPotreePointclouds = [], this.snapLines = [], this.models = [], this.active = !0;
  }
  initialize() {
    this.generateSnaps2 = this.generateSnaps.bind(this), Ce.scene.scene.add(this.snapPointCloud);
    for (let n of this.parentSources)
      n instanceof Go && (n.addEventListener("modifyend", this.generateSnaps2), n.addEventListener("added", this.generateSnaps2), n.addEventListener("removed", this.generateSnaps2));
    this.generateSnaps();
  }
  remove() {
    this.clearSnapPoints(), this.clearSnapLines();
  }
  setActive(n) {
    n == !0 ? (this.active = !0, this.generateSnaps()) : (this.active = !1, this.remove());
  }
  generateSnaps() {
    this.clearSnapLines(), this.clearSnapPoints();
    let n = [];
    if (this.target) n.push(this.target);
    else
      for (let r of this.parentSources)
        r instanceof Go && n.push(...r.geometries);
    for (let r of n) {
      if (r instanceof Fr && this.createSnapPoint(r.vectors, r), r instanceof Dn) {
        for (let s of r.vectors) this.createSnapPoint(s, r);
        for (let s of r.holes) {
          this.createSnapLine([...s, s[0]], r);
          for (let o of s)
            this.createSnapPoint(o, r);
        }
        this.createSnapLine([...r.vectors, r.vectors[0]], r);
      }
      if (r instanceof Zi) {
        this.createSnapLine(r.vectors, r);
        for (let s of r.vectors)
          this.createSnapPoint(s, r);
      }
    }
    this.updateSnapPointHelper();
  }
  clearSnapPoints() {
    this.snapPointCloud.geometry.setAttribute("position", new Ke([], 3)), this.snapPointCloud.geometry.setDrawRange(0, 0), this.snapPointCloud.geometry.verticesNeedUpdate = !0, this.snapPointCloud.geometry.computeBoundingSphere(), this.snapPoints = [];
  }
  clearSnapLines() {
    for (let n of this.snapLines)
      n.removeFromScene(), this.models.indexOf(n.model) > -1 && this.models.splice(this.models.indexOf(n.model), 1);
    this.snapLines = [];
  }
  createSnapPoint([n, r, s], o) {
    this.snapPoints.push({ coordinates: [n, r, s], refersTo: o });
  }
  updateSnapPointHelper() {
    if (this.snapPoints[0] && this.snapPoints[0].coordinates) {
      let n = this.snapPoints[0].coordinates, r = [];
      for (let s of this.snapPoints) r.push(s.coordinates[0] - n[0], s.coordinates[1] - n[1], s.coordinates[2] - n[2]);
      this.snapPointCloud.geometry.setAttribute("position", new Ke(r, 3)), this.snapPointCloud.geometry.setDrawRange(0, this.snapPoints.length), this.snapPointCloud.geometry.verticesNeedUpdate = !0, this.snapPointCloud.geometry.computeBoundingSphere(), this.snapPointCloud.position.set(...n);
    }
  }
  createSnapLine(n, r) {
    let s = new Rh(n, r);
    return s.attachToScene(), this.snapLines.push(s), this.models.push(s.model), s;
  }
};
Ue(Yh, "pointMaterial", new li({ color: "#282828", size: 0.1, transparent: !0, opacity: 0 }));
let of = Yh;
const sn = class sn {
  static generateSpriteTexture(e) {
    let n = document.createElement("canvas"), r = n.getContext("2d");
    n.width = 64, n.height = 64, n.style.width = "64px", n.style.height = "64px", r.clearRect(0, 0, r.canvas.width, r.canvas.height), r.strokeStyle = "black", e && (r.fillStyle = e), r.beginPath(), r.lineWidth = 2, r.arc(n.width / 2, n.height / 2, n.width / 2 - 3, 0, 2 * Math.PI, !1), e && r.fill(), r.stroke();
    let s = new ft(n);
    return s.needsUpdate = !0, n.remove(), s;
  }
  generateCursorHelper() {
    let e = document.createElement("span");
    return e.style.height = "5px", e.style.width = "5px", e.style.backgroundColor = "white", e.style.borderRadius = "50%", e.style.display = "inline-block", e.style.pointerEvents = "none", e.style.border = "0.5px solid black", e;
  }
  generateHeightHelper() {
    let e = document.createElement("p");
    return e.innerText = this.model.position.z, e.style.color = "white", e.style.textShadow = "-1px 0 black, 0 1px black, 1px 0 black, 0 -1px black", e.style.pointerEvents = "none", e.style.paddingTop = "50px", e.style.paddingLeft = "50px", e;
  }
  constructor() {
    this.mousePosition = [0, 0, 0], this.position = [0, 0, 0], this.type = "Cursor", this.updateOwnPosition = !0, this.movedMouse = !1, this.snapped = !1, this.snappedObject = void 0, this.model = new Nd(sn.material), this.cursorHelperElement = this.generateCursorHelper(), this.heightHelperElement = this.generateHeightHelper(), this.cursorHelperModel = new Ch(this.cursorHelperElement), this.heightHelperModel = new Ch(this.heightHelperElement), this.model.userData = this, this.snapDistance = 1, this.pointSnapDistance = 0.3, this.view = void 0, this.showHeightHelper();
  }
  attachToScene(e) {
    e.add(this.model), e.add(this.cursorHelperModel), e.add(this.heightHelperModel);
  }
  initializeEvents(e) {
    this.domElement = Ce.renderer.domElement, this.view = e, this.domElement.addEventListener("mousemove", (n) => {
      this.updatePosition(n), this.movedMouse = !0;
    }), this.domElement.addEventListener("pointerdown", (n) => {
      this.updateHeight(n), this.movedMouse = !1;
    });
  }
  updateModelPosition() {
    this.model.position.set(this.position[0], this.position[1], this.position[2]), this.heightHelperElement.innerText = "z: " + Math.round(this.position[2] * 100) / 100, this.cursorHelperModel.position.set(this.position[0], this.position[1], this.position[2]), this.heightHelperModel.position.set(this.position[0], this.position[1], this.position[2]);
  }
  updatePosition(e) {
    try {
      let n = this.view, r = new ye(
        e.layerX / this.domElement.getBoundingClientRect().width * 2 - 1,
        -(e.layerY / this.domElement.getBoundingClientRect().height) * 2 + 1
      ), s = [], o = [], a = [], l = [];
      for (let u of n.interactions)
        if (u instanceof of && u.active == !0 && (u.target == null || !u.target.beingModified)) {
          l.push(u.snapPoints), o.push(u.snapPointCloud), s.push(...u.snapLines.map((p) => p.model));
          for (let p of u.parentSources) p instanceof qm && a.push(...p.pointclouds);
        }
      let c = !1, h = !1, d = !1;
      for (let u = 0; u < o.length; u++)
        if (l[u].length > 0) {
          let p = this.getMouseIntersect(r, [o[u]]);
          if (p && p[0]) {
            let f = new z(...l[u][p[0].index].coordinates);
            if (p[0].index !== void 0 && f.distanceTo(p[0].point) < this.pointSnapDistance) {
              this.snapTo(l[u][p[0].index].coordinates, l[u][p[0].index].refersTo), c = !0;
              break;
            }
          }
        }
      if (!c) {
        let u = this.getMouseIntersect(r, s);
        u && u[0] && u[0].object.userData instanceof Rh && (this.snapTo([u[0].point.x, u[0].point.y, u[0].point.z], u[0].object.userData.refersTo), h = !0);
      }
      if (!c && !h) {
        let u = fs.Utils.getMousePointCloudIntersection(
          Ce.inputHandler.mouse,
          Ce.scene.getActiveCamera(),
          Ce,
          a
        );
        u && (this.snapTo([u.location.x, u.location.y, u.location.z]), d = !0);
      }
      if (!c && !d && !h && this.unsnap(), !this.snapped) {
        let u = new z(r.x, r.y, 0.5);
        u.unproject(Ce.scene.getActiveCamera().clone()), u.sub(Ce.scene.getActiveCamera().clone().position).normalize();
        let f = (this.position[2] - Ce.scene.getActiveCamera().clone().position.z) / u.z, m = Ce.scene.getActiveCamera().clone().position.add(u.multiplyScalar(f));
        this.mousePosition = [m.x, m.y, m.z], this.position = [m.x, m.y, m.z], this.updateModelPosition();
      }
    } catch (n) {
      console.log(n);
    }
  }
  updateHeight(e) {
    let n = this.view, r = new ye(
      e.layerX / this.domElement.getBoundingClientRect().width * 2 - 1,
      // x
      -(e.layerY / this.domElement.getBoundingClientRect().height) * 2 + 1
      // y
    );
    sn.raycaster.setFromCamera(r, Ce.scene.getActiveCamera());
    try {
      if (!this.snapped) {
        let s;
        Ce.scene.pointclouds.length > 0 && (s = fs.Utils.getMousePointCloudIntersection(
          e,
          Ce.scene.getActiveCamera(),
          Ce,
          Ce.scene.pointclouds,
          { pickClipped: !1 }
        ));
        const o = [];
        for (let u of n.layers)
          if ((u instanceof qm || u instanceof GeometryLayer) && u.Models)
            for (let p of u.Models) o.push(p);
        let a = sn.raycaster.intersectObjects(o, !0), l = new z(r.x, r.y, 0.5);
        l.unproject(Ce.scene.getActiveCamera().clone()), l.sub(Ce.scene.getActiveCamera().clone().position).normalize();
        let c;
        a && a[0] && a[0].point.z !== 0 ? c = a[0].point.z : s ? c = s.location.z : c = this.position[2];
        let h = (c - Ce.scene.getActiveCamera().clone().position.z) / l.z, d = Ce.scene.getActiveCamera().clone().position.add(l.multiplyScalar(h));
        this.mousePosition = [d.x, d.y, d.z], this.position = [d.x, d.y, d.z], this.updateModelPosition();
      }
    } catch {
    }
  }
  getMouseIntersect(e, n) {
    return sn.raycaster.setFromCamera(e, Ce.scene.getActiveCamera()), sn.raycaster.intersectObjects(n, !1);
  }
  snapTo([e, n, r], s) {
    this.updateOwnPosition = !1, this.snapped = !0, this.snappedObject = s, this.position = [e, n, r], this.mousePosition = [e, n, r], this.updateModelPosition(), this.model.material = sn.snapMaterial;
  }
  unsnap() {
    this.snapped = !1, this.updateOwnPosition = !0, this.snappedObject = void 0, this.model.material = sn.material;
  }
  showHeightHelper() {
    this.heightHelperModel.visible = !0;
  }
  hideHeightHelper() {
    this.heightHelperModel.visible = !1;
  }
};
Ue(sn, "material", new kr({ map: sn.generateSpriteTexture("black"), depthTest: !1, depthWrite: !1, transparent: !0 })), Ue(sn, "snapMaterial", new Fn({ map: sn.generateSpriteTexture("white"), depthTest: !1, depthWrite: !1, transparent: !0 })), Ue(sn, "raycaster", new tu());
let qr = sn;
qr.raycaster.params.Points.threshold = 0.1;
qr.raycaster.params.Line.threshold = 0.1;
const vt = class vt {
  constructor(e) {
    Ue(this, "layers", []);
    Ue(this, "interactions", []);
    e.layers && (this.layers = e.layers), e.interactions && (this.interactions = e.interactions);
  }
  async initialize() {
    Ce.renderer.domElement.parentElement.appendChild(vt.overlayRenderer.domElement), vt.cursor.attachToScene(vt.overlayScene), vt.cursor.initializeEvents(this);
    let e = document.getElementById("potree_render_area").getBoundingClientRect();
    vt.overlayRenderer.setSize(e.width, e.height);
    for (let n of this.interactions) n.initialize();
    for (let n of this.layers) await n.attach();
    window.addEventListener("resize", (n) => {
      let r = document.getElementById("potree_render_area").getBoundingClientRect();
      Ce.renderer.setSize(r.width, r.height), vt.overlayRenderer.setSize(r.width, r.height);
    }), this.everyFrame();
  }
  async addLayer(e) {
    this.layers.push(e), await e.attach();
  }
  removeLayer(e) {
    if (this.layers.indexOf(e) > -1) {
      let n = this.layers.indexOf(e);
      this.layers[n].detach(), this.layers.splice(n, 1);
    }
  }
  zooomToBbox(e) {
    let n = new z(e.min.x + (e.max.x - e.min.x) / 2, e.min.y + (e.max.y - e.min.y) / 2, e.min.z + (e.max.z - e.min.z) / 2);
    this.Position = [n.x, n.y, n.z];
    const r = new zS(e.max.x - e.min.x, e.max.y - e.min.y, e.max.z - e.min.z), s = new Fn({ color: 65280, wireframe: !0 }), o = new Tt(r, s);
    o.position.copy(n), Ce.zoomTo(o, 1, 0), Ce.controls.stop(), o.geometry.dispose(), o.material.dispose();
  }
  center() {
    let e = new kt();
    if (this.layers.length > 0) for (let n of this.layers) e.union(n.bbox());
    else e = new kt(new z(0, 0, 0), new z(10, 10, 10));
    this.zooomToBbox(e);
  }
  scale() {
    if (vt.cursor) {
      let s = vt.cursor.model.position.distanceTo(Ce.scene.view.position), a = 10 / Potree.Utils.projectedRadius(1, Ce.scene.getActiveCamera(), s, Ce.clientwidth, Ce.renderer.domElement.clientHeight);
      a > 3 && (a = 2), vt.cursor.snapped && (a *= 3), vt.cursor.model.scale.set(a, a, a);
    }
    let e = Ce.scene.view.position.z - vt.cursor.model.position.z, r = 30 / Potree.Utils.projectedRadius(1, Ce.scene.getActiveCamera(), e, Ce.clientwidth, Ce.renderer.domElement.clientHeight);
    r < vt.pointMinScale && (r = vt.pointMinScale), r > vt.pointMaxScale && (r = vt.pointMaxScale);
    for (let s of this.interactions)
      s instanceof yT && (s.drawHelper.pointscloud.material.size = r);
    for (let s of this.layers) {
      if (s instanceof TE && s.UseVisibilityDistance)
        for (let o of s.overlays)
          o.model.position.distanceTo(Ce.scene.view.position) > o.VisibilityDistance ? o.model.visible = !1 : s.visible && (o.model.visible = !0);
      s instanceof Go && (qr.raycaster.params.Points.threshold = r, s.pointscloud.material.size = r);
    }
  }
  everyFrame() {
    this.scale(), Ce.renderer.clearDepth(), Ce.renderer.render(vt.overlayScene, Ce.scene.getActiveCamera()), vt.overlayRenderer.render(Ce.scene.scene, Ce.scene.getActiveCamera()), vt.overlayRenderer.render(vt.overlayScene, Ce.scene.getActiveCamera()), requestAnimationFrame(this.everyFrame.bind(this));
    for (let e of this.layers)
      e.visible == !1 ? e.hide() : e.show();
  }
};
Ue(vt, "cursor", new qr()), Ue(vt, "overlayScene", new Zf()), Ue(vt, "overlayRenderer", new vT()), Ue(vt, "pointMinScale", 0.01), Ue(vt, "pointMaxScale", 10);
let Rt = vt;
const ei = class ei {
  constructor(e) {
    this.Vectors = [], this.Points = [], this.pointscloud = new Ro(new it(), ei.pointMaterial), this.Line = void 0, this.Polygon = void 0, this.scene = Rt.overlayScene, this.pointscloud.userData = this, this.geomType = e.geomType;
  }
  addVector(e) {
    this.Vectors.push(e);
    let n = new Fr(e, { material: ei.pointMaterial });
    if (this.Points.push(n), this.updatePoints(), this.geomType == "Line" && this.Vectors.length > 1) {
      this.removeLine();
      let r = new Zi(this.Vectors, { material: ei.lineMaterial });
      this.scene.add(r.model), this.Line = r, this.Line.model.userData = this;
    }
    if (this.geomType == "Polygon" && this.Vectors.length > 2) {
      this.removePolygon();
      let r = new Dn([this.Vectors], { material: ei.meshMaterial });
      this.Polygon || this.scene.add(r.model), this.Polygon = r, this.Polygon.model.userData = this;
    }
  }
  updatePoints() {
    let e = this.Vectors[0], n = [];
    for (let r of this.Vectors) n.push(r[0] - e[0], r[1] - e[1], r[2] - e[2]);
    this.scene.remove(this.pointscloud), this.pointscloud.geometry.setAttribute("position", new Ke(n, 3)), this.pointscloud.geometry.setDrawRange(0, this.Vectors.length), this.pointscloud.geometry.verticesNeedUpdate = !0, this.pointscloud.geometry.computeBoundingSphere(), this.pointscloud.position.set(...e), this.scene.add(this.pointscloud);
  }
  undo(e) {
    if (e || (this.Vectors.pop(), this.Points.pop()), e && (this.Vectors.splice(e, 1), this.Points.splice(e, 1)[0]), this.Line && this.removeLine(), this.Polygon && this.removePolygon(), this.geomType == "Line" && this.Vectors.length > 1) {
      let n = new Zi(this.Vectors, { material: ei.lineMaterial });
      this.scene.add(n.model), this.Line = n, this.Line.model.userData = this;
    }
    if (this.geomType == "Polygon" && this.Vectors.length > 2) {
      let n = new Dn([this.Vectors], { material: ei.meshMaterial });
      this.Polygon || this.scene.add(n.model), this.Polygon = n, this.Polygon.model.userData = this;
    }
    this.updatePoints();
  }
  clear() {
    this.removePolygon(), this.removeLine(), this.removePoints(), this.Vectors = [];
  }
  removePolygon() {
    this.Polygon && (this.Polygon.model.geometry.dispose(), this.scene.remove(this.Polygon.model), this.Polygon = void 0);
  }
  removeLine() {
    this.Line && (this.Line.model.geometry.dispose(), this.scene.remove(this.Line.model), this.Line = void 0);
  }
  removePoints() {
    this.Points && (this.Points = []), this.scene.remove(this.pointscloud);
  }
  convertPositionsToVectors(e) {
    let n = [];
    for (let [r, s, o] of e)
      n.push(new z(r, s, o));
    return n;
  }
};
Ue(ei, "lineMaterial", new Ol({ color: "blue", linewidth: 5, vertexColors: !1, resolution: new ye(1e3, 1e3), dashed: !1, alphaToCoverage: !0 })), Ue(ei, "meshMaterial", new Fn({ color: "blue", transparent: !1 })), Ue(ei, "pointMaterial", new li({ color: "#0000FF", size: 0.1, depthTest: !1, depthWrite: !1 }));
let af = ei;
class yT extends rp {
  constructor(n) {
    super(n);
    Ue(this, "type", "Draw");
    if (n) {
      if (n.layer && (this.parentSource = n.layer), n.type)
        this.geomType = n.type, this.drawHelper = new af({ geomType: n.type });
      else throw "Draw interaction must have 'type' parameter.";
      n.maxVertices ? this.maxVertices = n.maxVertices : this.maxVertices = 1 / 0;
    }
    this.raycaster = qr.raycaster, this.vectors = [], this.viewingImage360 = !1, this.viewingOrientedImage = !1, this.active = !0;
  }
  addEventListeners() {
    if (Ce.addEventListener("360image_focused", this.setViewingImage3602), Ce.addEventListener("360image_unfocused", this.unsetViewingImage3602), Ce.addEventListener("oriented_image_focused", this.setViewingOrientedImage2), Ce.addEventListener("oriented_image_unfocused", this.unsetViewingOrientedImage2), this.parentSource)
      this.parentSource instanceof Go ? this.domElement.addEventListener("pointerup", this.handleGeometrySourcePointerUp2) : console.warn("The assigned source " + this.parentSource.type + " is incompatible with the interaction " + this.type + ".");
    else throw "Must have parameter layer.";
  }
  initialize() {
    this.setViewingImage3602 = this.setViewingImage360.bind(this), this.unsetViewingImage3602 = this.unsetViewingImage360.bind(this), this.setViewingOrientedImage2 = this.setViewingOrientedImage.bind(this), this.unsetViewingOrientedImage2 = this.unsetViewingOrientedImage.bind(this), this.handleGeometrySourcePointerUp2 = this.handleGeometrySourcePointerUp.bind(this), this.addEventListeners();
  }
  remove() {
    this.drawHelper && this.drawHelper.clear();
  }
  setActive(n) {
    n == !0 ? this.active = !0 : (this.active = !1, this.remove());
  }
  handleGeometrySourcePointerUp(n) {
    if (this.active) {
      if (n.button == 0) {
        let r = this.getMouseIntersect(n);
        Rt.cursor.movedMouse == !1 && (!this.viewingImage360 && (!r || !r.object.image360) || this.viewingImage360) && (!this.viewingOrientedImage && (!r || r.object.parent.name != "oriented_images") || this.viewingOrientedImage && r.object.parent.name == "oriented_images") && this.vectors.length < this.maxVertices && this.drawHelper && (this.vectors.push(Rt.cursor.position), this.drawHelper.addVector(Rt.cursor.position), this.dispatchVertexAdded({ vertex: JSON.parse(JSON.stringify(Rt.cursor.position)), index: this.drawHelper.Vectors.length - 1 }));
      } else if (n.button == 2 && (this.vectors = [], this.drawHelper && !Rt.cursor.movedMouse)) {
        let r;
        if (this.geomType == "Point" && this.drawHelper.Vectors.length > 0) {
          let s = [];
          for (let o of this.drawHelper.Vectors)
            s.push(new Fr(o));
          r = s;
        } else this.geomType == "Line" && this.drawHelper.Vectors.length >= 2 ? r = new Zi(this.drawHelper.Vectors) : this.geomType == "Polygon" && this.drawHelper.Vectors.length >= 3 && (r = new Dn([this.drawHelper.Vectors]));
        r && this.dispatchDrawEnd(r), this.drawHelper.clear();
      }
    }
  }
  getMouseIntersect(n) {
    let r = new ye(
      n.layerX / this.domElement.getBoundingClientRect().width * 2 - 1,
      // x
      -(n.layerY / this.domElement.getBoundingClientRect().height) * 2 + 1
      // y
    );
    const s = [];
    Ce.scene.scene.traverse((a) => {
      a.visible == !0 && a.type != "AxesHelper" && a.userData.Type != "Cursor3D" && !a.userData.beingModified && s.push(a);
    }), this.raycaster.setFromCamera(r, Ce.scene.getActiveCamera());
    let o = this.raycaster.intersectObjects(s, !1);
    return o.sort((a, l) => a.distance > l.distance ? 1 : -1), o[0];
  }
  dispatchVertexAdded(n) {
    const r = new CustomEvent("vertexadded", { detail: n, source: this.parentSource });
    this.dispatchEvent(r);
  }
  undo(n) {
    this.active && this.parentSource instanceof GeometrySource && (this.vectors.pop(Rt.cursor.position), this.drawHelper && this.drawHelper.undo(n), this.parentSource.updatePoints());
  }
  dispatchDrawEnd(n) {
    const r = new CustomEvent("drawend", { detail: n, source: this.parentSource });
    this.dispatchEvent(r), this.parentSource.dispatchEvent(r);
  }
  setViewingOrientedImage() {
    this.viewingOrientedImage = !0;
  }
  unsetViewingOrientedImage() {
    this.viewingOrientedImage = !1;
  }
  setViewingImage360() {
    this.viewingImage360 = !0;
  }
  unsetViewingImage360() {
    this.viewingImage360 = !1;
  }
}
class PI extends rp {
  constructor(n) {
    super(n);
    Ue(this, "type", "Modify");
    this.raycaster = qr.raycaster, this.button = 0, this.clickRange = 0.5, n && (n.source && (this.parentSource = n.source), n.target && (this.target = n.target), n.button && (this.button = n.button), n.clickRange && (this.clickRange = n.clickRange)), this.selectedVector = {
      index: void 0,
      coordinates: void 0,
      holeIndex: void 0
    }, this.selectedObject = void 0, this.selectedMeasurement = void 0, this.active = !0;
  }
  addEventListeners() {
    this.parentSource instanceof Go ? (this.domElement.addEventListener("pointerup", this.handleGeometrySourcePointerUp), this.domElement.addEventListener("mousemove", this.handleGeometrySourceMouseMove)) : console.warn("The assigned source " + this.parentSource.type + " is incompatible with the interaction " + this.type + ".");
  }
  initialize() {
    this.handleGeometrySourcePointerUp = this.handleGeometrySourcePointerUp.bind(this), this.handleGeometrySourceMouseMove = this.handleGeometrySourceMouseMove.bind(this), this.addEventListeners();
  }
  remove() {
    this.selectedObject = void 0, this.selectedMeasurement = void 0, this.selectedVector = {
      index: void 0,
      coordinates: void 0,
      holeIndex: void 0
    };
  }
  setActive(n) {
    n == !0 ? this.active = !0 : (this.active = !1, this.remove());
  }
  removeSelectedVertex() {
    this.selectedObject && this.selectedObject instanceof Zi && this.selectedObject.vectors.length > 2 && (this.selectedObject.vectors.splice(this.selectedVector.index, 1), this.selectedObject.update(), this.dispatchModifyEnd(), this.clearSelection()), this.selectedObject && this.selectedObject instanceof Dn && this.selectedObject.vectors.length > 3 && (this.selectedObject.vectors.splice(this.selectedVector.index, 1), this.selectedObject.update(), this.dispatchModifyEnd(), this.clearSelection());
  }
  handleGeometrySourcePointerUp(n) {
    if (this.active && (this.handleGeometrySourceMouseMove(), n.button == this.button && Rt.cursor.movedMouse == !1)) {
      let r = this.getMouseIntersect(n);
      if (this.selectedObject && this.selectedVector.coordinates)
        this.dispatchModifyEnd(), this.clearSelection();
      else if (r || Rt.cursor.snapped || this.target) {
        if (this.target ? this.selectedObject = this.target : this.parentSource.geometries.includes(Rt.cursor.snappedObject) ? this.selectedObject = Rt.cursor.snappedObject : r && (this.selectedObject = r.object.userData), this.selectedObject) {
          this.selectedObject.beingModified = !0;
          let s = new z(...Rt.cursor.position), o = [0, 0, 0], a = null, l = 0;
          if (this.selectedObject.vectors)
            if (this.selectedObject instanceof Fr) {
              let [c, h, d] = this.selectedObject.vectors;
              (s.distanceTo(new z(c, h, d)) < a || a === null) && (a = s.distanceTo(new z(c, h, d)), o = [c, h, d], l = i), a < this.clickRange && (this.selectedVector = { coordinates: o, index: l, holeIndex: void 0 });
            } else {
              for (let c = 0; c < this.selectedObject.vectors.length; c++) {
                let [h, d, u] = this.selectedObject.vectors[c];
                (s.distanceTo(new z(h, d, u)) < a || a === null) && (a = s.distanceTo(new z(h, d, u)), o = [h, d, u], l = c);
              }
              a < this.clickRange && (this.selectedVector = { coordinates: o, index: l, holeIndex: void 0 });
            }
          if (this.selectedObject.holes)
            for (let c = 0; c < this.selectedObject.holes.length; c++) {
              let h = [0, 0, 0], d = null, u = 0;
              for (let p = 0; p < this.selectedObject.holes[c].length; p++) {
                let [f, m, y] = this.selectedObject.holes[c][p];
                (s.distanceTo(new z(f, m, y)) < d || d === null) && (d = s.distanceTo(new z(f, m, y)), h = [f, m, y], u = p);
              }
              d < this.clickRange && (!a || d < a) && (this.selectedVector = { coordinates: h, index: u, holeIndex: c });
            }
          if (!this.selectedVector.index && !this.selectedVector.coordinates && !this.selectedVector.holeIndex && (r || Rt.cursor.snapped && Rt.cursor.snappedObject == this.selectedObject)) {
            let c;
            if (r && r.point ? c = r.point : c = new z(...Rt.cursor.mousePosition), (this.selectedObject instanceof Zi || this.selectedObject instanceof Dn) && this.selectedObject.vectors) {
              for (let h = 1; h < this.selectedObject.vectors.length; h++)
                if (this.vectorIsOnLine(this.selectedObject.vectors[h - 1], this.selectedObject.vectors[h], c.toArray())) {
                  this.selectedObject.vectors.splice(h, 0, c.toArray()), this.selectedObject.update(), this.selectedVector = {
                    index: h,
                    coordinates: c.toArray(),
                    holeIndex: void 0
                  };
                  break;
                }
              if (this.selectedObject.holes) {
                for (let h = 0; h < this.selectedObject.holes.length; h++)
                  for (let d = 1; d < this.selectedObject.holes[h].length; d++)
                    if (this.vectorIsOnLine(this.selectedObject.holes[h][d - 1], this.selectedObject.holes[h][d], c.toArray())) {
                      this.selectedObject.holes[h].splice(d, 0, c.toArray()), this.selectedObject.update(), this.selectedVector = {
                        index: d,
                        coordinates: c.toArray(),
                        holeIndex: h
                      };
                      break;
                    }
              }
              this.selectedObject instanceof Dn && this.selectedObject.vectors.length > 1 && this.vectorIsOnLine(this.selectedObject.vectors[0], this.selectedObject.vectors[this.selectedObject.vectors.length - 1], c.toArray()) && (this.selectedObject.vectors.splice(this.selectedObject.vectors.length, 0, c.toArray()), this.selectedObject.update(), this.selectedVector = {
                index: this.selectedObject.vectors.length - 1,
                coordinates: c.toArray(),
                holeIndex: void 0
              });
            }
          }
          this.dispatchModifyStart();
        }
      } else
        this.clearSelection();
    }
  }
  vectorIsOnLine(n, r, s) {
    let o = new z(...n), a = new z(...r), l = new z(...s);
    return Math.floor(o.distanceTo(l) + a.distanceTo(l)) == Math.floor(a.distanceTo(o));
  }
  handleGeometrySourceMouseMove() {
    this.active && (this.selectedObject && (this.selectedObject.beingModified = !0), this.selectedVector.coordinates != null && this.selectedVector.index != null && (this.selectedVector.holeIndex == null ? (this.selectedVector.coordinates = Rt.cursor.position, this.selectedObject.vectors[this.selectedVector.index] = this.selectedVector.coordinates) : (this.selectedVector.coordinates = Rt.cursor.position, this.selectedObject.holes[this.selectedVector.holeIndex][this.selectedVector.index] = this.selectedVector.coordinates), this.selectedObject instanceof Fr ? this.parentSource.updatePoints() : this.selectedObject.update()));
  }
  clearSelection() {
    this.selectedVector && (this.selectedVector = {
      coordinates: void 0,
      index: void 0,
      holeIndex: void 0
    }), this.selectedObject && (this.selectedObject.beingModified = !1, this.selectedObject = void 0), this.selectedMeasurement && (this.selectedMeasurement = void 0);
  }
  getMouseIntersect(n) {
    let r = [], s = new ye(
      n.layerX / this.domElement.getBoundingClientRect().width * 2 - 1,
      // x
      -(n.layerY / this.domElement.getBoundingClientRect().height) * 2 + 1
      // y
    );
    if (this.raycaster.setFromCamera(s, Ce.scene.getActiveCamera()), this.parentSource.models && r.push(...this.raycaster.intersectObjects(this.parentSource.models, !0)), this.parentSource instanceof Go && this.parentSource.pointscloud && this.parentSource.pointscloud && this.parentSource.points.length > 0) {
      let o = this.raycaster.intersectObject(this.parentSource.pointscloud, !0);
      for (let a of o)
        r.push({ object: { userData: this.parentSource.points[a.index] }, point: a.point, distance: a.distance });
    }
    return r.sort((o, a) => o.distance > a.distance ? 1 : -1), r[0];
  }
  dispatchModifyStart() {
    const n = new CustomEvent("modifystart", {
      detail: {
        object: this.selectedObject,
        measurement: this.selectedMeasurement,
        editedVector: this.selectedVector,
        source: this.parentSource
      }
    });
    this.dispatchEvent(n), this.parentSource.dispatchEvent(n);
  }
  dispatchModifyEnd() {
    const n = new CustomEvent("modifyend", {
      detail: {
        object: this.selectedObject,
        measurement: this.selectedMeasurement,
        editedVector: this.selectedVector,
        source: this.parentSource
      }
    });
    this.dispatchEvent(n), this.parentSource.dispatchEvent(n);
  }
}
const xT = "124", _T = 0, bg = 1, bT = 2, Qy = 1, wT = 2, Ra = 3, Fl = 0, Ct = 1, su = 2, ex = 1, Ga = 0, Va = 1, wg = 2, Mg = 3, Sg = 4, MT = 5, lo = 100, ST = 101, ET = 102, Eg = 103, Tg = 104, TT = 200, AT = 201, LT = 202, CT = 203, tx = 204, nx = 205, RT = 206, PT = 207, IT = 208, DT = 209, NT = 210, OT = 0, FT = 1, BT = 2, lf = 3, zT = 4, UT = 5, HT = 6, GT = 7, ou = 0, VT = 1, kT = 2, ka = 0, WT = 1, $T = 2, jT = 3, qT = 4, XT = 5, ix = 300, sp = 301, op = 302, Ag = 303, Lg = 304, ap = 306, lp = 307, cf = 1e3, yn = 1001, hf = 1002, Xt = 1003, Cg = 1004, Rg = 1005, At = 1006, YT = 1007, au = 1008, cp = 1009, ZT = 1010, JT = 1011, Ph = 1012, KT = 1013, ch = 1014, Rr = 1015, Ih = 1016, QT = 1017, eA = 1018, tA = 1019, Wa = 1020, nA = 1021, Br = 1022, Nn = 1023, iA = 1024, rA = 1025, Eo = 1026, ml = 1027, sA = 1028, oA = 1029, aA = 1030, lA = 1031, cA = 1032, hA = 1033, Pg = 33776, Ig = 33777, Dg = 33778, Ng = 33779, Og = 35840, Fg = 35841, Bg = 35842, zg = 35843, uA = 36196, Ug = 37492, Hg = 37496, dA = 37808, fA = 37809, pA = 37810, mA = 37811, gA = 37812, vA = 37813, yA = 37814, xA = 37815, _A = 37816, bA = 37817, wA = 37818, MA = 37819, SA = 37820, EA = 37821, TA = 36492, AA = 37840, LA = 37841, CA = 37842, RA = 37843, PA = 37844, IA = 37845, DA = 37846, NA = 37847, OA = 37848, FA = 37849, BA = 37850, zA = 37851, UA = 37852, HA = 37853, GA = 2200, VA = 2201, kA = 2202, Dh = 2300, hh = 2301, qu = 2302, go = 2400, vo = 2401, Nh = 2402, hp = 2500, rx = 2501, WA = 0, Bl = 3e3, sx = 3001, $A = 3007, jA = 3002, qA = 3003, XA = 3004, YA = 3005, ZA = 3006, JA = 3200, KA = 3201, Qo = 0, QA = 1, Xu = 7680, eL = 519, lu = 35044, gl = 35048, Gg = "300 es";
function lr() {
}
Object.assign(lr.prototype, {
  addEventListener: function(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  },
  hasEventListener: function(t, e) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  },
  removeEventListener: function(t, e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[t];
    if (r !== void 0) {
      const s = r.indexOf(e);
      s !== -1 && r.splice(s, 1);
    }
  },
  dispatchEvent: function(t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[t.type];
    if (n !== void 0) {
      t.target = this;
      const r = n.slice(0);
      for (let s = 0, o = r.length; s < o; s++)
        r[s].call(this, t);
    }
  }
});
const zt = [];
for (let t = 0; t < 256; t++)
  zt[t] = (t < 16 ? "0" : "") + t.toString(16);
let Ec = 1234567;
const Xe = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
    return (zt[t & 255] + zt[t >> 8 & 255] + zt[t >> 16 & 255] + zt[t >> 24 & 255] + "-" + zt[e & 255] + zt[e >> 8 & 255] + "-" + zt[e >> 16 & 15 | 64] + zt[e >> 24 & 255] + "-" + zt[n & 63 | 128] + zt[n >> 8 & 255] + "-" + zt[n >> 16 & 255] + zt[n >> 24 & 255] + zt[r & 255] + zt[r >> 8 & 255] + zt[r >> 16 & 255] + zt[r >> 24 & 255]).toUpperCase();
  },
  clamp: function(t, e, n) {
    return Math.max(e, Math.min(n, t));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function(t, e) {
    return (t % e + e) % e;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function(t, e, n, r, s) {
    return r + (t - e) * (s - r) / (n - e);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function(t, e, n) {
    return (1 - n) * t + n * e;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t));
  },
  smootherstep: function(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (t * 6 - 15) + 10));
  },
  // Random integer from <low, high> interval
  randInt: function(t, e) {
    return t + Math.floor(Math.random() * (e - t + 1));
  },
  // Random float from <low, high> interval
  randFloat: function(t, e) {
    return t + Math.random() * (e - t);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function(t) {
    return t * (0.5 - Math.random());
  },
  // Deterministic pseudo-random float in the interval [ 0, 1 ]
  seededRandom: function(t) {
    return t !== void 0 && (Ec = t % 2147483647), Ec = Ec * 16807 % 2147483647, (Ec - 1) / 2147483646;
  },
  degToRad: function(t) {
    return t * Xe.DEG2RAD;
  },
  radToDeg: function(t) {
    return t * Xe.RAD2DEG;
  },
  isPowerOfTwo: function(t) {
    return (t & t - 1) === 0 && t !== 0;
  },
  ceilPowerOfTwo: function(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  },
  floorPowerOfTwo: function(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(t, e, n, r, s) {
    const o = Math.cos, a = Math.sin, l = o(n / 2), c = a(n / 2), h = o((e + r) / 2), d = a((e + r) / 2), u = o((e - r) / 2), p = a((e - r) / 2), f = o((r - e) / 2), m = a((r - e) / 2);
    switch (s) {
      case "XYX":
        t.set(l * d, c * u, c * p, l * h);
        break;
      case "YZY":
        t.set(c * p, l * d, c * u, l * h);
        break;
      case "ZXZ":
        t.set(c * u, c * p, l * d, l * h);
        break;
      case "XZX":
        t.set(l * d, c * m, c * f, l * h);
        break;
      case "YXY":
        t.set(c * f, l * d, c * m, l * h);
        break;
      case "ZYZ":
        t.set(c * m, c * f, l * d, l * h);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
    }
  }
};
class xe {
  constructor(e = 0, n = 0) {
    Object.defineProperty(this, "isVector2", { value: !0 }), this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, n)) : (this.x += e.x, this.y += e.y, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, n)) : (this.x -= e.x, this.y -= e.y, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, r = this.y, s = e.elements;
    return this.x = s[0] * n + s[3] * r + s[6], this.y = s[1] * n + s[4] * r + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, r = this.y - e.y;
    return n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, r) {
    return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n, r) {
    return r !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const r = Math.cos(n), s = Math.sin(n), o = this.x - e.x, a = this.y - e.y;
    return this.x = o * r - a * s + e.x, this.y = o * s + a * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
}
class hn {
  constructor() {
    Object.defineProperty(this, "isMatrix3", { value: !0 }), this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e, n, r, s, o, a, l, c, h) {
    const d = this.elements;
    return d[0] = e, d[1] = s, d[2] = l, d[3] = n, d[4] = o, d[5] = c, d[6] = r, d[7] = a, d[8] = h, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, r = e.elements;
    return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], this;
  }
  extractBasis(e, n, r) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements, s = n.elements, o = this.elements, a = r[0], l = r[3], c = r[6], h = r[1], d = r[4], u = r[7], p = r[2], f = r[5], m = r[8], y = s[0], x = s[3], v = s[6], g = s[1], S = s[4], T = s[7], E = s[2], w = s[5], C = s[8];
    return o[0] = a * y + l * g + c * E, o[3] = a * x + l * S + c * w, o[6] = a * v + l * T + c * C, o[1] = h * y + d * g + u * E, o[4] = h * x + d * S + u * w, o[7] = h * v + d * T + u * C, o[2] = p * y + f * g + m * E, o[5] = p * x + f * S + m * w, o[8] = p * v + f * T + m * C, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], h = e[7], d = e[8];
    return n * a * d - n * l * h - r * o * d + r * l * c + s * o * h - s * a * c;
  }
  invert() {
    const e = this.elements, n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], h = e[7], d = e[8], u = d * a - l * h, p = l * c - d * o, f = h * o - a * c, m = n * u + r * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / m;
    return e[0] = u * y, e[1] = (s * h - d * r) * y, e[2] = (l * r - s * a) * y, e[3] = p * y, e[4] = (d * n - s * c) * y, e[5] = (s * o - l * n) * y, e[6] = f * y, e[7] = (r * c - h * n) * y, e[8] = (a * n - r * o) * y, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).copy(this).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, r, s, o, a, l) {
    const c = Math.cos(o), h = Math.sin(o);
    return this.set(
      r * c,
      r * h,
      -r * (c * a + h * l) + a + e,
      -s * h,
      s * c,
      -s * (-h * a + c * l) + l + n,
      0,
      0,
      1
    ), this;
  }
  scale(e, n) {
    const r = this.elements;
    return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= n, r[4] *= n, r[7] *= n, this;
  }
  rotate(e) {
    const n = Math.cos(e), r = Math.sin(e), s = this.elements, o = s[0], a = s[3], l = s[6], c = s[1], h = s[4], d = s[7];
    return s[0] = n * o + r * c, s[3] = n * a + r * h, s[6] = n * l + r * d, s[1] = -r * o + n * c, s[4] = -r * a + n * h, s[7] = -r * l + n * d, this;
  }
  translate(e, n) {
    const r = this.elements;
    return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += n * r[2], r[4] += n * r[5], r[7] += n * r[8], this;
  }
  equals(e) {
    const n = this.elements, r = e.elements;
    for (let s = 0; s < 9; s++)
      if (n[s] !== r[s]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e;
  }
}
let Ws;
const ea = {
  getDataURL: function(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement)
      e = t;
    else {
      Ws === void 0 && (Ws = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Ws.width = t.width, Ws.height = t.height;
      const n = Ws.getContext("2d");
      t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Ws;
    }
    return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", 0.6) : e.toDataURL("image/png");
  }
};
let tL = 0;
function ut(t = ut.DEFAULT_IMAGE, e = ut.DEFAULT_MAPPING, n = yn, r = yn, s = At, o = au, a = Nn, l = cp, c = 1, h = Bl) {
  Object.defineProperty(this, "id", { value: tL++ }), this.uuid = Xe.generateUUID(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new xe(0, 0), this.repeat = new xe(1, 1), this.center = new xe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new hn(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.version = 0, this.onUpdate = null;
}
ut.DEFAULT_IMAGE = void 0;
ut.DEFAULT_MAPPING = ix;
ut.prototype = Object.assign(Object.create(lr.prototype), {
  constructor: ut,
  isTexture: !0,
  updateMatrix: function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const r = this.image;
      if (r.uuid === void 0 && (r.uuid = Xe.generateUUID()), !e && t.images[r.uuid] === void 0) {
        let s;
        if (Array.isArray(r)) {
          s = [];
          for (let o = 0, a = r.length; o < a; o++)
            r[o].isDataTexture ? s.push(Yu(r[o].image)) : s.push(Yu(r[o]));
        } else
          s = Yu(r);
        t.images[r.uuid] = {
          uuid: r.uuid,
          url: s
        };
      }
      n.image = r.uuid;
    }
    return e || (t.textures[this.uuid] = n), n;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function(t) {
    if (this.mapping !== ix) return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case cf:
          t.x = t.x - Math.floor(t.x);
          break;
        case yn:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case hf:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case cf:
          t.y = t.y - Math.floor(t.y);
          break;
        case yn:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case hf:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
});
Object.defineProperty(ut.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
function Yu(t) {
  return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? ea.getDataURL(t) : t.data ? {
    data: Array.prototype.slice.call(t.data),
    width: t.width,
    height: t.height,
    type: t.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
class st {
  constructor(e = 0, n = 0, r = 0, s = 1) {
    Object.defineProperty(this, "isVector4", { value: !0 }), this.x = e, this.y = n, this.z = r, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, r, s) {
    return this.x = e, this.y = n, this.z = r, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, n)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, n)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, r = this.y, s = this.z, o = this.w, a = e.elements;
    return this.x = a[0] * n + a[4] * r + a[8] * s + a[12] * o, this.y = a[1] * n + a[5] * r + a[9] * s + a[13] * o, this.z = a[2] * n + a[6] * r + a[10] * s + a[14] * o, this.w = a[3] * n + a[7] * r + a[11] * s + a[15] * o, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, r, s, o;
    const c = e.elements, h = c[0], d = c[4], u = c[8], p = c[1], f = c[5], m = c[9], y = c[2], x = c[6], v = c[10];
    if (Math.abs(d - p) < 0.01 && Math.abs(u - y) < 0.01 && Math.abs(m - x) < 0.01) {
      if (Math.abs(d + p) < 0.1 && Math.abs(u + y) < 0.1 && Math.abs(m + x) < 0.1 && Math.abs(h + f + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const S = (h + 1) / 2, T = (f + 1) / 2, E = (v + 1) / 2, w = (d + p) / 4, C = (u + y) / 4, ee = (m + x) / 4;
      return S > T && S > E ? S < 0.01 ? (r = 0, s = 0.707106781, o = 0.707106781) : (r = Math.sqrt(S), s = w / r, o = C / r) : T > E ? T < 0.01 ? (r = 0.707106781, s = 0, o = 0.707106781) : (s = Math.sqrt(T), r = w / s, o = ee / s) : E < 0.01 ? (r = 0.707106781, s = 0.707106781, o = 0) : (o = Math.sqrt(E), r = C / o, s = ee / o), this.set(r, s, o, n), this;
    }
    let g = Math.sqrt((x - m) * (x - m) + (u - y) * (u - y) + (p - d) * (p - d));
    return Math.abs(g) < 1e-3 && (g = 1), this.x = (x - m) / g, this.y = (u - y) / g, this.z = (p - d) / g, this.w = Math.acos((h + f + v - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, r) {
    return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this.w = e.w + (n.w - e.w) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n, r) {
    return r !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
}
function ai(t, e, n) {
  this.width = t, this.height = e, this.scissor = new st(0, 0, t, e), this.scissorTest = !1, this.viewport = new st(0, 0, t, e), n = n || {}, this.texture = new ut(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : At, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null;
}
ai.prototype = Object.assign(Object.create(lr.prototype), {
  constructor: ai,
  isWebGLRenderTarget: !0,
  setSize: function(t, e) {
    (this.width !== t || this.height !== e) && (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function Vg(t, e, n) {
  ai.call(this, t, e, n), this.samples = 4;
}
Vg.prototype = Object.assign(Object.create(ai.prototype), {
  constructor: Vg,
  isWebGLMultisampleRenderTarget: !0,
  copy: function(t) {
    return ai.prototype.copy.call(this, t), this.samples = t.samples, this;
  }
});
class Mn {
  constructor(e = 0, n = 0, r = 0, s = 1) {
    Object.defineProperty(this, "isQuaternion", { value: !0 }), this._x = e, this._y = n, this._z = r, this._w = s;
  }
  static slerp(e, n, r, s) {
    return r.copy(e).slerp(n, s);
  }
  static slerpFlat(e, n, r, s, o, a, l) {
    let c = r[s + 0], h = r[s + 1], d = r[s + 2], u = r[s + 3];
    const p = o[a + 0], f = o[a + 1], m = o[a + 2], y = o[a + 3];
    if (u !== y || c !== p || h !== f || d !== m) {
      let x = 1 - l;
      const v = c * p + h * f + d * m + u * y, g = v >= 0 ? 1 : -1, S = 1 - v * v;
      if (S > Number.EPSILON) {
        const E = Math.sqrt(S), w = Math.atan2(E, v * g);
        x = Math.sin(x * w) / E, l = Math.sin(l * w) / E;
      }
      const T = l * g;
      if (c = c * x + p * T, h = h * x + f * T, d = d * x + m * T, u = u * x + y * T, x === 1 - l) {
        const E = 1 / Math.sqrt(c * c + h * h + d * d + u * u);
        c *= E, h *= E, d *= E, u *= E;
      }
    }
    e[n] = c, e[n + 1] = h, e[n + 2] = d, e[n + 3] = u;
  }
  static multiplyQuaternionsFlat(e, n, r, s, o, a) {
    const l = r[s], c = r[s + 1], h = r[s + 2], d = r[s + 3], u = o[a], p = o[a + 1], f = o[a + 2], m = o[a + 3];
    return e[n] = l * m + d * u + c * f - h * p, e[n + 1] = c * m + d * p + h * u - l * f, e[n + 2] = h * m + d * f + l * p - c * u, e[n + 3] = d * m - l * u - c * p - h * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, r, s) {
    return this._x = e, this._y = n, this._z = r, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const r = e._x, s = e._y, o = e._z, a = e._order, l = Math.cos, c = Math.sin, h = l(r / 2), d = l(s / 2), u = l(o / 2), p = c(r / 2), f = c(s / 2), m = c(o / 2);
    switch (a) {
      case "XYZ":
        this._x = p * d * u + h * f * m, this._y = h * f * u - p * d * m, this._z = h * d * m + p * f * u, this._w = h * d * u - p * f * m;
        break;
      case "YXZ":
        this._x = p * d * u + h * f * m, this._y = h * f * u - p * d * m, this._z = h * d * m - p * f * u, this._w = h * d * u + p * f * m;
        break;
      case "ZXY":
        this._x = p * d * u - h * f * m, this._y = h * f * u + p * d * m, this._z = h * d * m + p * f * u, this._w = h * d * u - p * f * m;
        break;
      case "ZYX":
        this._x = p * d * u - h * f * m, this._y = h * f * u + p * d * m, this._z = h * d * m - p * f * u, this._w = h * d * u + p * f * m;
        break;
      case "YZX":
        this._x = p * d * u + h * f * m, this._y = h * f * u + p * d * m, this._z = h * d * m - p * f * u, this._w = h * d * u - p * f * m;
        break;
      case "XZY":
        this._x = p * d * u - h * f * m, this._y = h * f * u - p * d * m, this._z = h * d * m + p * f * u, this._w = h * d * u + p * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return n !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const r = n / 2, s = Math.sin(r);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, r = n[0], s = n[4], o = n[8], a = n[1], l = n[5], c = n[9], h = n[2], d = n[6], u = n[10], p = r + l + u;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (d - c) * f, this._y = (o - h) * f, this._z = (a - s) * f;
    } else if (r > l && r > u) {
      const f = 2 * Math.sqrt(1 + r - l - u);
      this._w = (d - c) / f, this._x = 0.25 * f, this._y = (s + a) / f, this._z = (o + h) / f;
    } else if (l > u) {
      const f = 2 * Math.sqrt(1 + l - r - u);
      this._w = (o - h) / f, this._x = (s + a) / f, this._y = 0.25 * f, this._z = (c + d) / f;
    } else {
      const f = 2 * Math.sqrt(1 + u - r - l);
      this._w = (a - s) / f, this._x = (o + h) / f, this._y = (c + d) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let s = e.dot(n) + 1;
    return s < 1e-6 ? (s = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = s) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = s)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = s), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Xe.clamp(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const s = Math.min(1, n / r);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e, n) {
    return n !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, n)) : this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const r = e._x, s = e._y, o = e._z, a = e._w, l = n._x, c = n._y, h = n._z, d = n._w;
    return this._x = r * d + a * l + s * h - o * c, this._y = s * d + a * c + o * l - r * h, this._z = o * d + a * h + r * c - s * l, this._w = a * d - r * l - s * c - o * h, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const r = this._x, s = this._y, o = this._z, a = this._w;
    let l = a * e._w + r * e._x + s * e._y + o * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = a, this._x = r, this._y = s, this._z = o, this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const f = 1 - n;
      return this._w = f * a + n * this._w, this._x = f * r + n * this._x, this._y = f * s + n * this._y, this._z = f * o + n * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const h = Math.sqrt(c), d = Math.atan2(h, l), u = Math.sin((1 - n) * d) / h, p = Math.sin(n * d) / h;
    return this._w = a * u + this._w * p, this._x = r * u + this._x * p, this._y = s * u + this._y * p, this._z = o * u + this._z * p, this._onChangeCallback(), this;
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
}
class F {
  constructor(e = 0, n = 0, r = 0) {
    Object.defineProperty(this, "isVector3", { value: !0 }), this.x = e, this.y = n, this.z = r;
  }
  set(e, n, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = n, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, n)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, n)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, n)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(kg.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(kg.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, r = this.y, s = this.z, o = e.elements;
    return this.x = o[0] * n + o[3] * r + o[6] * s, this.y = o[1] * n + o[4] * r + o[7] * s, this.z = o[2] * n + o[5] * r + o[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, r = this.y, s = this.z, o = e.elements, a = 1 / (o[3] * n + o[7] * r + o[11] * s + o[15]);
    return this.x = (o[0] * n + o[4] * r + o[8] * s + o[12]) * a, this.y = (o[1] * n + o[5] * r + o[9] * s + o[13]) * a, this.z = (o[2] * n + o[6] * r + o[10] * s + o[14]) * a, this;
  }
  applyQuaternion(e) {
    const n = this.x, r = this.y, s = this.z, o = e.x, a = e.y, l = e.z, c = e.w, h = c * n + a * s - l * r, d = c * r + l * n - o * s, u = c * s + o * r - a * n, p = -o * n - a * r - l * s;
    return this.x = h * c + p * -o + d * -l - u * -a, this.y = d * c + p * -a + u * -o - h * -l, this.z = u * c + p * -l + h * -a - d * -o, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, r = this.y, s = this.z, o = e.elements;
    return this.x = o[0] * n + o[4] * r + o[8] * s, this.y = o[1] * n + o[5] * r + o[9] * s, this.z = o[2] * n + o[6] * r + o[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, r) {
    return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this;
  }
  cross(e, n) {
    return n !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, n)) : this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const r = e.x, s = e.y, o = e.z, a = n.x, l = n.y, c = n.z;
    return this.x = s * c - o * l, this.y = o * a - r * c, this.z = r * l - s * a, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / n;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return Zu.copy(this).projectOnVector(e), this.sub(Zu);
  }
  reflect(e) {
    return this.sub(Zu.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const r = this.dot(e) / n;
    return Math.acos(Xe.clamp(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, r = this.y - e.y, s = this.z - e.z;
    return n * n + r * r + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, r) {
    const s = Math.sin(n) * e;
    return this.x = s * Math.sin(r), this.y = Math.cos(n) * e, this.z = s * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, r) {
    return this.x = e * Math.sin(n), this.y = r, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = r, this.z = s, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n, r) {
    return r !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
}
const Zu = /* @__PURE__ */ new F(), kg = /* @__PURE__ */ new Mn();
class Un {
  constructor(e, n) {
    Object.defineProperty(this, "isBox3", { value: !0 }), this.min = e !== void 0 ? e : new F(1 / 0, 1 / 0, 1 / 0), this.max = n !== void 0 ? n : new F(-1 / 0, -1 / 0, -1 / 0);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    let n = 1 / 0, r = 1 / 0, s = 1 / 0, o = -1 / 0, a = -1 / 0, l = -1 / 0;
    for (let c = 0, h = e.length; c < h; c += 3) {
      const d = e[c], u = e[c + 1], p = e[c + 2];
      d < n && (n = d), u < r && (r = u), p < s && (s = p), d > o && (o = d), u > a && (a = u), p > l && (l = p);
    }
    return this.min.set(n, r, s), this.max.set(o, a, l), this;
  }
  setFromBufferAttribute(e) {
    let n = 1 / 0, r = 1 / 0, s = 1 / 0, o = -1 / 0, a = -1 / 0, l = -1 / 0;
    for (let c = 0, h = e.count; c < h; c++) {
      const d = e.getX(c), u = e.getY(c), p = e.getZ(c);
      d < n && (n = d), u < r && (r = u), p < s && (s = p), d > o && (o = d), u > a && (a = u), p > l && (l = p);
    }
    return this.min.set(n, r, s), this.max.set(o, a, l), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = ya.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e) {
    return this.makeEmpty(), this.expandByObject(e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new F()), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), e = new F()), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    n !== void 0 && (n.boundingBox === null && n.computeBoundingBox(), Ku.copy(n.boundingBox), Ku.applyMatrix4(e.matrixWorld), this.union(Ku));
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++)
      this.expandByObject(r[s]);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), n = new F()), n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, ya), ya.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, r;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, r += e.normal.z * this.min.z), n <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(xa), Tc.subVectors(this.max, xa), $s.subVectors(e.a, xa), js.subVectors(e.b, xa), qs.subVectors(e.c, xa), br.subVectors(js, $s), wr.subVectors(qs, js), as.subVectors($s, qs);
    let n = [
      0,
      -br.z,
      br.y,
      0,
      -wr.z,
      wr.y,
      0,
      -as.z,
      as.y,
      br.z,
      0,
      -br.x,
      wr.z,
      0,
      -wr.x,
      as.z,
      0,
      -as.x,
      -br.y,
      br.x,
      0,
      -wr.y,
      wr.x,
      0,
      -as.y,
      as.x,
      0
    ];
    return !Ju(n, $s, js, qs, Tc) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Ju(n, $s, js, qs, Tc)) ? !1 : (Ac.crossVectors(br, wr), n = [Ac.x, Ac.y, Ac.z], Ju(n, $s, js, qs, Tc));
  }
  clampPoint(e, n) {
    return n === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), n = new F()), n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return ya.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return e === void 0 && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = this.getSize(ya).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : ($i[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), $i[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), $i[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), $i[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), $i[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), $i[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), $i[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), $i[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints($i), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
function Ju(t, e, n, r, s) {
  for (let o = 0, a = t.length - 3; o <= a; o += 3) {
    ls.fromArray(t, o);
    const l = s.x * Math.abs(ls.x) + s.y * Math.abs(ls.y) + s.z * Math.abs(ls.z), c = e.dot(ls), h = n.dot(ls), d = r.dot(ls);
    if (Math.max(-Math.max(c, h, d), Math.min(c, h, d)) > l)
      return !1;
  }
  return !0;
}
const $i = [
  /* @__PURE__ */ new F(),
  /* @__PURE__ */ new F(),
  /* @__PURE__ */ new F(),
  /* @__PURE__ */ new F(),
  /* @__PURE__ */ new F(),
  /* @__PURE__ */ new F(),
  /* @__PURE__ */ new F(),
  /* @__PURE__ */ new F()
], ya = /* @__PURE__ */ new F(), Ku = /* @__PURE__ */ new Un(), $s = /* @__PURE__ */ new F(), js = /* @__PURE__ */ new F(), qs = /* @__PURE__ */ new F(), br = /* @__PURE__ */ new F(), wr = /* @__PURE__ */ new F(), as = /* @__PURE__ */ new F(), xa = /* @__PURE__ */ new F(), Tc = /* @__PURE__ */ new F(), Ac = /* @__PURE__ */ new F(), ls = /* @__PURE__ */ new F(), nL = /* @__PURE__ */ new Un();
class Oi {
  constructor(e, n) {
    this.center = e !== void 0 ? e : new F(), this.radius = n !== void 0 ? n : -1;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const r = this.center;
    n !== void 0 ? r.copy(n) : nL.setFromPoints(e).getCenter(r);
    let s = 0;
    for (let o = 0, a = e.length; o < a; o++)
      s = Math.max(s, r.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const r = this.center.distanceToSquared(e);
    return n === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), n = new F()), n.copy(e), r > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return e === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Un()), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
}
const ji = /* @__PURE__ */ new F(), Qu = /* @__PURE__ */ new F(), Lc = /* @__PURE__ */ new F(), Mr = /* @__PURE__ */ new F(), ed = /* @__PURE__ */ new F(), Cc = /* @__PURE__ */ new F(), td = /* @__PURE__ */ new F();
class ta {
  constructor(e, n) {
    this.origin = e !== void 0 ? e : new F(), this.direction = n !== void 0 ? n : new F(0, 0, -1);
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n === void 0 && (console.warn("THREE.Ray: .at() target is now required"), n = new F()), n.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, ji)), this;
  }
  closestPointToPoint(e, n) {
    n === void 0 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), n = new F()), n.subVectors(e, this.origin);
    const r = n.dot(this.direction);
    return r < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = ji.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (ji.copy(this.direction).multiplyScalar(n).add(this.origin), ji.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, r, s) {
    Qu.copy(e).add(n).multiplyScalar(0.5), Lc.copy(n).sub(e).normalize(), Mr.copy(this.origin).sub(Qu);
    const o = e.distanceTo(n) * 0.5, a = -this.direction.dot(Lc), l = Mr.dot(this.direction), c = -Mr.dot(Lc), h = Mr.lengthSq(), d = Math.abs(1 - a * a);
    let u, p, f, m;
    if (d > 0)
      if (u = a * c - l, p = a * l - c, m = o * d, u >= 0)
        if (p >= -m)
          if (p <= m) {
            const y = 1 / d;
            u *= y, p *= y, f = u * (u + a * p + 2 * l) + p * (a * u + p + 2 * c) + h;
          } else
            p = o, u = Math.max(0, -(a * p + l)), f = -u * u + p * (p + 2 * c) + h;
        else
          p = -o, u = Math.max(0, -(a * p + l)), f = -u * u + p * (p + 2 * c) + h;
      else
        p <= -m ? (u = Math.max(0, -(-a * o + l)), p = u > 0 ? -o : Math.min(Math.max(-o, -c), o), f = -u * u + p * (p + 2 * c) + h) : p <= m ? (u = 0, p = Math.min(Math.max(-o, -c), o), f = p * (p + 2 * c) + h) : (u = Math.max(0, -(a * o + l)), p = u > 0 ? o : Math.min(Math.max(-o, -c), o), f = -u * u + p * (p + 2 * c) + h);
    else
      p = a > 0 ? -o : o, u = Math.max(0, -(a * p + l)), f = -u * u + p * (p + 2 * c) + h;
    return r && r.copy(this.direction).multiplyScalar(u).add(this.origin), s && s.copy(Lc).multiplyScalar(p).add(Qu), f;
  }
  intersectSphere(e, n) {
    ji.subVectors(e.center, this.origin);
    const r = ji.dot(this.direction), s = ji.dot(ji) - r * r, o = e.radius * e.radius;
    if (s > o) return null;
    const a = Math.sqrt(o - s), l = r - a, c = r + a;
    return l < 0 && c < 0 ? null : l < 0 ? this.at(c, n) : this.at(l, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / n;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, n) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let r, s, o, a, l, c;
    const h = 1 / this.direction.x, d = 1 / this.direction.y, u = 1 / this.direction.z, p = this.origin;
    return h >= 0 ? (r = (e.min.x - p.x) * h, s = (e.max.x - p.x) * h) : (r = (e.max.x - p.x) * h, s = (e.min.x - p.x) * h), d >= 0 ? (o = (e.min.y - p.y) * d, a = (e.max.y - p.y) * d) : (o = (e.max.y - p.y) * d, a = (e.min.y - p.y) * d), r > a || o > s || ((o > r || r !== r) && (r = o), (a < s || s !== s) && (s = a), u >= 0 ? (l = (e.min.z - p.z) * u, c = (e.max.z - p.z) * u) : (l = (e.max.z - p.z) * u, c = (e.min.z - p.z) * u), r > c || l > s) || ((l > r || r !== r) && (r = l), (c < s || s !== s) && (s = c), s < 0) ? null : this.at(r >= 0 ? r : s, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, ji) !== null;
  }
  intersectTriangle(e, n, r, s, o) {
    ed.subVectors(n, e), Cc.subVectors(r, e), td.crossVectors(ed, Cc);
    let a = this.direction.dot(td), l;
    if (a > 0) {
      if (s) return null;
      l = 1;
    } else if (a < 0)
      l = -1, a = -a;
    else
      return null;
    Mr.subVectors(this.origin, e);
    const c = l * this.direction.dot(Cc.crossVectors(Mr, Cc));
    if (c < 0)
      return null;
    const h = l * this.direction.dot(ed.cross(Mr));
    if (h < 0 || c + h > a)
      return null;
    const d = -l * Mr.dot(td);
    return d < 0 ? null : this.at(d / a, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
}
class Ye {
  constructor() {
    Object.defineProperty(this, "isMatrix4", { value: !0 }), this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e, n, r, s, o, a, l, c, h, d, u, p, f, m, y, x) {
    const v = this.elements;
    return v[0] = e, v[4] = n, v[8] = r, v[12] = s, v[1] = o, v[5] = a, v[9] = l, v[13] = c, v[2] = h, v[6] = d, v[10] = u, v[14] = p, v[3] = f, v[7] = m, v[11] = y, v[15] = x, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Ye().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, r = e.elements;
    return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this;
  }
  copyPosition(e) {
    const n = this.elements, r = e.elements;
    return n[12] = r[12], n[13] = r[13], n[14] = r[14], this;
  }
  extractBasis(e, n, r) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, r) {
    return this.set(
      e.x,
      n.x,
      r.x,
      0,
      e.y,
      n.y,
      r.y,
      0,
      e.z,
      n.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const n = this.elements, r = e.elements, s = 1 / Xs.setFromMatrixColumn(e, 0).length(), o = 1 / Xs.setFromMatrixColumn(e, 1).length(), a = 1 / Xs.setFromMatrixColumn(e, 2).length();
    return n[0] = r[0] * s, n[1] = r[1] * s, n[2] = r[2] * s, n[3] = 0, n[4] = r[4] * o, n[5] = r[5] * o, n[6] = r[6] * o, n[7] = 0, n[8] = r[8] * a, n[9] = r[9] * a, n[10] = r[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    const n = this.elements, r = e.x, s = e.y, o = e.z, a = Math.cos(r), l = Math.sin(r), c = Math.cos(s), h = Math.sin(s), d = Math.cos(o), u = Math.sin(o);
    if (e.order === "XYZ") {
      const p = a * d, f = a * u, m = l * d, y = l * u;
      n[0] = c * d, n[4] = -c * u, n[8] = h, n[1] = f + m * h, n[5] = p - y * h, n[9] = -l * c, n[2] = y - p * h, n[6] = m + f * h, n[10] = a * c;
    } else if (e.order === "YXZ") {
      const p = c * d, f = c * u, m = h * d, y = h * u;
      n[0] = p + y * l, n[4] = m * l - f, n[8] = a * h, n[1] = a * u, n[5] = a * d, n[9] = -l, n[2] = f * l - m, n[6] = y + p * l, n[10] = a * c;
    } else if (e.order === "ZXY") {
      const p = c * d, f = c * u, m = h * d, y = h * u;
      n[0] = p - y * l, n[4] = -a * u, n[8] = m + f * l, n[1] = f + m * l, n[5] = a * d, n[9] = y - p * l, n[2] = -a * h, n[6] = l, n[10] = a * c;
    } else if (e.order === "ZYX") {
      const p = a * d, f = a * u, m = l * d, y = l * u;
      n[0] = c * d, n[4] = m * h - f, n[8] = p * h + y, n[1] = c * u, n[5] = y * h + p, n[9] = f * h - m, n[2] = -h, n[6] = l * c, n[10] = a * c;
    } else if (e.order === "YZX") {
      const p = a * c, f = a * h, m = l * c, y = l * h;
      n[0] = c * d, n[4] = y - p * u, n[8] = m * u + f, n[1] = u, n[5] = a * d, n[9] = -l * d, n[2] = -h * d, n[6] = f * u + m, n[10] = p - y * u;
    } else if (e.order === "XZY") {
      const p = a * c, f = a * h, m = l * c, y = l * h;
      n[0] = c * d, n[4] = -u, n[8] = h * d, n[1] = p * u + y, n[5] = a * d, n[9] = f * u - m, n[2] = m * u - f, n[6] = l * d, n[10] = y * u + p;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(iL, e, rL);
  }
  lookAt(e, n, r) {
    const s = this.elements;
    return gn.subVectors(e, n), gn.lengthSq() === 0 && (gn.z = 1), gn.normalize(), Sr.crossVectors(r, gn), Sr.lengthSq() === 0 && (Math.abs(r.z) === 1 ? gn.x += 1e-4 : gn.z += 1e-4, gn.normalize(), Sr.crossVectors(r, gn)), Sr.normalize(), Rc.crossVectors(gn, Sr), s[0] = Sr.x, s[4] = Rc.x, s[8] = gn.x, s[1] = Sr.y, s[5] = Rc.y, s[9] = gn.y, s[2] = Sr.z, s[6] = Rc.z, s[10] = gn.z, this;
  }
  multiply(e, n) {
    return n !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, n)) : this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements, s = n.elements, o = this.elements, a = r[0], l = r[4], c = r[8], h = r[12], d = r[1], u = r[5], p = r[9], f = r[13], m = r[2], y = r[6], x = r[10], v = r[14], g = r[3], S = r[7], T = r[11], E = r[15], w = s[0], C = s[4], ee = s[8], Y = s[12], le = s[1], B = s[5], Z = s[9], k = s[13], O = s[2], P = s[6], j = s[10], re = s[14], ae = s[3], ce = s[7], pe = s[11], de = s[15];
    return o[0] = a * w + l * le + c * O + h * ae, o[4] = a * C + l * B + c * P + h * ce, o[8] = a * ee + l * Z + c * j + h * pe, o[12] = a * Y + l * k + c * re + h * de, o[1] = d * w + u * le + p * O + f * ae, o[5] = d * C + u * B + p * P + f * ce, o[9] = d * ee + u * Z + p * j + f * pe, o[13] = d * Y + u * k + p * re + f * de, o[2] = m * w + y * le + x * O + v * ae, o[6] = m * C + y * B + x * P + v * ce, o[10] = m * ee + y * Z + x * j + v * pe, o[14] = m * Y + y * k + x * re + v * de, o[3] = g * w + S * le + T * O + E * ae, o[7] = g * C + S * B + T * P + E * ce, o[11] = g * ee + S * Z + T * j + E * pe, o[15] = g * Y + S * k + T * re + E * de, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], r = e[4], s = e[8], o = e[12], a = e[1], l = e[5], c = e[9], h = e[13], d = e[2], u = e[6], p = e[10], f = e[14], m = e[3], y = e[7], x = e[11], v = e[15];
    return m * (+o * c * u - s * h * u - o * l * p + r * h * p + s * l * f - r * c * f) + y * (+n * c * f - n * h * p + o * a * p - s * a * f + s * h * d - o * c * d) + x * (+n * h * u - n * l * f - o * a * u + r * a * f + o * l * d - r * h * d) + v * (-s * l * d - n * c * u + n * l * p + s * a * u - r * a * p + r * c * d);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, r) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = n, s[14] = r), this;
  }
  invert() {
    const e = this.elements, n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], h = e[7], d = e[8], u = e[9], p = e[10], f = e[11], m = e[12], y = e[13], x = e[14], v = e[15], g = u * x * h - y * p * h + y * c * f - l * x * f - u * c * v + l * p * v, S = m * p * h - d * x * h - m * c * f + a * x * f + d * c * v - a * p * v, T = d * y * h - m * u * h + m * l * f - a * y * f - d * l * v + a * u * v, E = m * u * c - d * y * c - m * l * p + a * y * p + d * l * x - a * u * x, w = n * g + r * S + s * T + o * E;
    if (w === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const C = 1 / w;
    return e[0] = g * C, e[1] = (y * p * o - u * x * o - y * s * f + r * x * f + u * s * v - r * p * v) * C, e[2] = (l * x * o - y * c * o + y * s * h - r * x * h - l * s * v + r * c * v) * C, e[3] = (u * c * o - l * p * o - u * s * h + r * p * h + l * s * f - r * c * f) * C, e[4] = S * C, e[5] = (d * x * o - m * p * o + m * s * f - n * x * f - d * s * v + n * p * v) * C, e[6] = (m * c * o - a * x * o - m * s * h + n * x * h + a * s * v - n * c * v) * C, e[7] = (a * p * o - d * c * o + d * s * h - n * p * h - a * s * f + n * c * f) * C, e[8] = T * C, e[9] = (m * u * o - d * y * o - m * r * f + n * y * f + d * r * v - n * u * v) * C, e[10] = (a * y * o - m * l * o + m * r * h - n * y * h - a * r * v + n * l * v) * C, e[11] = (d * l * o - a * u * o - d * r * h + n * u * h + a * r * f - n * l * f) * C, e[12] = E * C, e[13] = (d * y * s - m * u * s + m * r * p - n * y * p - d * r * x + n * u * x) * C, e[14] = (m * l * s - a * y * s - m * r * c + n * y * c + a * r * x - n * l * x) * C, e[15] = (a * u * s - d * l * s + d * r * c - n * u * c - a * r * p + n * l * p) * C, this;
  }
  scale(e) {
    const n = this.elements, r = e.x, s = e.y, o = e.z;
    return n[0] *= r, n[4] *= s, n[8] *= o, n[1] *= r, n[5] *= s, n[9] *= o, n[2] *= r, n[6] *= s, n[10] *= o, n[3] *= r, n[7] *= s, n[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, r, s));
  }
  makeTranslation(e, n, r) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -r,
      0,
      0,
      r,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), r = Math.sin(e);
    return this.set(
      n,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), r = Math.sin(e);
    return this.set(
      n,
      -r,
      0,
      0,
      r,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, n) {
    const r = Math.cos(n), s = Math.sin(n), o = 1 - r, a = e.x, l = e.y, c = e.z, h = o * a, d = o * l;
    return this.set(
      h * a + r,
      h * l - s * c,
      h * c + s * l,
      0,
      h * l + s * c,
      d * l + r,
      d * c - s * a,
      0,
      h * c - s * l,
      d * c + s * a,
      o * c * c + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, n, r) {
    return this.set(
      1,
      n,
      r,
      0,
      e,
      1,
      r,
      0,
      e,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, n, r) {
    const s = this.elements, o = n._x, a = n._y, l = n._z, c = n._w, h = o + o, d = a + a, u = l + l, p = o * h, f = o * d, m = o * u, y = a * d, x = a * u, v = l * u, g = c * h, S = c * d, T = c * u, E = r.x, w = r.y, C = r.z;
    return s[0] = (1 - (y + v)) * E, s[1] = (f + T) * E, s[2] = (m - S) * E, s[3] = 0, s[4] = (f - T) * w, s[5] = (1 - (p + v)) * w, s[6] = (x + g) * w, s[7] = 0, s[8] = (m + S) * C, s[9] = (x - g) * C, s[10] = (1 - (p + y)) * C, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, n, r) {
    const s = this.elements;
    let o = Xs.set(s[0], s[1], s[2]).length();
    const a = Xs.set(s[4], s[5], s[6]).length(), l = Xs.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (o = -o), e.x = s[12], e.y = s[13], e.z = s[14], Zn.copy(this);
    const h = 1 / o, d = 1 / a, u = 1 / l;
    return Zn.elements[0] *= h, Zn.elements[1] *= h, Zn.elements[2] *= h, Zn.elements[4] *= d, Zn.elements[5] *= d, Zn.elements[6] *= d, Zn.elements[8] *= u, Zn.elements[9] *= u, Zn.elements[10] *= u, n.setFromRotationMatrix(Zn), r.x = o, r.y = a, r.z = l, this;
  }
  makePerspective(e, n, r, s, o, a) {
    a === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    const l = this.elements, c = 2 * o / (n - e), h = 2 * o / (r - s), d = (n + e) / (n - e), u = (r + s) / (r - s), p = -(a + o) / (a - o), f = -2 * a * o / (a - o);
    return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = h, l[9] = u, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = f, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, n, r, s, o, a) {
    const l = this.elements, c = 1 / (n - e), h = 1 / (r - s), d = 1 / (a - o), u = (n + e) * c, p = (r + s) * h, f = (a + o) * d;
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -u, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = -2 * d, l[14] = -f, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, r = e.elements;
    for (let s = 0; s < 16; s++)
      if (n[s] !== r[s]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e[n + 9] = r[9], e[n + 10] = r[10], e[n + 11] = r[11], e[n + 12] = r[12], e[n + 13] = r[13], e[n + 14] = r[14], e[n + 15] = r[15], e;
  }
}
const Xs = /* @__PURE__ */ new F(), Zn = /* @__PURE__ */ new Ye(), iL = /* @__PURE__ */ new F(0, 0, 0), rL = /* @__PURE__ */ new F(1, 1, 1), Sr = /* @__PURE__ */ new F(), Rc = /* @__PURE__ */ new F(), gn = /* @__PURE__ */ new F();
class zl {
  constructor(e = 0, n = 0, r = 0, s = zl.DefaultOrder) {
    Object.defineProperty(this, "isEuler", { value: !0 }), this._x = e, this._y = n, this._z = r, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, r, s) {
    return this._x = e, this._y = n, this._z = r, this._order = s || this._order, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n, r) {
    const s = Xe.clamp, o = e.elements, a = o[0], l = o[4], c = o[8], h = o[1], d = o[5], u = o[9], p = o[2], f = o[6], m = o[10];
    switch (n = n || this._order, n) {
      case "XYZ":
        this._y = Math.asin(s(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-u, m), this._z = Math.atan2(-l, a)) : (this._x = Math.atan2(f, d), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-s(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(c, m), this._z = Math.atan2(h, d)) : (this._y = Math.atan2(-p, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(s(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(-p, m), this._z = Math.atan2(-l, d)) : (this._y = 0, this._z = Math.atan2(h, a));
        break;
      case "ZYX":
        this._y = Math.asin(-s(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(f, m), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-l, d));
        break;
      case "YZX":
        this._z = Math.asin(s(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-u, d), this._y = Math.atan2(-p, a)) : (this._x = 0, this._y = Math.atan2(c, m));
        break;
      case "XZY":
        this._z = Math.asin(-s(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(f, d), this._y = Math.atan2(c, a)) : (this._x = Math.atan2(-u, m), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, r !== !1 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, r) {
    return Wg.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Wg, n, r);
  }
  setFromVector3(e, n) {
    return this.set(e.x, e.y, e.z, n || this._order);
  }
  reorder(e) {
    return $g.setFromEuler(this), this.setFromQuaternion($g, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  toVector3(e) {
    return e ? e.set(this._x, this._y, this._z) : new F(this._x, this._y, this._z);
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
}
zl.DefaultOrder = "XYZ";
zl.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
const Wg = /* @__PURE__ */ new Ye(), $g = /* @__PURE__ */ new Mn();
class ox {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = 1 << e | 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
}
let sL = 0;
const jg = new F(), Ys = new Mn(), qi = new Ye(), Pc = new F(), _a = new F(), oL = new F(), aL = new Mn(), qg = new F(1, 0, 0), Xg = new F(0, 1, 0), Yg = new F(0, 0, 1), lL = { type: "added" }, Zg = { type: "removed" };
function Ie() {
  Object.defineProperty(this, "id", { value: sL++ }), this.uuid = Xe.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ie.DefaultUp.clone();
  const t = new F(), e = new zl(), n = new Mn(), r = new F(1, 1, 1);
  function s() {
    n.setFromEuler(e, !1);
  }
  function o() {
    e.setFromQuaternion(n, void 0, !1);
  }
  e._onChange(s), n._onChange(o), Object.defineProperties(this, {
    position: {
      configurable: !0,
      enumerable: !0,
      value: t
    },
    rotation: {
      configurable: !0,
      enumerable: !0,
      value: e
    },
    quaternion: {
      configurable: !0,
      enumerable: !0,
      value: n
    },
    scale: {
      configurable: !0,
      enumerable: !0,
      value: r
    },
    modelViewMatrix: {
      value: new Ye()
    },
    normalMatrix: {
      value: new hn()
    }
  }), this.matrix = new Ye(), this.matrixWorld = new Ye(), this.matrixAutoUpdate = Ie.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ox(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
}
Ie.DefaultUp = new F(0, 1, 0);
Ie.DefaultMatrixAutoUpdate = !0;
Ie.prototype = Object.assign(Object.create(lr.prototype), {
  constructor: Ie,
  isObject3D: !0,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(t) {
    return this.quaternion.premultiply(t), this;
  },
  setRotationFromAxisAngle: function(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  },
  setRotationFromEuler: function(t) {
    this.quaternion.setFromEuler(t, !0);
  },
  setRotationFromMatrix: function(t) {
    this.quaternion.setFromRotationMatrix(t);
  },
  setRotationFromQuaternion: function(t) {
    this.quaternion.copy(t);
  },
  rotateOnAxis: function(t, e) {
    return Ys.setFromAxisAngle(t, e), this.quaternion.multiply(Ys), this;
  },
  rotateOnWorldAxis: function(t, e) {
    return Ys.setFromAxisAngle(t, e), this.quaternion.premultiply(Ys), this;
  },
  rotateX: function(t) {
    return this.rotateOnAxis(qg, t);
  },
  rotateY: function(t) {
    return this.rotateOnAxis(Xg, t);
  },
  rotateZ: function(t) {
    return this.rotateOnAxis(Yg, t);
  },
  translateOnAxis: function(t, e) {
    return jg.copy(t).applyQuaternion(this.quaternion), this.position.add(jg.multiplyScalar(e)), this;
  },
  translateX: function(t) {
    return this.translateOnAxis(qg, t);
  },
  translateY: function(t) {
    return this.translateOnAxis(Xg, t);
  },
  translateZ: function(t) {
    return this.translateOnAxis(Yg, t);
  },
  localToWorld: function(t) {
    return t.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(t) {
    return t.applyMatrix4(qi.copy(this.matrixWorld).invert());
  },
  lookAt: function(t, e, n) {
    t.isVector3 ? Pc.copy(t) : Pc.set(t, e, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), _a.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? qi.lookAt(_a, Pc, this.up) : qi.lookAt(Pc, _a, this.up), this.quaternion.setFromRotationMatrix(qi), r && (qi.extractRotation(r.matrixWorld), Ys.setFromRotationMatrix(qi), this.quaternion.premultiply(Ys.invert()));
  },
  add: function(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(lL)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  },
  remove: function(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Zg)), this;
  },
  clear: function() {
    for (let t = 0; t < this.children.length; t++) {
      const e = this.children[t];
      e.parent = null, e.dispatchEvent(Zg);
    }
    return this.children.length = 0, this;
  },
  attach: function(t) {
    return this.updateWorldMatrix(!0, !1), qi.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), qi.multiply(t.parent.matrixWorld)), t.applyMatrix4(qi), t.updateWorldMatrix(!1, !1), this.add(t), this;
  },
  getObjectById: function(t) {
    return this.getObjectByProperty("id", t);
  },
  getObjectByName: function(t) {
    return this.getObjectByProperty("name", t);
  },
  getObjectByProperty: function(t, e) {
    if (this[t] === e) return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const o = this.children[n].getObjectByProperty(t, e);
      if (o !== void 0)
        return o;
    }
  },
  getWorldPosition: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new F()), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new Mn()), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_a, t, oL), t;
  },
  getWorldScale: function(t) {
    return t === void 0 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new F()), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_a, aL, t), t;
  },
  getWorldDirection: function(t) {
    t === void 0 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new F()), this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(t) {
    t(this);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++)
      e[n].traverse(t);
  },
  traverseVisible: function(t) {
    if (this.visible === !1) return;
    t(this);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++)
      e[n].traverseVisible(t);
  },
  traverseAncestors: function(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++)
      e[n].updateMatrixWorld(t);
  },
  updateWorldMatrix: function(t, e) {
    const n = this.parent;
    if (t === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++)
        r[s].updateWorldMatrix(!1, !0);
    }
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string", n = {};
    e && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {}
    }, n.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON());
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(t)), l.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(t.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const d = l[c];
            s(t.shapes, d);
          }
        else
          s(t.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(t.materials, this.material[l]));
        r.material = a;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(t.animations, l));
      }
    }
    if (e) {
      const a = o(t.geometries), l = o(t.materials), c = o(t.textures), h = o(t.images), d = o(t.shapes), u = o(t.skeletons), p = o(t.animations);
      a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), u.length > 0 && (n.skeletons = u), p.length > 0 && (n.animations = p);
    }
    return n.object = r, n;
    function o(a) {
      const l = [];
      for (const c in a) {
        const h = a[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  },
  clone: function(t) {
    return new this.constructor().copy(this, t);
  },
  copy: function(t, e = !0) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
      for (let n = 0; n < t.children.length; n++) {
        const r = t.children[n];
        this.add(r.clone());
      }
    return this;
  }
});
const nd = /* @__PURE__ */ new F(), cL = /* @__PURE__ */ new F(), hL = /* @__PURE__ */ new hn();
class vi {
  constructor(e, n) {
    Object.defineProperty(this, "isPlane", { value: !0 }), this.normal = e !== void 0 ? e : new F(1, 0, 0), this.constant = n !== void 0 ? n : 0;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, r, s) {
    return this.normal.set(e, n, r), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, r) {
    const s = nd.subVectors(r, n).cross(cL.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), n = new F()), n.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, n) {
    n === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new F());
    const r = e.delta(nd), s = this.normal.dot(r);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : void 0;
    const o = -(e.start.dot(this.normal) + this.constant) / s;
    if (!(o < 0 || o > 1))
      return n.copy(r).multiplyScalar(o).add(e.start);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return n < 0 && r > 0 || r < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new F()), e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const r = n || hL.getNormalMatrix(e), s = this.coplanarPoint(nd).applyMatrix4(e), o = this.normal.applyMatrix3(r).normalize();
    return this.constant = -s.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
}
const Jn = /* @__PURE__ */ new F(), Xi = /* @__PURE__ */ new F(), id = /* @__PURE__ */ new F(), Yi = /* @__PURE__ */ new F(), Zs = /* @__PURE__ */ new F(), Js = /* @__PURE__ */ new F(), Jg = /* @__PURE__ */ new F(), rd = /* @__PURE__ */ new F(), sd = /* @__PURE__ */ new F(), od = /* @__PURE__ */ new F();
class Yt {
  constructor(e, n, r) {
    this.a = e !== void 0 ? e : new F(), this.b = n !== void 0 ? n : new F(), this.c = r !== void 0 ? r : new F();
  }
  static getNormal(e, n, r, s) {
    s === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), s = new F()), s.subVectors(r, n), Jn.subVectors(e, n), s.cross(Jn);
    const o = s.lengthSq();
    return o > 0 ? s.multiplyScalar(1 / Math.sqrt(o)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, n, r, s, o) {
    Jn.subVectors(s, n), Xi.subVectors(r, n), id.subVectors(e, n);
    const a = Jn.dot(Jn), l = Jn.dot(Xi), c = Jn.dot(id), h = Xi.dot(Xi), d = Xi.dot(id), u = a * h - l * l;
    if (o === void 0 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), o = new F()), u === 0)
      return o.set(-2, -1, -1);
    const p = 1 / u, f = (h * c - l * d) * p, m = (a * d - l * c) * p;
    return o.set(1 - f - m, m, f);
  }
  static containsPoint(e, n, r, s) {
    return this.getBarycoord(e, n, r, s, Yi), Yi.x >= 0 && Yi.y >= 0 && Yi.x + Yi.y <= 1;
  }
  static getUV(e, n, r, s, o, a, l, c) {
    return this.getBarycoord(e, n, r, s, Yi), c.set(0, 0), c.addScaledVector(o, Yi.x), c.addScaledVector(a, Yi.y), c.addScaledVector(l, Yi.z), c;
  }
  static isFrontFacing(e, n, r, s) {
    return Jn.subVectors(r, n), Xi.subVectors(e, n), Jn.cross(Xi).dot(s) < 0;
  }
  set(e, n, r) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, n, r, s) {
    return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[s]), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Jn.subVectors(this.c, this.b), Xi.subVectors(this.a, this.b), Jn.cross(Xi).length() * 0.5;
  }
  getMidpoint(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new F()), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Yt.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new vi()), e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return Yt.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getUV(e, n, r, s, o) {
    return Yt.getUV(e, this.a, this.b, this.c, n, r, s, o);
  }
  containsPoint(e) {
    return Yt.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Yt.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    n === void 0 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), n = new F());
    const r = this.a, s = this.b, o = this.c;
    let a, l;
    Zs.subVectors(s, r), Js.subVectors(o, r), rd.subVectors(e, r);
    const c = Zs.dot(rd), h = Js.dot(rd);
    if (c <= 0 && h <= 0)
      return n.copy(r);
    sd.subVectors(e, s);
    const d = Zs.dot(sd), u = Js.dot(sd);
    if (d >= 0 && u <= d)
      return n.copy(s);
    const p = c * u - d * h;
    if (p <= 0 && c >= 0 && d <= 0)
      return a = c / (c - d), n.copy(r).addScaledVector(Zs, a);
    od.subVectors(e, o);
    const f = Zs.dot(od), m = Js.dot(od);
    if (m >= 0 && f <= m)
      return n.copy(o);
    const y = f * h - c * m;
    if (y <= 0 && h >= 0 && m <= 0)
      return l = h / (h - m), n.copy(r).addScaledVector(Js, l);
    const x = d * m - f * u;
    if (x <= 0 && u - d >= 0 && f - m >= 0)
      return Jg.subVectors(o, s), l = (u - d) / (u - d + (f - m)), n.copy(s).addScaledVector(Jg, l);
    const v = 1 / (x + y + p);
    return a = y * v, l = p * v, n.copy(r).addScaledVector(Zs, a).addScaledVector(Js, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const ax = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Kn = { h: 0, s: 0, l: 0 }, Ic = { h: 0, s: 0, l: 0 };
function ad(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t;
}
function ld(t) {
  return t < 0.04045 ? t * 0.0773993808 : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function cd(t) {
  return t < 31308e-7 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
class De {
  constructor(e, n, r) {
    return Object.defineProperty(this, "isColor", { value: !0 }), n === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, n, r);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  }
  setRGB(e, n, r) {
    return this.r = e, this.g = n, this.b = r, this;
  }
  setHSL(e, n, r) {
    if (e = Xe.euclideanModulo(e, 1), n = Xe.clamp(n, 0, 1), r = Xe.clamp(r, 0, 1), n === 0)
      this.r = this.g = this.b = r;
    else {
      const s = r <= 0.5 ? r * (1 + n) : r + n - r * n, o = 2 * r - s;
      this.r = ad(o, s, e + 1 / 3), this.g = ad(o, s, e), this.b = ad(o, s, e - 1 / 3);
    }
    return this;
  }
  setStyle(e) {
    function n(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
      let s;
      const o = r[1], a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (s = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, n(s[4]), this;
          if (s = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, n(s[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
            const l = parseFloat(s[1]) / 360, c = parseInt(s[2], 10) / 100, h = parseInt(s[3], 10) / 100;
            return n(s[4]), this.setHSL(l, c, h);
          }
          break;
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = r[1], o = s.length;
      if (o === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, this;
      if (o === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, this;
    }
    return e && e.length > 0 ? this.setColorName(e) : this;
  }
  setColorName(e) {
    const n = ax[e];
    return n !== void 0 ? this.setHex(n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copyGammaToLinear(e, n = 2) {
    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this;
  }
  copyLinearToGamma(e, n = 2) {
    const r = n > 0 ? 1 / n : 1;
    return this.r = Math.pow(e.r, r), this.g = Math.pow(e.g, r), this.b = Math.pow(e.b, r), this;
  }
  convertGammaToLinear(e) {
    return this.copyGammaToLinear(this, e), this;
  }
  convertLinearToGamma(e) {
    return this.copyLinearToGamma(this, e), this;
  }
  copySRGBToLinear(e) {
    return this.r = ld(e.r), this.g = ld(e.g), this.b = ld(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = cd(e.r), this.g = cd(e.g), this.b = cd(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(e) {
    e === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 });
    const n = this.r, r = this.g, s = this.b, o = Math.max(n, r, s), a = Math.min(n, r, s);
    let l, c;
    const h = (a + o) / 2;
    if (a === o)
      l = 0, c = 0;
    else {
      const d = o - a;
      switch (c = h <= 0.5 ? d / (o + a) : d / (2 - o - a), o) {
        case n:
          l = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - n) / d + 2;
          break;
        case s:
          l = (n - r) / d + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = h, e;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(e, n, r) {
    return this.getHSL(Kn), Kn.h += e, Kn.s += n, Kn.l += r, this.setHSL(Kn.h, Kn.s, Kn.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpHSL(e, n) {
    this.getHSL(Kn), e.getHSL(Ic);
    const r = Xe.lerp(Kn.h, Ic.h, n), s = Xe.lerp(Kn.s, Ic.s, n), o = Xe.lerp(Kn.l, Ic.l, n);
    return this.setHSL(r, s, o), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
}
De.NAMES = ax;
De.prototype.r = 1;
De.prototype.g = 1;
De.prototype.b = 1;
class uf {
  constructor(e, n, r, s, o, a = 0) {
    this.a = e, this.b = n, this.c = r, this.normal = s && s.isVector3 ? s : new F(), this.vertexNormals = Array.isArray(s) ? s : [], this.color = o && o.isColor ? o : new De(), this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = a;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
    for (let n = 0, r = e.vertexNormals.length; n < r; n++)
      this.vertexNormals[n] = e.vertexNormals[n].clone();
    for (let n = 0, r = e.vertexColors.length; n < r; n++)
      this.vertexColors[n] = e.vertexColors[n].clone();
    return this;
  }
}
let uL = 0;
function ke() {
  Object.defineProperty(this, "id", { value: uL++ }), this.uuid = Xe.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = Va, this.side = Fl, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = tx, this.blendDst = nx, this.blendEquation = lo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = lf, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = eL, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Xu, this.stencilZFail = Xu, this.stencilZPass = Xu, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
}
ke.prototype = Object.assign(Object.create(lr.prototype), {
  constructor: ke,
  isMaterial: !0,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue;
        }
        if (e === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === ex;
          continue;
        }
        const r = this[e];
        if (r === void 0) {
          console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
          continue;
        }
        r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n;
      }
  },
  toJSON: function(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, this.combine !== void 0 && (n.combine = this.combine), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.size !== void 0 && (n.size = this.size), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Va && (n.blending = this.blending), this.flatShading === !0 && (n.flatShading = this.flatShading), this.side !== Fl && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (n.morphTargets = !0), this.morphNormals === !0 && (n.morphNormals = !0), this.skinning === !0 && (n.skinning = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (e) {
      const s = r(t.textures), o = r(t.images);
      s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o);
    }
    return n;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const r = e.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s)
        n[s] = e[s].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
Object.defineProperty(ke.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
function ci(t) {
  ke.call(this), this.type = "MeshBasicMaterial", this.color = new De(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ou, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t);
}
ci.prototype = Object.create(ke.prototype);
ci.prototype.constructor = ci;
ci.prototype.isMeshBasicMaterial = !0;
ci.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
};
const gt = new F(), Dc = new xe();
function qe(t, e, n) {
  if (Array.isArray(t))
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n === !0, this.usage = lu, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(qe.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
Object.assign(qe.prototype, {
  isBufferAttribute: !0,
  onUploadCallback: function() {
  },
  setUsage: function(t) {
    return this.usage = t, this;
  },
  copy: function(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
  },
  copyAt: function(t, e, n) {
    t *= this.itemSize, n *= e.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[t + r] = e.array[n + r];
    return this;
  },
  copyArray: function(t) {
    return this.array.set(t), this;
  },
  copyColorsArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      let o = t[r];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new De()), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b;
    }
    return this;
  },
  copyVector2sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      let o = t[r];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new xe()), e[n++] = o.x, e[n++] = o.y;
    }
    return this;
  },
  copyVector3sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      let o = t[r];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new F()), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z;
    }
    return this;
  },
  copyVector4sArray: function(t) {
    const e = this.array;
    let n = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      let o = t[r];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new st()), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w;
    }
    return this;
  },
  applyMatrix3: function(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        Dc.fromBufferAttribute(this, e), Dc.applyMatrix3(t), this.setXY(e, Dc.x, Dc.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        gt.fromBufferAttribute(this, e), gt.applyMatrix3(t), this.setXYZ(e, gt.x, gt.y, gt.z);
    return this;
  },
  applyMatrix4: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      gt.x = this.getX(e), gt.y = this.getY(e), gt.z = this.getZ(e), gt.applyMatrix4(t), this.setXYZ(e, gt.x, gt.y, gt.z);
    return this;
  },
  applyNormalMatrix: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      gt.x = this.getX(e), gt.y = this.getY(e), gt.z = this.getZ(e), gt.applyNormalMatrix(t), this.setXYZ(e, gt.x, gt.y, gt.z);
    return this;
  },
  transformDirection: function(t) {
    for (let e = 0, n = this.count; e < n; e++)
      gt.x = this.getX(e), gt.y = this.getY(e), gt.z = this.getZ(e), gt.transformDirection(t), this.setXYZ(e, gt.x, gt.y, gt.z);
    return this;
  },
  set: function(t, e = 0) {
    return this.array.set(t, e), this;
  },
  getX: function(t) {
    return this.array[t * this.itemSize];
  },
  setX: function(t, e) {
    return this.array[t * this.itemSize] = e, this;
  },
  getY: function(t) {
    return this.array[t * this.itemSize + 1];
  },
  setY: function(t, e) {
    return this.array[t * this.itemSize + 1] = e, this;
  },
  getZ: function(t) {
    return this.array[t * this.itemSize + 2];
  },
  setZ: function(t, e) {
    return this.array[t * this.itemSize + 2] = e, this;
  },
  getW: function(t) {
    return this.array[t * this.itemSize + 3];
  },
  setW: function(t, e) {
    return this.array[t * this.itemSize + 3] = e, this;
  },
  setXY: function(t, e, n) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this;
  },
  setXYZ: function(t, e, n, r) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this;
  },
  setXYZW: function(t, e, n, r, s) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = s, this;
  },
  onUpload: function(t) {
    return this.onUploadCallback = t, this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function df(t, e, n) {
  qe.call(this, new Int8Array(t), e, n);
}
df.prototype = Object.create(qe.prototype);
df.prototype.constructor = df;
function ff(t, e, n) {
  qe.call(this, new Uint8Array(t), e, n);
}
ff.prototype = Object.create(qe.prototype);
ff.prototype.constructor = ff;
function pf(t, e, n) {
  qe.call(this, new Uint8ClampedArray(t), e, n);
}
pf.prototype = Object.create(qe.prototype);
pf.prototype.constructor = pf;
function mf(t, e, n) {
  qe.call(this, new Int16Array(t), e, n);
}
mf.prototype = Object.create(qe.prototype);
mf.prototype.constructor = mf;
function vl(t, e, n) {
  qe.call(this, new Uint16Array(t), e, n);
}
vl.prototype = Object.create(qe.prototype);
vl.prototype.constructor = vl;
function gf(t, e, n) {
  qe.call(this, new Int32Array(t), e, n);
}
gf.prototype = Object.create(qe.prototype);
gf.prototype.constructor = gf;
function yl(t, e, n) {
  qe.call(this, new Uint32Array(t), e, n);
}
yl.prototype = Object.create(qe.prototype);
yl.prototype.constructor = yl;
function Oh(t, e, n) {
  qe.call(this, new Uint16Array(t), e, n);
}
Oh.prototype = Object.create(qe.prototype);
Oh.prototype.constructor = Oh;
Oh.prototype.isFloat16BufferAttribute = !0;
function Qe(t, e, n) {
  qe.call(this, new Float32Array(t), e, n);
}
Qe.prototype = Object.create(qe.prototype);
Qe.prototype.constructor = Qe;
function vf(t, e, n) {
  qe.call(this, new Float64Array(t), e, n);
}
vf.prototype = Object.create(qe.prototype);
vf.prototype.constructor = vf;
class dL {
  constructor() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
  }
  computeGroups(e) {
    const n = [];
    let r, s, o;
    const a = e.faces;
    for (s = 0; s < a.length; s++) {
      const l = a[s];
      l.materialIndex !== o && (o = l.materialIndex, r !== void 0 && (r.count = s * 3 - r.start, n.push(r)), r = {
        start: s * 3,
        materialIndex: o
      });
    }
    r !== void 0 && (r.count = s * 3 - r.start, n.push(r)), this.groups = n;
  }
  fromGeometry(e) {
    const n = e.faces, r = e.vertices, s = e.faceVertexUvs, o = s[0] && s[0].length > 0, a = s[1] && s[1].length > 0, l = e.morphTargets, c = l.length;
    let h;
    if (c > 0) {
      h = [];
      for (let v = 0; v < c; v++)
        h[v] = {
          name: l[v].name,
          data: []
        };
      this.morphTargets.position = h;
    }
    const d = e.morphNormals, u = d.length;
    let p;
    if (u > 0) {
      p = [];
      for (let v = 0; v < u; v++)
        p[v] = {
          name: d[v].name,
          data: []
        };
      this.morphTargets.normal = p;
    }
    const f = e.skinIndices, m = e.skinWeights, y = f.length === r.length, x = m.length === r.length;
    r.length > 0 && n.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (let v = 0; v < n.length; v++) {
      const g = n[v];
      this.vertices.push(r[g.a], r[g.b], r[g.c]);
      const S = g.vertexNormals;
      if (S.length === 3)
        this.normals.push(S[0], S[1], S[2]);
      else {
        const E = g.normal;
        this.normals.push(E, E, E);
      }
      const T = g.vertexColors;
      if (T.length === 3)
        this.colors.push(T[0], T[1], T[2]);
      else {
        const E = g.color;
        this.colors.push(E, E, E);
      }
      if (o === !0) {
        const E = s[0][v];
        E !== void 0 ? this.uvs.push(E[0], E[1], E[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", v), this.uvs.push(new xe(), new xe(), new xe()));
      }
      if (a === !0) {
        const E = s[1][v];
        E !== void 0 ? this.uvs2.push(E[0], E[1], E[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", v), this.uvs2.push(new xe(), new xe(), new xe()));
      }
      for (let E = 0; E < c; E++) {
        const w = l[E].vertices;
        h[E].data.push(w[g.a], w[g.b], w[g.c]);
      }
      for (let E = 0; E < u; E++) {
        const w = d[E].vertexNormals[v];
        p[E].data.push(w.a, w.b, w.c);
      }
      y && this.skinIndices.push(f[g.a], f[g.b], f[g.c]), x && this.skinWeights.push(m[g.a], m[g.b], m[g.c]);
    }
    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), this;
  }
}
function lx(t) {
  if (t.length === 0) return -1 / 0;
  let e = t[0];
  for (let n = 1, r = t.length; n < r; ++n)
    t[n] > e && (e = t[n]);
  return e;
}
const fL = {
  Int8Array,
  Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Nc(t, e) {
  return new fL[t](e);
}
let pL = 1;
const mi = new Ye(), hd = new Ie(), Ks = new F(), vn = new Un(), ba = new Un(), Dt = new F();
function ot() {
  Object.defineProperty(this, "id", { value: pL += 2 }), this.uuid = Xe.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
}
ot.prototype = Object.assign(Object.create(lr.prototype), {
  constructor: ot,
  isBufferGeometry: !0,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(t) {
    return Array.isArray(t) ? this.index = new (lx(t) > 65535 ? yl : vl)(t, 1) : this.index = t, this;
  },
  getAttribute: function(t) {
    return this.attributes[t];
  },
  setAttribute: function(t, e) {
    return this.attributes[t] = e, this;
  },
  deleteAttribute: function(t) {
    return delete this.attributes[t], this;
  },
  hasAttribute: function(t) {
    return this.attributes[t] !== void 0;
  },
  addGroup: function(t, e, n = 0) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: n
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  },
  applyMatrix4: function(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new hn().getNormalMatrix(t);
      n.applyNormalMatrix(s), n.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(t), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  },
  rotateX: function(t) {
    return mi.makeRotationX(t), this.applyMatrix4(mi), this;
  },
  rotateY: function(t) {
    return mi.makeRotationY(t), this.applyMatrix4(mi), this;
  },
  rotateZ: function(t) {
    return mi.makeRotationZ(t), this.applyMatrix4(mi), this;
  },
  translate: function(t, e, n) {
    return mi.makeTranslation(t, e, n), this.applyMatrix4(mi), this;
  },
  scale: function(t, e, n) {
    return mi.makeScale(t, e, n), this.applyMatrix4(mi), this;
  },
  lookAt: function(t) {
    return hd.lookAt(t), hd.updateMatrix(), this.applyMatrix4(hd.matrix), this;
  },
  center: function() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Ks).negate(), this.translate(Ks.x, Ks.y, Ks.z), this;
  },
  setFromObject: function(t) {
    const e = t.geometry;
    if (t.isPoints || t.isLine) {
      const n = new Qe(e.vertices.length * 3, 3), r = new Qe(e.colors.length * 3, 3);
      if (this.setAttribute("position", n.copyVector3sArray(e.vertices)), this.setAttribute("color", r.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
        const s = new Qe(e.lineDistances.length, 1);
        this.setAttribute("lineDistance", s.copyArray(e.lineDistances));
      }
      e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone());
    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
    return this;
  },
  setFromPoints: function(t) {
    const e = [];
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Qe(e, 3)), this;
  },
  updateFromObject: function(t) {
    let e = t.geometry;
    if (t.isMesh) {
      let n = e.__directGeometry;
      if (e.elementsNeedUpdate === !0 && (n = void 0, e.elementsNeedUpdate = !1), n === void 0)
        return this.fromGeometry(e);
      n.verticesNeedUpdate = e.verticesNeedUpdate, n.normalsNeedUpdate = e.normalsNeedUpdate, n.colorsNeedUpdate = e.colorsNeedUpdate, n.uvsNeedUpdate = e.uvsNeedUpdate, n.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = n;
    }
    if (e.verticesNeedUpdate === !0) {
      const n = this.attributes.position;
      n !== void 0 && (n.copyVector3sArray(e.vertices), n.needsUpdate = !0), e.verticesNeedUpdate = !1;
    }
    if (e.normalsNeedUpdate === !0) {
      const n = this.attributes.normal;
      n !== void 0 && (n.copyVector3sArray(e.normals), n.needsUpdate = !0), e.normalsNeedUpdate = !1;
    }
    if (e.colorsNeedUpdate === !0) {
      const n = this.attributes.color;
      n !== void 0 && (n.copyColorsArray(e.colors), n.needsUpdate = !0), e.colorsNeedUpdate = !1;
    }
    if (e.uvsNeedUpdate) {
      const n = this.attributes.uv;
      n !== void 0 && (n.copyVector2sArray(e.uvs), n.needsUpdate = !0), e.uvsNeedUpdate = !1;
    }
    if (e.lineDistancesNeedUpdate) {
      const n = this.attributes.lineDistance;
      n !== void 0 && (n.copyArray(e.lineDistances), n.needsUpdate = !0), e.lineDistancesNeedUpdate = !1;
    }
    return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
  },
  fromGeometry: function(t) {
    return t.__directGeometry = new dL().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
  },
  fromDirectGeometry: function(t) {
    const e = new Float32Array(t.vertices.length * 3);
    if (this.setAttribute("position", new qe(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
      const n = new Float32Array(t.normals.length * 3);
      this.setAttribute("normal", new qe(n, 3).copyVector3sArray(t.normals));
    }
    if (t.colors.length > 0) {
      const n = new Float32Array(t.colors.length * 3);
      this.setAttribute("color", new qe(n, 3).copyColorsArray(t.colors));
    }
    if (t.uvs.length > 0) {
      const n = new Float32Array(t.uvs.length * 2);
      this.setAttribute("uv", new qe(n, 2).copyVector2sArray(t.uvs));
    }
    if (t.uvs2.length > 0) {
      const n = new Float32Array(t.uvs2.length * 2);
      this.setAttribute("uv2", new qe(n, 2).copyVector2sArray(t.uvs2));
    }
    this.groups = t.groups;
    for (const n in t.morphTargets) {
      const r = [], s = t.morphTargets[n];
      for (let o = 0, a = s.length; o < a; o++) {
        const l = s[o], c = new Qe(l.data.length * 3, 3);
        c.name = l.name, r.push(c.copyVector3sArray(l.data));
      }
      this.morphAttributes[n] = r;
    }
    if (t.skinIndices.length > 0) {
      const n = new Qe(t.skinIndices.length * 4, 4);
      this.setAttribute("skinIndex", n.copyVector4sArray(t.skinIndices));
    }
    if (t.skinWeights.length > 0) {
      const n = new Qe(t.skinWeights.length * 4, 4);
      this.setAttribute("skinWeight", n.copyVector4sArray(t.skinWeights));
    }
    return t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new Un());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new F(-1 / 0, -1 / 0, -1 / 0),
        new F(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e)
        for (let n = 0, r = e.length; n < r; n++) {
          const s = e[n];
          vn.setFromBufferAttribute(s), this.morphTargetsRelative ? (Dt.addVectors(this.boundingBox.min, vn.min), this.boundingBox.expandByPoint(Dt), Dt.addVectors(this.boundingBox.max, vn.max), this.boundingBox.expandByPoint(Dt)) : (this.boundingBox.expandByPoint(vn.min), this.boundingBox.expandByPoint(vn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new Oi());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new F(), 1 / 0);
      return;
    }
    if (t) {
      const n = this.boundingSphere.center;
      if (vn.setFromBufferAttribute(t), e)
        for (let s = 0, o = e.length; s < o; s++) {
          const a = e[s];
          ba.setFromBufferAttribute(a), this.morphTargetsRelative ? (Dt.addVectors(vn.min, ba.min), vn.expandByPoint(Dt), Dt.addVectors(vn.max, ba.max), vn.expandByPoint(Dt)) : (vn.expandByPoint(ba.min), vn.expandByPoint(ba.max));
        }
      vn.getCenter(n);
      let r = 0;
      for (let s = 0, o = t.count; s < o; s++)
        Dt.fromBufferAttribute(t, s), r = Math.max(r, n.distanceToSquared(Dt));
      if (e)
        for (let s = 0, o = e.length; s < o; s++) {
          const a = e[s], l = this.morphTargetsRelative;
          for (let c = 0, h = a.count; c < h; c++)
            Dt.fromBufferAttribute(a, c), l && (Ks.fromBufferAttribute(t, c), Dt.add(Ks)), r = Math.max(r, n.distanceToSquared(Dt));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    const t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new qe(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let u = 0, p = n.count; u < p; u++)
          n.setXYZ(u, 0, 0, 0);
      const r = new F(), s = new F(), o = new F(), a = new F(), l = new F(), c = new F(), h = new F(), d = new F();
      if (t)
        for (let u = 0, p = t.count; u < p; u += 3) {
          const f = t.getX(u + 0), m = t.getX(u + 1), y = t.getX(u + 2);
          r.fromBufferAttribute(e, f), s.fromBufferAttribute(e, m), o.fromBufferAttribute(e, y), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), a.fromBufferAttribute(n, f), l.fromBufferAttribute(n, m), c.fromBufferAttribute(n, y), a.add(h), l.add(h), c.add(h), n.setXYZ(f, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let u = 0, p = e.count; u < p; u += 3)
          r.fromBufferAttribute(e, u + 0), s.fromBufferAttribute(e, u + 1), o.fromBufferAttribute(e, u + 2), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), n.setXYZ(u + 0, h.x, h.y, h.z), n.setXYZ(u + 1, h.x, h.y, h.z), n.setXYZ(u + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  },
  merge: function(t, e) {
    if (!(t && t.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
      return;
    }
    e === void 0 && (e = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    const n = this.attributes;
    for (const r in n) {
      if (t.attributes[r] === void 0) continue;
      const o = n[r].array, a = t.attributes[r], l = a.array, c = a.itemSize * e, h = Math.min(l.length, o.length - c);
      for (let d = 0, u = c; d < h; d++, u++)
        o[u] = l[d];
    }
    return this;
  },
  normalizeNormals: function() {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      Dt.fromBufferAttribute(t, e), Dt.normalize(), t.setXYZ(e, Dt.x, Dt.y, Dt.z);
  },
  toNonIndexed: function() {
    function t(a, l) {
      const c = a.array, h = a.itemSize, d = a.normalized, u = new c.constructor(l.length * h);
      let p = 0, f = 0;
      for (let m = 0, y = l.length; m < y; m++) {
        p = l[m] * h;
        for (let x = 0; x < h; x++)
          u[f++] = c[p++];
      }
      return new qe(u, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    const e = new ot(), n = this.index.array, r = this.attributes;
    for (const a in r) {
      const l = r[a], c = t(l, n);
      e.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [], c = s[a];
      for (let h = 0, d = c.length; h < d; h++) {
        const u = c[h], p = t(u, n);
        l.push(p);
      }
      e.morphAttributes[a] = l;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      e.addGroup(c.start, c.count, c.materialIndex);
    }
    return e;
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (t[c] = l[c]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null && (t.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l], h = c.toJSON(t.data);
      c.name !== "" && (h.name = c.name), t.data.attributes[l] = h;
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], h = [];
      for (let d = 0, u = c.length; d < u; d++) {
        const p = c[d], f = p.toJSON(t.data);
        p.name !== "" && (f.name = p.name), h.push(f);
      }
      h.length > 0 && (r[l] = h, s = !0);
    }
    s && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (t.data.boundingSphere = {
      center: a.center.toArray(),
      radius: a.radius
    }), t;
  },
  clone: function() {
    return new ot().copy(this);
  },
  copy: function(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone(e));
    const r = t.attributes;
    for (const c in r) {
      const h = r[c];
      this.setAttribute(c, h.clone(e));
    }
    const s = t.morphAttributes;
    for (const c in s) {
      const h = [], d = s[c];
      for (let u = 0, p = d.length; u < p; u++)
        h.push(d[u].clone(e));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const o = t.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = t.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = t.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
const Kg = new Ye(), cs = new ta(), ud = new Oi(), Er = new F(), Tr = new F(), Ar = new F(), dd = new F(), fd = new F(), pd = new F(), Oc = new F(), Fc = new F(), Bc = new F(), yo = new xe(), xo = new xe(), _o = new xe(), $a = new F(), zc = new F();
function at(t = new ot(), e = new ci()) {
  Ie.call(this), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
}
at.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: at,
  isMesh: !0,
  copy: function(t) {
    return Ie.prototype.copy.call(this, t), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const r = e[n[0]];
        if (r !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  raycast: function(t, e) {
    const n = this.geometry, r = this.material, s = this.matrixWorld;
    if (r === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), ud.copy(n.boundingSphere), ud.applyMatrix4(s), t.ray.intersectsSphere(ud) === !1) || (Kg.copy(s).invert(), cs.copy(t.ray).applyMatrix4(Kg), n.boundingBox !== null && cs.intersectsBox(n.boundingBox) === !1))
      return;
    let o;
    if (n.isBufferGeometry) {
      const a = n.index, l = n.attributes.position, c = n.morphAttributes.position, h = n.morphTargetsRelative, d = n.attributes.uv, u = n.attributes.uv2, p = n.groups, f = n.drawRange;
      if (a !== null)
        if (Array.isArray(r))
          for (let m = 0, y = p.length; m < y; m++) {
            const x = p[m], v = r[x.materialIndex], g = Math.max(x.start, f.start), S = Math.min(x.start + x.count, f.start + f.count);
            for (let T = g, E = S; T < E; T += 3) {
              const w = a.getX(T), C = a.getX(T + 1), ee = a.getX(T + 2);
              o = Uc(this, v, t, cs, l, c, h, d, u, w, C, ee), o && (o.faceIndex = Math.floor(T / 3), o.face.materialIndex = x.materialIndex, e.push(o));
            }
          }
        else {
          const m = Math.max(0, f.start), y = Math.min(a.count, f.start + f.count);
          for (let x = m, v = y; x < v; x += 3) {
            const g = a.getX(x), S = a.getX(x + 1), T = a.getX(x + 2);
            o = Uc(this, r, t, cs, l, c, h, d, u, g, S, T), o && (o.faceIndex = Math.floor(x / 3), e.push(o));
          }
        }
      else if (l !== void 0)
        if (Array.isArray(r))
          for (let m = 0, y = p.length; m < y; m++) {
            const x = p[m], v = r[x.materialIndex], g = Math.max(x.start, f.start), S = Math.min(x.start + x.count, f.start + f.count);
            for (let T = g, E = S; T < E; T += 3) {
              const w = T, C = T + 1, ee = T + 2;
              o = Uc(this, v, t, cs, l, c, h, d, u, w, C, ee), o && (o.faceIndex = Math.floor(T / 3), o.face.materialIndex = x.materialIndex, e.push(o));
            }
          }
        else {
          const m = Math.max(0, f.start), y = Math.min(l.count, f.start + f.count);
          for (let x = m, v = y; x < v; x += 3) {
            const g = x, S = x + 1, T = x + 2;
            o = Uc(this, r, t, cs, l, c, h, d, u, g, S, T), o && (o.faceIndex = Math.floor(x / 3), e.push(o));
          }
        }
    } else if (n.isGeometry) {
      const a = Array.isArray(r), l = n.vertices, c = n.faces;
      let h;
      const d = n.faceVertexUvs[0];
      d.length > 0 && (h = d);
      for (let u = 0, p = c.length; u < p; u++) {
        const f = c[u], m = a ? r[f.materialIndex] : r;
        if (m === void 0) continue;
        const y = l[f.a], x = l[f.b], v = l[f.c];
        if (o = cx(this, m, t, cs, y, x, v, $a), o) {
          if (h && h[u]) {
            const g = h[u];
            yo.copy(g[0]), xo.copy(g[1]), _o.copy(g[2]), o.uv = Yt.getUV($a, y, x, v, yo, xo, _o, new xe());
          }
          o.face = f, o.faceIndex = u, e.push(o);
        }
      }
    }
  }
});
function cx(t, e, n, r, s, o, a, l) {
  let c;
  if (e.side === Ct ? c = r.intersectTriangle(a, o, s, !0, l) : c = r.intersectTriangle(s, o, a, e.side !== su, l), c === null) return null;
  zc.copy(l), zc.applyMatrix4(t.matrixWorld);
  const h = n.ray.origin.distanceTo(zc);
  return h < n.near || h > n.far ? null : {
    distance: h,
    point: zc.clone(),
    object: t
  };
}
function Uc(t, e, n, r, s, o, a, l, c, h, d, u) {
  Er.fromBufferAttribute(s, h), Tr.fromBufferAttribute(s, d), Ar.fromBufferAttribute(s, u);
  const p = t.morphTargetInfluences;
  if (e.morphTargets && o && p) {
    Oc.set(0, 0, 0), Fc.set(0, 0, 0), Bc.set(0, 0, 0);
    for (let m = 0, y = o.length; m < y; m++) {
      const x = p[m], v = o[m];
      x !== 0 && (dd.fromBufferAttribute(v, h), fd.fromBufferAttribute(v, d), pd.fromBufferAttribute(v, u), a ? (Oc.addScaledVector(dd, x), Fc.addScaledVector(fd, x), Bc.addScaledVector(pd, x)) : (Oc.addScaledVector(dd.sub(Er), x), Fc.addScaledVector(fd.sub(Tr), x), Bc.addScaledVector(pd.sub(Ar), x)));
    }
    Er.add(Oc), Tr.add(Fc), Ar.add(Bc);
  }
  t.isSkinnedMesh && (t.boneTransform(h, Er), t.boneTransform(d, Tr), t.boneTransform(u, Ar));
  const f = cx(t, e, n, r, Er, Tr, Ar, $a);
  if (f) {
    l && (yo.fromBufferAttribute(l, h), xo.fromBufferAttribute(l, d), _o.fromBufferAttribute(l, u), f.uv = Yt.getUV($a, Er, Tr, Ar, yo, xo, _o, new xe())), c && (yo.fromBufferAttribute(c, h), xo.fromBufferAttribute(c, d), _o.fromBufferAttribute(c, u), f.uv2 = Yt.getUV($a, Er, Tr, Ar, yo, xo, _o, new xe()));
    const m = new uf(h, d, u);
    Yt.getNormal(Er, Tr, Ar, m.normal), f.face = m;
  }
  return f;
}
class up extends ot {
  constructor(e = 1, n = 1, r = 1, s = 1, o = 1, a = 1) {
    super(), this.type = "BoxBufferGeometry", this.parameters = {
      width: e,
      height: n,
      depth: r,
      widthSegments: s,
      heightSegments: o,
      depthSegments: a
    };
    const l = this;
    s = Math.floor(s), o = Math.floor(o), a = Math.floor(a);
    const c = [], h = [], d = [], u = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, r, n, e, a, o, 0), m("z", "y", "x", 1, -1, r, n, -e, a, o, 1), m("x", "z", "y", 1, 1, e, r, n, s, a, 2), m("x", "z", "y", 1, -1, e, r, -n, s, a, 3), m("x", "y", "z", 1, -1, e, n, r, s, o, 4), m("x", "y", "z", -1, -1, e, n, -r, s, o, 5), this.setIndex(c), this.setAttribute("position", new Qe(h, 3)), this.setAttribute("normal", new Qe(d, 3)), this.setAttribute("uv", new Qe(u, 2));
    function m(y, x, v, g, S, T, E, w, C, ee, Y) {
      const le = T / C, B = E / ee, Z = T / 2, k = E / 2, O = w / 2, P = C + 1, j = ee + 1;
      let re = 0, ae = 0;
      const ce = new F();
      for (let pe = 0; pe < j; pe++) {
        const de = pe * B - k;
        for (let ge = 0; ge < P; ge++) {
          const we = ge * le - Z;
          ce[y] = we * g, ce[x] = de * S, ce[v] = O, h.push(ce.x, ce.y, ce.z), ce[y] = 0, ce[x] = 0, ce[v] = w > 0 ? 1 : -1, d.push(ce.x, ce.y, ce.z), u.push(ge / C), u.push(1 - pe / ee), re += 1;
        }
      }
      for (let pe = 0; pe < ee; pe++)
        for (let de = 0; de < C; de++) {
          const ge = p + de + P * pe, we = p + de + P * (pe + 1), Ge = p + (de + 1) + P * (pe + 1), te = p + (de + 1) + P * pe;
          c.push(ge, we, te), c.push(we, Ge, te), ae += 6;
        }
      l.addGroup(f, ae, Y), f += ae, p += re;
    }
  }
}
function Vo(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const r in t[n]) {
      const s = t[n][r];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture) ? e[n][r] = s.clone() : Array.isArray(s) ? e[n][r] = s.slice() : e[n][r] = s;
    }
  }
  return e;
}
function jt(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const r = Vo(t[n]);
    for (const s in r)
      e[s] = r[s];
  }
  return e;
}
const dp = { clone: Vo, merge: jt };
var mL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, gL = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
function Kt(t) {
  ke.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = mL, this.fragmentShader = gL, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
    derivatives: !1,
    // set to use derivatives
    fragDepth: !1,
    // set to use fragment depth values
    drawBuffers: !1,
    // set to use draw buffers
    shaderTextureLOD: !1
    // set to use shader texture LOD
  }, this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && (t.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
}
Kt.prototype = Object.create(ke.prototype);
Kt.prototype.constructor = Kt;
Kt.prototype.isShaderMaterial = !0;
Kt.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Vo(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
};
Kt.prototype.toJSON = function(t) {
  const e = ke.prototype.toJSON.call(this, t);
  e.glslVersion = this.glslVersion, e.uniforms = {};
  for (const r in this.uniforms) {
    const o = this.uniforms[r].value;
    o && o.isTexture ? e.uniforms[r] = {
      type: "t",
      value: o.toJSON(t).uuid
    } : o && o.isColor ? e.uniforms[r] = {
      type: "c",
      value: o.getHex()
    } : o && o.isVector2 ? e.uniforms[r] = {
      type: "v2",
      value: o.toArray()
    } : o && o.isVector3 ? e.uniforms[r] = {
      type: "v3",
      value: o.toArray()
    } : o && o.isVector4 ? e.uniforms[r] = {
      type: "v4",
      value: o.toArray()
    } : o && o.isMatrix3 ? e.uniforms[r] = {
      type: "m3",
      value: o.toArray()
    } : o && o.isMatrix4 ? e.uniforms[r] = {
      type: "m4",
      value: o.toArray()
    } : e.uniforms[r] = {
      value: o
    };
  }
  Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
  const n = {};
  for (const r in this.extensions)
    this.extensions[r] === !0 && (n[r] = !0);
  return Object.keys(n).length > 0 && (e.extensions = n), e;
};
function er() {
  Ie.call(this), this.type = "Camera", this.matrixWorldInverse = new Ye(), this.projectionMatrix = new Ye(), this.projectionMatrixInverse = new Ye();
}
er.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: er,
  isCamera: !0,
  copy: function(t, e) {
    return Ie.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
  },
  getWorldDirection: function(t) {
    t === void 0 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new F()), this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function(t) {
    Ie.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function(t, e) {
    Ie.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function Pt(t = 50, e = 1, n = 0.1, r = 2e3) {
  er.call(this), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
}
Pt.prototype = Object.assign(Object.create(er.prototype), {
  constructor: Pt,
  isPerspectiveCamera: !0,
  copy: function(t, e) {
    return er.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  },
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function(t) {
    const e = 0.5 * this.getFilmHeight() / t;
    this.fov = Xe.RAD2DEG * 2 * Math.atan(e), this.updateProjectionMatrix();
  },
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function() {
    const t = Math.tan(Xe.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  },
  getEffectiveFOV: function() {
    return Xe.RAD2DEG * 2 * Math.atan(
      Math.tan(Xe.DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function(t, e, n, r, s, o) {
    this.aspect = t / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const t = this.near;
    let e = t * Math.tan(Xe.DEG2RAD * 0.5 * this.fov) / this.zoom, n = 2 * e, r = this.aspect * n, s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, c = o.fullHeight;
      s += o.offsetX * r / l, e -= o.offsetY * n / c, r *= o.width / l, n *= o.height / c;
    }
    const a = this.filmOffset;
    a !== 0 && (s += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(t) {
    const e = Ie.prototype.toJSON.call(this, t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
});
const Qs = 90, eo = 1;
function ko(t, e, n) {
  if (Ie.call(this), this.type = "CubeCamera", n.isWebGLCubeRenderTarget !== !0) {
    console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    return;
  }
  this.renderTarget = n;
  const r = new Pt(Qs, eo, t, e);
  r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new F(1, 0, 0)), this.add(r);
  const s = new Pt(Qs, eo, t, e);
  s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new F(-1, 0, 0)), this.add(s);
  const o = new Pt(Qs, eo, t, e);
  o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new F(0, 1, 0)), this.add(o);
  const a = new Pt(Qs, eo, t, e);
  a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new F(0, -1, 0)), this.add(a);
  const l = new Pt(Qs, eo, t, e);
  l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new F(0, 0, 1)), this.add(l);
  const c = new Pt(Qs, eo, t, e);
  c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new F(0, 0, -1)), this.add(c), this.update = function(h, d) {
    this.parent === null && this.updateMatrixWorld();
    const u = h.xr.enabled, p = h.getRenderTarget();
    h.xr.enabled = !1;
    const f = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, h.setRenderTarget(n, 0), h.render(d, r), h.setRenderTarget(n, 1), h.render(d, s), h.setRenderTarget(n, 2), h.render(d, o), h.setRenderTarget(n, 3), h.render(d, a), h.setRenderTarget(n, 4), h.render(d, l), n.texture.generateMipmaps = f, h.setRenderTarget(n, 5), h.render(d, c), h.setRenderTarget(p), h.xr.enabled = u;
  };
}
ko.prototype = Object.create(Ie.prototype);
ko.prototype.constructor = ko;
function Xr(t, e, n, r, s, o, a, l, c, h) {
  t = t !== void 0 ? t : [], e = e !== void 0 ? e : sp, a = a !== void 0 ? a : Br, ut.call(this, t, e, n, r, s, o, a, l, c, h), this.flipY = !1, this._needsFlipEnvMap = !0;
}
Xr.prototype = Object.create(ut.prototype);
Xr.prototype.constructor = Xr;
Xr.prototype.isCubeTexture = !0;
Object.defineProperty(Xr.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(t) {
    this.image = t;
  }
});
function bs(t, e, n) {
  Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), ai.call(this, t, t, e), e = e || {}, this.texture = new Xr(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture._needsFlipEnvMap = !1;
}
bs.prototype = Object.create(ai.prototype);
bs.prototype.constructor = bs;
bs.prototype.isWebGLCubeRenderTarget = !0;
bs.prototype.fromEquirectangularTexture = function(t, e) {
  this.texture.type = e.type, this.texture.format = Nn, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
  const n = {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: (
      /* glsl */
      `

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`
    ),
    fragmentShader: (
      /* glsl */
      `

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
    )
  }, r = new up(5, 5, 5), s = new Kt({
    name: "CubemapFromEquirect",
    uniforms: Vo(n.uniforms),
    vertexShader: n.vertexShader,
    fragmentShader: n.fragmentShader,
    side: Ct,
    blending: Ga
  });
  s.uniforms.tEquirect.value = e;
  const o = new at(r, s), a = e.minFilter;
  return e.minFilter === au && (e.minFilter = At), new ko(1, 10, this).update(t, o), e.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
};
bs.prototype.clear = function(t, e, n, r) {
  const s = t.getRenderTarget();
  for (let o = 0; o < 6; o++)
    t.setRenderTarget(this, o), t.clear(e, n, r);
  t.setRenderTarget(s);
};
function Yr(t, e, n, r, s, o, a, l, c, h, d, u) {
  ut.call(this, null, o, a, l, c, h, r, s, d, u), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = c !== void 0 ? c : Xt, this.minFilter = h !== void 0 ? h : Xt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
}
Yr.prototype = Object.create(ut.prototype);
Yr.prototype.constructor = Yr;
Yr.prototype.isDataTexture = !0;
const to = /* @__PURE__ */ new Oi(), Hc = /* @__PURE__ */ new F();
class cu {
  constructor(e, n, r, s, o, a) {
    this.planes = [
      e !== void 0 ? e : new vi(),
      n !== void 0 ? n : new vi(),
      r !== void 0 ? r : new vi(),
      s !== void 0 ? s : new vi(),
      o !== void 0 ? o : new vi(),
      a !== void 0 ? a : new vi()
    ];
  }
  set(e, n, r, s, o, a) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(n), l[2].copy(r), l[3].copy(s), l[4].copy(o), l[5].copy(a), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++)
      n[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const n = this.planes, r = e.elements, s = r[0], o = r[1], a = r[2], l = r[3], c = r[4], h = r[5], d = r[6], u = r[7], p = r[8], f = r[9], m = r[10], y = r[11], x = r[12], v = r[13], g = r[14], S = r[15];
    return n[0].setComponents(l - s, u - c, y - p, S - x).normalize(), n[1].setComponents(l + s, u + c, y + p, S + x).normalize(), n[2].setComponents(l + o, u + h, y + f, S + v).normalize(), n[3].setComponents(l - o, u - h, y - f, S - v).normalize(), n[4].setComponents(l - a, u - d, y - m, S - g).normalize(), n[5].setComponents(l + a, u + d, y + m, S + g).normalize(), this;
  }
  intersectsObject(e) {
    const n = e.geometry;
    return n.boundingSphere === null && n.computeBoundingSphere(), to.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(to);
  }
  intersectsSprite(e) {
    return to.center.set(0, 0, 0), to.radius = 0.7071067811865476, to.applyMatrix4(e.matrixWorld), this.intersectsSphere(to);
  }
  intersectsSphere(e) {
    const n = this.planes, r = e.center, s = -e.radius;
    for (let o = 0; o < 6; o++)
      if (n[o].distanceToPoint(r) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) {
      const s = n[r];
      if (Hc.x = s.normal.x > 0 ? e.max.x : e.min.x, Hc.y = s.normal.y > 0 ? e.max.y : e.min.y, Hc.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(Hc) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++)
      if (n[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
}
function hx() {
  let t = null, e = !1, n = null, r = null;
  function s(o, a) {
    n(o, a), r = t.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (r = t.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      t.cancelAnimationFrame(r), e = !1;
    },
    setAnimationLoop: function(o) {
      n = o;
    },
    setContext: function(o) {
      t = o;
    }
  };
}
function vL(t, e) {
  const n = e.isWebGL2, r = /* @__PURE__ */ new WeakMap();
  function s(h, d) {
    const u = h.array, p = h.usage, f = t.createBuffer();
    t.bindBuffer(d, f), t.bufferData(d, u, p), h.onUploadCallback();
    let m = 5126;
    return u instanceof Float32Array ? m = 5126 : u instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : u instanceof Uint16Array ? h.isFloat16BufferAttribute ? n ? m = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : m = 5123 : u instanceof Int16Array ? m = 5122 : u instanceof Uint32Array ? m = 5125 : u instanceof Int32Array ? m = 5124 : u instanceof Int8Array ? m = 5120 : u instanceof Uint8Array && (m = 5121), {
      buffer: f,
      type: m,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: h.version
    };
  }
  function o(h, d, u) {
    const p = d.array, f = d.updateRange;
    t.bindBuffer(u, h), f.count === -1 ? t.bufferSubData(u, 0, p) : (n ? t.bufferSubData(
      u,
      f.offset * p.BYTES_PER_ELEMENT,
      p,
      f.offset,
      f.count
    ) : t.bufferSubData(
      u,
      f.offset * p.BYTES_PER_ELEMENT,
      p.subarray(f.offset, f.offset + f.count)
    ), f.count = -1);
  }
  function a(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), r.get(h);
  }
  function l(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    const d = r.get(h);
    d && (t.deleteBuffer(d.buffer), r.delete(h));
  }
  function c(h, d) {
    if (h.isGLBufferAttribute) {
      const p = r.get(h);
      (!p || p.version < h.version) && r.set(h, {
        buffer: h.buffer,
        type: h.type,
        bytesPerElement: h.elementSize,
        version: h.version
      });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    const u = r.get(h);
    u === void 0 ? r.set(h, s(h, d)) : u.version < h.version && (o(u.buffer, h, d), u.version = h.version);
  }
  return {
    get: a,
    remove: l,
    update: c
  };
}
class ux extends ot {
  constructor(e = 1, n = 1, r = 1, s = 1) {
    super(), this.type = "PlaneBufferGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: r,
      heightSegments: s
    };
    const o = e / 2, a = n / 2, l = Math.floor(r), c = Math.floor(s), h = l + 1, d = c + 1, u = e / l, p = n / c, f = [], m = [], y = [], x = [];
    for (let v = 0; v < d; v++) {
      const g = v * p - a;
      for (let S = 0; S < h; S++) {
        const T = S * u - o;
        m.push(T, -g, 0), y.push(0, 0, 1), x.push(S / l), x.push(1 - v / c);
      }
    }
    for (let v = 0; v < c; v++)
      for (let g = 0; g < l; g++) {
        const S = g + h * v, T = g + h * (v + 1), E = g + 1 + h * (v + 1), w = g + 1 + h * v;
        f.push(S, T, w), f.push(T, E, w);
      }
    this.setIndex(f), this.setAttribute("position", new Qe(m, 3)), this.setAttribute("normal", new Qe(y, 3)), this.setAttribute("uv", new Qe(x, 2));
  }
}
var yL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, xL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, _L = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`, bL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`, wL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, ML = "vec3 transformed = vec3( position );", SL = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, EL = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`, TL = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, AL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, LL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, CL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, RL = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, PL = `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`, IL = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`, DL = `#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, NL = `#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, OL = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, FL = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, BL = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, zL = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, UL = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, HL = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, GL = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, VL = "gl_FragColor = linearToOutputTexel( gl_FragColor );", kL = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`, WL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, $L = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, jL = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, qL = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, XL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, YL = `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`, ZL = `#ifdef USE_FOG
	varying float fogDepth;
#endif`, JL = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, KL = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, QL = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, e2 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`, t2 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, n2 = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`, i2 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`, r2 = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`, s2 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, o2 = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, a2 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, l2 = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, c2 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`, h2 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, u2 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, d2 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`, f2 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, p2 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, m2 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, g2 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, v2 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, y2 = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`, x2 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, _2 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, b2 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, w2 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, M2 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, S2 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`, E2 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`, T2 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`, A2 = `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, L2 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`, C2 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`, R2 = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, P2 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`, I2 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, D2 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, N2 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, O2 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, F2 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, B2 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, z2 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, U2 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, H2 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, G2 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, V2 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, k2 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, W2 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, $2 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`, j2 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, q2 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, X2 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Y2 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Z2 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, J2 = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, K2 = `#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`, Q2 = `#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`, eC = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, tC = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, nC = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, iC = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, rC = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, sC = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, oC = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, aC = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, lC = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, cC = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, hC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, uC = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, dC = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, fC = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, pC = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, mC = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, gC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, vC = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, yC = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, xC = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _C = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, bC = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wC = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, MC = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, SC = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, EC = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, TC = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, AC = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, LC = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, CC = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, RC = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, PC = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`, IC = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, DC = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, NC = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, OC = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, FC = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, BC = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, zC = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
const nt = {
  alphamap_fragment: yL,
  alphamap_pars_fragment: xL,
  alphatest_fragment: _L,
  aomap_fragment: bL,
  aomap_pars_fragment: wL,
  begin_vertex: ML,
  beginnormal_vertex: SL,
  bsdfs: EL,
  bumpmap_pars_fragment: TL,
  clipping_planes_fragment: AL,
  clipping_planes_pars_fragment: LL,
  clipping_planes_pars_vertex: CL,
  clipping_planes_vertex: RL,
  color_fragment: PL,
  color_pars_fragment: IL,
  color_pars_vertex: DL,
  color_vertex: NL,
  common: OL,
  cube_uv_reflection_fragment: FL,
  defaultnormal_vertex: BL,
  displacementmap_pars_vertex: zL,
  displacementmap_vertex: UL,
  emissivemap_fragment: HL,
  emissivemap_pars_fragment: GL,
  encodings_fragment: VL,
  encodings_pars_fragment: kL,
  envmap_fragment: WL,
  envmap_common_pars_fragment: $L,
  envmap_pars_fragment: jL,
  envmap_pars_vertex: qL,
  envmap_physical_pars_fragment: r2,
  envmap_vertex: XL,
  fog_vertex: YL,
  fog_pars_vertex: ZL,
  fog_fragment: JL,
  fog_pars_fragment: KL,
  gradientmap_pars_fragment: QL,
  lightmap_fragment: e2,
  lightmap_pars_fragment: t2,
  lights_lambert_vertex: n2,
  lights_pars_begin: i2,
  lights_toon_fragment: s2,
  lights_toon_pars_fragment: o2,
  lights_phong_fragment: a2,
  lights_phong_pars_fragment: l2,
  lights_physical_fragment: c2,
  lights_physical_pars_fragment: h2,
  lights_fragment_begin: u2,
  lights_fragment_maps: d2,
  lights_fragment_end: f2,
  logdepthbuf_fragment: p2,
  logdepthbuf_pars_fragment: m2,
  logdepthbuf_pars_vertex: g2,
  logdepthbuf_vertex: v2,
  map_fragment: y2,
  map_pars_fragment: x2,
  map_particle_fragment: _2,
  map_particle_pars_fragment: b2,
  metalnessmap_fragment: w2,
  metalnessmap_pars_fragment: M2,
  morphnormal_vertex: S2,
  morphtarget_pars_vertex: E2,
  morphtarget_vertex: T2,
  normal_fragment_begin: A2,
  normal_fragment_maps: L2,
  normalmap_pars_fragment: C2,
  clearcoat_normal_fragment_begin: R2,
  clearcoat_normal_fragment_maps: P2,
  clearcoat_pars_fragment: I2,
  packing: D2,
  premultiplied_alpha_fragment: N2,
  project_vertex: O2,
  dithering_fragment: F2,
  dithering_pars_fragment: B2,
  roughnessmap_fragment: z2,
  roughnessmap_pars_fragment: U2,
  shadowmap_pars_fragment: H2,
  shadowmap_pars_vertex: G2,
  shadowmap_vertex: V2,
  shadowmask_pars_fragment: k2,
  skinbase_vertex: W2,
  skinning_pars_vertex: $2,
  skinning_vertex: j2,
  skinnormal_vertex: q2,
  specularmap_fragment: X2,
  specularmap_pars_fragment: Y2,
  tonemapping_fragment: Z2,
  tonemapping_pars_fragment: J2,
  transmissionmap_fragment: K2,
  transmissionmap_pars_fragment: Q2,
  uv_pars_fragment: eC,
  uv_pars_vertex: tC,
  uv_vertex: nC,
  uv2_pars_fragment: iC,
  uv2_pars_vertex: rC,
  uv2_vertex: sC,
  worldpos_vertex: oC,
  background_frag: aC,
  background_vert: lC,
  cube_frag: cC,
  cube_vert: hC,
  depth_frag: uC,
  depth_vert: dC,
  distanceRGBA_frag: fC,
  distanceRGBA_vert: pC,
  equirect_frag: mC,
  equirect_vert: gC,
  linedashed_frag: vC,
  linedashed_vert: yC,
  meshbasic_frag: xC,
  meshbasic_vert: _C,
  meshlambert_frag: bC,
  meshlambert_vert: wC,
  meshmatcap_frag: MC,
  meshmatcap_vert: SC,
  meshtoon_frag: EC,
  meshtoon_vert: TC,
  meshphong_frag: AC,
  meshphong_vert: LC,
  meshphysical_frag: CC,
  meshphysical_vert: RC,
  normal_frag: PC,
  normal_vert: IC,
  points_frag: DC,
  points_vert: NC,
  shadow_frag: OC,
  shadow_vert: FC,
  sprite_frag: BC,
  sprite_vert: zC
}, Te = {
  common: {
    diffuse: { value: new De(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new hn() },
    uv2Transform: { value: new hn() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new xe(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new De(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new De(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new hn() }
  },
  sprite: {
    diffuse: { value: new De(15658734) },
    opacity: { value: 1 },
    center: { value: new xe(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new hn() }
  }
}, on = {
  basic: {
    uniforms: jt([
      Te.common,
      Te.specularmap,
      Te.envmap,
      Te.aomap,
      Te.lightmap,
      Te.fog
    ]),
    vertexShader: nt.meshbasic_vert,
    fragmentShader: nt.meshbasic_frag
  },
  lambert: {
    uniforms: jt([
      Te.common,
      Te.specularmap,
      Te.envmap,
      Te.aomap,
      Te.lightmap,
      Te.emissivemap,
      Te.fog,
      Te.lights,
      {
        emissive: { value: new De(0) }
      }
    ]),
    vertexShader: nt.meshlambert_vert,
    fragmentShader: nt.meshlambert_frag
  },
  phong: {
    uniforms: jt([
      Te.common,
      Te.specularmap,
      Te.envmap,
      Te.aomap,
      Te.lightmap,
      Te.emissivemap,
      Te.bumpmap,
      Te.normalmap,
      Te.displacementmap,
      Te.fog,
      Te.lights,
      {
        emissive: { value: new De(0) },
        specular: { value: new De(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: nt.meshphong_vert,
    fragmentShader: nt.meshphong_frag
  },
  standard: {
    uniforms: jt([
      Te.common,
      Te.envmap,
      Te.aomap,
      Te.lightmap,
      Te.emissivemap,
      Te.bumpmap,
      Te.normalmap,
      Te.displacementmap,
      Te.roughnessmap,
      Te.metalnessmap,
      Te.fog,
      Te.lights,
      {
        emissive: { value: new De(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: nt.meshphysical_vert,
    fragmentShader: nt.meshphysical_frag
  },
  toon: {
    uniforms: jt([
      Te.common,
      Te.aomap,
      Te.lightmap,
      Te.emissivemap,
      Te.bumpmap,
      Te.normalmap,
      Te.displacementmap,
      Te.gradientmap,
      Te.fog,
      Te.lights,
      {
        emissive: { value: new De(0) }
      }
    ]),
    vertexShader: nt.meshtoon_vert,
    fragmentShader: nt.meshtoon_frag
  },
  matcap: {
    uniforms: jt([
      Te.common,
      Te.bumpmap,
      Te.normalmap,
      Te.displacementmap,
      Te.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: nt.meshmatcap_vert,
    fragmentShader: nt.meshmatcap_frag
  },
  points: {
    uniforms: jt([
      Te.points,
      Te.fog
    ]),
    vertexShader: nt.points_vert,
    fragmentShader: nt.points_frag
  },
  dashed: {
    uniforms: jt([
      Te.common,
      Te.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: nt.linedashed_vert,
    fragmentShader: nt.linedashed_frag
  },
  depth: {
    uniforms: jt([
      Te.common,
      Te.displacementmap
    ]),
    vertexShader: nt.depth_vert,
    fragmentShader: nt.depth_frag
  },
  normal: {
    uniforms: jt([
      Te.common,
      Te.bumpmap,
      Te.normalmap,
      Te.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: nt.normal_vert,
    fragmentShader: nt.normal_frag
  },
  sprite: {
    uniforms: jt([
      Te.sprite,
      Te.fog
    ]),
    vertexShader: nt.sprite_vert,
    fragmentShader: nt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new hn() },
      t2D: { value: null }
    },
    vertexShader: nt.background_vert,
    fragmentShader: nt.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: jt([
      Te.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: nt.cube_vert,
    fragmentShader: nt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: nt.equirect_vert,
    fragmentShader: nt.equirect_frag
  },
  distanceRGBA: {
    uniforms: jt([
      Te.common,
      Te.displacementmap,
      {
        referencePosition: { value: new F() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: nt.distanceRGBA_vert,
    fragmentShader: nt.distanceRGBA_frag
  },
  shadow: {
    uniforms: jt([
      Te.lights,
      Te.fog,
      {
        color: { value: new De(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: nt.shadow_vert,
    fragmentShader: nt.shadow_frag
  }
};
on.physical = {
  uniforms: jt([
    on.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new xe(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new De(0) },
      transmission: { value: 0 },
      transmissionMap: { value: null }
    }
  ]),
  vertexShader: nt.meshphysical_vert,
  fragmentShader: nt.meshphysical_frag
};
function UC(t, e, n, r, s) {
  const o = new De(0);
  let a = 0, l, c, h = null, d = 0, u = null;
  function p(m, y, x, v) {
    let g = y.isScene === !0 ? y.background : null;
    g && g.isTexture && (g = e.get(g));
    const S = t.xr, T = S.getSession && S.getSession();
    T && T.environmentBlendMode === "additive" && (g = null), g === null ? f(o, a) : g && g.isColor && (f(g, 1), v = !0), (t.autoClear || v) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.isWebGLCubeRenderTarget || g.mapping === ap) ? (c === void 0 && (c = new at(
      new up(1, 1, 1),
      new Kt({
        name: "BackgroundCubeMaterial",
        uniforms: Vo(on.cube.uniforms),
        vertexShader: on.cube.vertexShader,
        fragmentShader: on.cube.fragmentShader,
        side: Ct,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(E, w, C) {
      this.matrixWorld.copyPosition(C.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(c)), g.isWebGLCubeRenderTarget && (g = g.texture), c.material.uniforms.envMap.value = g, c.material.uniforms.flipEnvMap.value = g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1, (h !== g || d !== g.version || u !== t.toneMapping) && (c.material.needsUpdate = !0, h = g, d = g.version, u = t.toneMapping), m.unshift(c, c.geometry, c.material, 0, 0, null)) : g && g.isTexture && (l === void 0 && (l = new at(
      new ux(2, 2),
      new Kt({
        name: "BackgroundMaterial",
        uniforms: Vo(on.background.uniforms),
        vertexShader: on.background.vertexShader,
        fragmentShader: on.background.fragmentShader,
        side: Fl,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(l)), l.material.uniforms.t2D.value = g, g.matrixAutoUpdate === !0 && g.updateMatrix(), l.material.uniforms.uvTransform.value.copy(g.matrix), (h !== g || d !== g.version || u !== t.toneMapping) && (l.material.needsUpdate = !0, h = g, d = g.version, u = t.toneMapping), m.unshift(l, l.geometry, l.material, 0, 0, null));
  }
  function f(m, y) {
    n.buffers.color.setClear(m.r, m.g, m.b, y, s);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(m, y = 1) {
      o.set(m), a = y, f(o, a);
    },
    getClearAlpha: function() {
      return a;
    },
    setClearAlpha: function(m) {
      a = m, f(o, a);
    },
    render: p
  };
}
function HC(t, e, n, r) {
  const s = t.getParameter(34921), o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), a = r.isWebGL2 || o !== null, l = {}, c = y(null);
  let h = c;
  function d(k, O, P, j, re) {
    let ae = !1;
    if (a) {
      const ce = m(j, P, O);
      h !== ce && (h = ce, p(h.object)), ae = x(j, re), ae && v(j, re);
    } else {
      const ce = O.wireframe === !0;
      (h.geometry !== j.id || h.program !== P.id || h.wireframe !== ce) && (h.geometry = j.id, h.program = P.id, h.wireframe = ce, ae = !0);
    }
    k.isInstancedMesh === !0 && (ae = !0), re !== null && n.update(re, 34963), ae && (C(k, O, P, j), re !== null && t.bindBuffer(34963, n.get(re).buffer));
  }
  function u() {
    return r.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES();
  }
  function p(k) {
    return r.isWebGL2 ? t.bindVertexArray(k) : o.bindVertexArrayOES(k);
  }
  function f(k) {
    return r.isWebGL2 ? t.deleteVertexArray(k) : o.deleteVertexArrayOES(k);
  }
  function m(k, O, P) {
    const j = P.wireframe === !0;
    let re = l[k.id];
    re === void 0 && (re = {}, l[k.id] = re);
    let ae = re[O.id];
    ae === void 0 && (ae = {}, re[O.id] = ae);
    let ce = ae[j];
    return ce === void 0 && (ce = y(u()), ae[j] = ce), ce;
  }
  function y(k) {
    const O = [], P = [], j = [];
    for (let re = 0; re < s; re++)
      O[re] = 0, P[re] = 0, j[re] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: O,
      enabledAttributes: P,
      attributeDivisors: j,
      object: k,
      attributes: {},
      index: null
    };
  }
  function x(k, O) {
    const P = h.attributes, j = k.attributes;
    let re = 0;
    for (const ae in j) {
      const ce = P[ae], pe = j[ae];
      if (ce === void 0 || ce.attribute !== pe || ce.data !== pe.data) return !0;
      re++;
    }
    return h.attributesNum !== re || h.index !== O;
  }
  function v(k, O) {
    const P = {}, j = k.attributes;
    let re = 0;
    for (const ae in j) {
      const ce = j[ae], pe = {};
      pe.attribute = ce, ce.data && (pe.data = ce.data), P[ae] = pe, re++;
    }
    h.attributes = P, h.attributesNum = re, h.index = O;
  }
  function g() {
    const k = h.newAttributes;
    for (let O = 0, P = k.length; O < P; O++)
      k[O] = 0;
  }
  function S(k) {
    T(k, 0);
  }
  function T(k, O) {
    const P = h.newAttributes, j = h.enabledAttributes, re = h.attributeDivisors;
    P[k] = 1, j[k] === 0 && (t.enableVertexAttribArray(k), j[k] = 1), re[k] !== O && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](k, O), re[k] = O);
  }
  function E() {
    const k = h.newAttributes, O = h.enabledAttributes;
    for (let P = 0, j = O.length; P < j; P++)
      O[P] !== k[P] && (t.disableVertexAttribArray(P), O[P] = 0);
  }
  function w(k, O, P, j, re, ae) {
    r.isWebGL2 === !0 && (P === 5124 || P === 5125) ? t.vertexAttribIPointer(k, O, P, re, ae) : t.vertexAttribPointer(k, O, P, j, re, ae);
  }
  function C(k, O, P, j) {
    if (r.isWebGL2 === !1 && (k.isInstancedMesh || j.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    g();
    const re = j.attributes, ae = P.getAttributes(), ce = O.defaultAttributeValues;
    for (const pe in ae) {
      const de = ae[pe];
      if (de >= 0) {
        const ge = re[pe];
        if (ge !== void 0) {
          const we = ge.normalized, Ge = ge.itemSize, te = n.get(ge);
          if (te === void 0) continue;
          const I = te.buffer, L = te.type, U = te.bytesPerElement;
          if (ge.isInterleavedBufferAttribute) {
            const N = ge.data, V = N.stride, W = ge.offset;
            N && N.isInstancedInterleavedBuffer ? (T(de, N.meshPerAttribute), j._maxInstanceCount === void 0 && (j._maxInstanceCount = N.meshPerAttribute * N.count)) : S(de), t.bindBuffer(34962, I), w(de, Ge, L, we, V * U, W * U);
          } else
            ge.isInstancedBufferAttribute ? (T(de, ge.meshPerAttribute), j._maxInstanceCount === void 0 && (j._maxInstanceCount = ge.meshPerAttribute * ge.count)) : S(de), t.bindBuffer(34962, I), w(de, Ge, L, we, 0, 0);
        } else if (pe === "instanceMatrix") {
          const we = n.get(k.instanceMatrix);
          if (we === void 0) continue;
          const Ge = we.buffer, te = we.type;
          T(de + 0, 1), T(de + 1, 1), T(de + 2, 1), T(de + 3, 1), t.bindBuffer(34962, Ge), t.vertexAttribPointer(de + 0, 4, te, !1, 64, 0), t.vertexAttribPointer(de + 1, 4, te, !1, 64, 16), t.vertexAttribPointer(de + 2, 4, te, !1, 64, 32), t.vertexAttribPointer(de + 3, 4, te, !1, 64, 48);
        } else if (pe === "instanceColor") {
          const we = n.get(k.instanceColor);
          if (we === void 0) continue;
          const Ge = we.buffer, te = we.type;
          T(de, 1), t.bindBuffer(34962, Ge), t.vertexAttribPointer(de, 3, te, !1, 12, 0);
        } else if (ce !== void 0) {
          const we = ce[pe];
          if (we !== void 0)
            switch (we.length) {
              case 2:
                t.vertexAttrib2fv(de, we);
                break;
              case 3:
                t.vertexAttrib3fv(de, we);
                break;
              case 4:
                t.vertexAttrib4fv(de, we);
                break;
              default:
                t.vertexAttrib1fv(de, we);
            }
        }
      }
    }
    E();
  }
  function ee() {
    B();
    for (const k in l) {
      const O = l[k];
      for (const P in O) {
        const j = O[P];
        for (const re in j)
          f(j[re].object), delete j[re];
        delete O[P];
      }
      delete l[k];
    }
  }
  function Y(k) {
    if (l[k.id] === void 0) return;
    const O = l[k.id];
    for (const P in O) {
      const j = O[P];
      for (const re in j)
        f(j[re].object), delete j[re];
      delete O[P];
    }
    delete l[k.id];
  }
  function le(k) {
    for (const O in l) {
      const P = l[O];
      if (P[k.id] === void 0) continue;
      const j = P[k.id];
      for (const re in j)
        f(j[re].object), delete j[re];
      delete P[k.id];
    }
  }
  function B() {
    Z(), h !== c && (h = c, p(h.object));
  }
  function Z() {
    c.geometry = null, c.program = null, c.wireframe = !1;
  }
  return {
    setup: d,
    reset: B,
    resetDefaultState: Z,
    dispose: ee,
    releaseStatesOfGeometry: Y,
    releaseStatesOfProgram: le,
    initAttributes: g,
    enableAttribute: S,
    disableUnusedAttributes: E
  };
}
function GC(t, e, n, r) {
  const s = r.isWebGL2;
  let o;
  function a(h) {
    o = h;
  }
  function l(h, d) {
    t.drawArrays(o, h, d), n.update(d, o, 1);
  }
  function c(h, d, u) {
    if (u === 0) return;
    let p, f;
    if (s)
      p = t, f = "drawArraysInstanced";
    else if (p = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", p === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    p[f](o, h, d, u), n.update(d, o, u);
  }
  this.setMode = a, this.render = l, this.renderInstances = c;
}
function VC(t, e, n) {
  let r;
  function s() {
    if (r !== void 0) return r;
    const w = e.get("EXT_texture_filter_anisotropic");
    return w !== null ? r = t.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : r = 0, r;
  }
  function o(w) {
    if (w === "highp") {
      if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      w = "mediump";
    }
    return w === "mediump" && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const a = typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && t instanceof WebGL2ComputeRenderingContext;
  let l = n.precision !== void 0 ? n.precision : "highp";
  const c = o(l);
  c !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", c, "instead."), l = c);
  const h = n.logarithmicDepthBuffer === !0, d = t.getParameter(34930), u = t.getParameter(35660), p = t.getParameter(3379), f = t.getParameter(34076), m = t.getParameter(34921), y = t.getParameter(36347), x = t.getParameter(36348), v = t.getParameter(36349), g = u > 0, S = a || !!e.get("OES_texture_float"), T = g && S, E = a ? t.getParameter(36183) : 0;
  return {
    isWebGL2: a,
    getMaxAnisotropy: s,
    getMaxPrecision: o,
    precision: l,
    logarithmicDepthBuffer: h,
    maxTextures: d,
    maxVertexTextures: u,
    maxTextureSize: p,
    maxCubemapSize: f,
    maxAttributes: m,
    maxVertexUniforms: y,
    maxVaryings: x,
    maxFragmentUniforms: v,
    vertexTextures: g,
    floatFragmentTextures: S,
    floatVertexTextures: T,
    maxSamples: E
  };
}
function kC(t) {
  const e = this;
  let n = null, r = 0, s = !1, o = !1;
  const a = new vi(), l = new hn(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, p, f) {
    const m = u.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    r !== 0 || s;
    return s = p, n = d(u, f, 0), r = u.length, m;
  }, this.beginShadows = function() {
    o = !0, d(null);
  }, this.endShadows = function() {
    o = !1, h();
  }, this.setState = function(u, p, f) {
    const m = u.clippingPlanes, y = u.clipIntersection, x = u.clipShadows, v = t.get(u);
    if (!s || m === null || m.length === 0 || o && !x)
      o ? d(null) : h();
    else {
      const g = o ? 0 : r, S = g * 4;
      let T = v.clippingState || null;
      c.value = T, T = d(m, p, S, f);
      for (let E = 0; E !== S; ++E)
        T[E] = n[E];
      v.clippingState = T, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += g;
    }
  };
  function h() {
    c.value !== n && (c.value = n, c.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function d(u, p, f, m) {
    const y = u !== null ? u.length : 0;
    let x = null;
    if (y !== 0) {
      if (x = c.value, m !== !0 || x === null) {
        const v = f + y * 4, g = p.matrixWorldInverse;
        l.getNormalMatrix(g), (x === null || x.length < v) && (x = new Float32Array(v));
        for (let S = 0, T = f; S !== y; ++S, T += 4)
          a.copy(u[S]).applyMatrix4(g, l), a.normal.toArray(x, T), x[T + 3] = a.constant;
      }
      c.value = x, c.needsUpdate = !0;
    }
    return e.numPlanes = y, e.numIntersection = 0, x;
  }
}
function WC(t) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(a, l) {
    return l === Ag ? a.mapping = sp : l === Lg && (a.mapping = op), a;
  }
  function r(a) {
    if (a && a.isTexture) {
      const l = a.mapping;
      if (l === Ag || l === Lg)
        if (e.has(a)) {
          const c = e.get(a).texture;
          return n(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const h = t.getRenderList(), d = t.getRenderTarget(), u = new bs(c.height / 2);
            return u.fromEquirectangularTexture(t, a), e.set(a, u), t.setRenderTarget(d), t.setRenderList(h), a.addEventListener("dispose", s), n(u.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: o
  };
}
function $C(t) {
  const e = {};
  return {
    has: function(n) {
      if (e[n] !== void 0)
        return e[n] !== null;
      let r;
      switch (n) {
        case "WEBGL_depth_texture":
          r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          r = t.getExtension(n);
      }
      return e[n] = r, r !== null;
    },
    get: function(n) {
      return this.has(n) || console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n];
    }
  };
}
function jC(t, e, n, r) {
  const s = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const p = u.target, f = s.get(p);
    f.index !== null && e.remove(f.index);
    for (const y in f.attributes)
      e.remove(f.attributes[y]);
    p.removeEventListener("dispose", a), s.delete(p);
    const m = o.get(f);
    m && (e.remove(m), o.delete(f)), r.releaseStatesOfGeometry(f), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, n.memory.geometries--;
  }
  function l(u, p) {
    let f = s.get(p);
    return f || (p.addEventListener("dispose", a), p.isBufferGeometry ? f = p : p.isGeometry && (p._bufferGeometry === void 0 && (p._bufferGeometry = new ot().setFromObject(u)), f = p._bufferGeometry), s.set(p, f), n.memory.geometries++, f);
  }
  function c(u) {
    const p = u.attributes;
    for (const m in p)
      e.update(p[m], 34962);
    const f = u.morphAttributes;
    for (const m in f) {
      const y = f[m];
      for (let x = 0, v = y.length; x < v; x++)
        e.update(y[x], 34962);
    }
  }
  function h(u) {
    const p = [], f = u.index, m = u.attributes.position;
    let y = 0;
    if (f !== null) {
      const g = f.array;
      y = f.version;
      for (let S = 0, T = g.length; S < T; S += 3) {
        const E = g[S + 0], w = g[S + 1], C = g[S + 2];
        p.push(E, w, w, C, C, E);
      }
    } else {
      const g = m.array;
      y = m.version;
      for (let S = 0, T = g.length / 3 - 1; S < T; S += 3) {
        const E = S + 0, w = S + 1, C = S + 2;
        p.push(E, w, w, C, C, E);
      }
    }
    const x = new (lx(p) > 65535 ? yl : vl)(p, 1);
    x.version = y;
    const v = o.get(u);
    v && e.remove(v), o.set(u, x);
  }
  function d(u) {
    const p = o.get(u);
    if (p) {
      const f = u.index;
      f !== null && p.version < f.version && h(u);
    } else
      h(u);
    return o.get(u);
  }
  return {
    get: l,
    update: c,
    getWireframeAttribute: d
  };
}
function qC(t, e, n, r) {
  const s = r.isWebGL2;
  let o;
  function a(p) {
    o = p;
  }
  let l, c;
  function h(p) {
    l = p.type, c = p.bytesPerElement;
  }
  function d(p, f) {
    t.drawElements(o, f, l, p * c), n.update(f, o, 1);
  }
  function u(p, f, m) {
    if (m === 0) return;
    let y, x;
    if (s)
      y = t, x = "drawElementsInstanced";
    else if (y = e.get("ANGLE_instanced_arrays"), x = "drawElementsInstancedANGLE", y === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    y[x](o, f, l, p * c, m), n.update(f, o, m);
  }
  this.setMode = a, this.setIndex = h, this.render = d, this.renderInstances = u;
}
function XC(t) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function r(o, a, l) {
    switch (n.calls++, a) {
      case 4:
        n.triangles += l * (o / 3);
        break;
      case 1:
        n.lines += l * (o / 2);
        break;
      case 3:
        n.lines += l * (o - 1);
        break;
      case 2:
        n.lines += l * o;
        break;
      case 0:
        n.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function s() {
    n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: s,
    update: r
  };
}
function YC(t, e) {
  return t[0] - e[0];
}
function ZC(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function JC(t) {
  const e = {}, n = new Float32Array(8), r = [];
  for (let o = 0; o < 8; o++)
    r[o] = [o, 0];
  function s(o, a, l, c) {
    const h = o.morphTargetInfluences, d = h === void 0 ? 0 : h.length;
    let u = e[a.id];
    if (u === void 0) {
      u = [];
      for (let x = 0; x < d; x++)
        u[x] = [x, 0];
      e[a.id] = u;
    }
    for (let x = 0; x < d; x++) {
      const v = u[x];
      v[0] = x, v[1] = h[x];
    }
    u.sort(ZC);
    for (let x = 0; x < 8; x++)
      x < d && u[x][1] ? (r[x][0] = u[x][0], r[x][1] = u[x][1]) : (r[x][0] = Number.MAX_SAFE_INTEGER, r[x][1] = 0);
    r.sort(YC);
    const p = l.morphTargets && a.morphAttributes.position, f = l.morphNormals && a.morphAttributes.normal;
    let m = 0;
    for (let x = 0; x < 8; x++) {
      const v = r[x], g = v[0], S = v[1];
      g !== Number.MAX_SAFE_INTEGER && S ? (p && a.getAttribute("morphTarget" + x) !== p[g] && a.setAttribute("morphTarget" + x, p[g]), f && a.getAttribute("morphNormal" + x) !== f[g] && a.setAttribute("morphNormal" + x, f[g]), n[x] = S, m += S) : (p && a.hasAttribute("morphTarget" + x) === !0 && a.deleteAttribute("morphTarget" + x), f && a.hasAttribute("morphNormal" + x) === !0 && a.deleteAttribute("morphNormal" + x), n[x] = 0);
    }
    const y = a.morphTargetsRelative ? 1 : 1 - m;
    c.getUniforms().setValue(t, "morphTargetBaseInfluence", y), c.getUniforms().setValue(t, "morphTargetInfluences", n);
  }
  return {
    update: s
  };
}
function KC(t, e, n, r) {
  let s = /* @__PURE__ */ new WeakMap();
  function o(c) {
    const h = r.render.frame, d = c.geometry, u = e.get(c, d);
    return s.get(u) !== h && (d.isGeometry && u.updateFromObject(c), e.update(u), s.set(u, h)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), n.update(c.instanceMatrix, 34962), c.instanceColor !== null && n.update(c.instanceColor, 34962)), u;
  }
  function a() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function l(c) {
    const h = c.target;
    h.removeEventListener("dispose", l), n.remove(h.instanceMatrix), h.instanceColor !== null && n.remove(h.instanceColor);
  }
  return {
    update: o,
    dispose: a
  };
}
function xl(t = null, e = 1, n = 1, r = 1) {
  ut.call(this, null), this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = Xt, this.minFilter = Xt, this.wrapR = yn, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}
xl.prototype = Object.create(ut.prototype);
xl.prototype.constructor = xl;
xl.prototype.isDataTexture2DArray = !0;
function _l(t = null, e = 1, n = 1, r = 1) {
  ut.call(this, null), this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = Xt, this.minFilter = Xt, this.wrapR = yn, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}
_l.prototype = Object.create(ut.prototype);
_l.prototype.constructor = _l;
_l.prototype.isDataTexture3D = !0;
const dx = new ut(), QC = new xl(), e3 = new _l(), fx = new Xr(), Qg = [], ev = [], tv = new Float32Array(16), nv = new Float32Array(9), iv = new Float32Array(4);
function na(t, e, n) {
  const r = t[0];
  if (r <= 0 || r > 0) return t;
  const s = e * n;
  let o = Qg[s];
  if (o === void 0 && (o = new Float32Array(s), Qg[s] = o), e !== 0) {
    r.toArray(o, 0);
    for (let a = 1, l = 0; a !== e; ++a)
      l += n, t[a].toArray(o, l);
  }
  return o;
}
function Hn(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, r = t.length; n < r; n++)
    if (t[n] !== e[n]) return !1;
  return !0;
}
function An(t, e) {
  for (let n = 0, r = e.length; n < r; n++)
    t[n] = e[n];
}
function px(t, e) {
  let n = ev[e];
  n === void 0 && (n = new Int32Array(e), ev[e] = n);
  for (let r = 0; r !== e; ++r)
    n[r] = t.allocateTextureUnit();
  return n;
}
function t3(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e);
}
function n3(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Hn(n, e)) return;
    t.uniform2fv(this.addr, e), An(n, e);
  }
}
function i3(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (Hn(n, e)) return;
    t.uniform3fv(this.addr, e), An(n, e);
  }
}
function r3(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Hn(n, e)) return;
    t.uniform4fv(this.addr, e), An(n, e);
  }
}
function s3(t, e) {
  const n = this.cache, r = e.elements;
  if (r === void 0) {
    if (Hn(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), An(n, e);
  } else {
    if (Hn(n, r)) return;
    iv.set(r), t.uniformMatrix2fv(this.addr, !1, iv), An(n, r);
  }
}
function o3(t, e) {
  const n = this.cache, r = e.elements;
  if (r === void 0) {
    if (Hn(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), An(n, e);
  } else {
    if (Hn(n, r)) return;
    nv.set(r), t.uniformMatrix3fv(this.addr, !1, nv), An(n, r);
  }
}
function a3(t, e) {
  const n = this.cache, r = e.elements;
  if (r === void 0) {
    if (Hn(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), An(n, e);
  } else {
    if (Hn(n, r)) return;
    tv.set(r), t.uniformMatrix4fv(this.addr, !1, tv), An(n, r);
  }
}
function l3(t, e, n) {
  const r = this.cache, s = n.allocateTextureUnit();
  r[0] !== s && (t.uniform1i(this.addr, s), r[0] = s), n.safeSetTexture2D(e || dx, s);
}
function c3(t, e, n) {
  const r = this.cache, s = n.allocateTextureUnit();
  r[0] !== s && (t.uniform1i(this.addr, s), r[0] = s), n.setTexture2DArray(e || QC, s);
}
function h3(t, e, n) {
  const r = this.cache, s = n.allocateTextureUnit();
  r[0] !== s && (t.uniform1i(this.addr, s), r[0] = s), n.setTexture3D(e || e3, s);
}
function u3(t, e, n) {
  const r = this.cache, s = n.allocateTextureUnit();
  r[0] !== s && (t.uniform1i(this.addr, s), r[0] = s), n.safeSetTextureCube(e || fx, s);
}
function d3(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e);
}
function f3(t, e) {
  const n = this.cache;
  Hn(n, e) || (t.uniform2iv(this.addr, e), An(n, e));
}
function p3(t, e) {
  const n = this.cache;
  Hn(n, e) || (t.uniform3iv(this.addr, e), An(n, e));
}
function m3(t, e) {
  const n = this.cache;
  Hn(n, e) || (t.uniform4iv(this.addr, e), An(n, e));
}
function g3(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e);
}
function v3(t) {
  switch (t) {
    case 5126:
      return t3;
    // FLOAT
    case 35664:
      return n3;
    // _VEC2
    case 35665:
      return i3;
    // _VEC3
    case 35666:
      return r3;
    // _VEC4
    case 35674:
      return s3;
    // _MAT2
    case 35675:
      return o3;
    // _MAT3
    case 35676:
      return a3;
    // _MAT4
    case 5124:
    case 35670:
      return d3;
    // INT, BOOL
    case 35667:
    case 35671:
      return f3;
    // _VEC2
    case 35668:
    case 35672:
      return p3;
    // _VEC3
    case 35669:
    case 35673:
      return m3;
    // _VEC4
    case 5125:
      return g3;
    // UINT
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return l3;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return h3;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return u3;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return c3;
  }
}
function y3(t, e) {
  t.uniform1fv(this.addr, e);
}
function x3(t, e) {
  t.uniform1iv(this.addr, e);
}
function _3(t, e) {
  t.uniform2iv(this.addr, e);
}
function b3(t, e) {
  t.uniform3iv(this.addr, e);
}
function w3(t, e) {
  t.uniform4iv(this.addr, e);
}
function M3(t, e) {
  const n = na(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function S3(t, e) {
  const n = na(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function E3(t, e) {
  const n = na(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function T3(t, e) {
  const n = na(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function A3(t, e) {
  const n = na(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function L3(t, e) {
  const n = na(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function C3(t, e, n) {
  const r = e.length, s = px(n, r);
  t.uniform1iv(this.addr, s);
  for (let o = 0; o !== r; ++o)
    n.safeSetTexture2D(e[o] || dx, s[o]);
}
function R3(t, e, n) {
  const r = e.length, s = px(n, r);
  t.uniform1iv(this.addr, s);
  for (let o = 0; o !== r; ++o)
    n.safeSetTextureCube(e[o] || fx, s[o]);
}
function P3(t) {
  switch (t) {
    case 5126:
      return y3;
    // FLOAT
    case 35664:
      return M3;
    // _VEC2
    case 35665:
      return S3;
    // _VEC3
    case 35666:
      return E3;
    // _VEC4
    case 35674:
      return T3;
    // _MAT2
    case 35675:
      return A3;
    // _MAT3
    case 35676:
      return L3;
    // _MAT4
    case 5124:
    case 35670:
      return x3;
    // INT, BOOL
    case 35667:
    case 35671:
      return _3;
    // _VEC2
    case 35668:
    case 35672:
      return b3;
    // _VEC3
    case 35669:
    case 35673:
      return w3;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return C3;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return R3;
  }
}
function I3(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.setValue = v3(e.type);
}
function mx(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = P3(e.type);
}
mx.prototype.updateCache = function(t) {
  const e = this.cache;
  t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), An(e, t);
};
function gx(t) {
  this.id = t, this.seq = [], this.map = {};
}
gx.prototype.setValue = function(t, e, n) {
  const r = this.seq;
  for (let s = 0, o = r.length; s !== o; ++s) {
    const a = r[s];
    a.setValue(t, e[a.id], n);
  }
};
const md = /(\w+)(\])?(\[|\.)?/g;
function rv(t, e) {
  t.seq.push(e), t.map[e.id] = e;
}
function D3(t, e, n) {
  const r = t.name, s = r.length;
  for (md.lastIndex = 0; ; ) {
    const o = md.exec(r), a = md.lastIndex;
    let l = o[1];
    const c = o[2] === "]", h = o[3];
    if (c && (l = l | 0), h === void 0 || h === "[" && a + 2 === s) {
      rv(n, h === void 0 ? new I3(l, t, e) : new mx(l, t, e));
      break;
    } else {
      let u = n.map[l];
      u === void 0 && (u = new gx(l), rv(n, u)), n = u;
    }
  }
}
function zr(t, e) {
  this.seq = [], this.map = {};
  const n = t.getProgramParameter(e, 35718);
  for (let r = 0; r < n; ++r) {
    const s = t.getActiveUniform(e, r), o = t.getUniformLocation(e, s.name);
    D3(s, o, this);
  }
}
zr.prototype.setValue = function(t, e, n, r) {
  const s = this.map[e];
  s !== void 0 && s.setValue(t, n, r);
};
zr.prototype.setOptional = function(t, e, n) {
  const r = e[n];
  r !== void 0 && this.setValue(t, n, r);
};
zr.upload = function(t, e, n, r) {
  for (let s = 0, o = e.length; s !== o; ++s) {
    const a = e[s], l = n[a.id];
    l.needsUpdate !== !1 && a.setValue(t, l.value, r);
  }
};
zr.seqWithValue = function(t, e) {
  const n = [];
  for (let r = 0, s = t.length; r !== s; ++r) {
    const o = t[r];
    o.id in e && n.push(o);
  }
  return n;
};
function sv(t, e, n) {
  const r = t.createShader(e);
  return t.shaderSource(r, n), t.compileShader(r), r;
}
let N3 = 0;
function O3(t) {
  const e = t.split(`
`);
  for (let n = 0; n < e.length; n++)
    e[n] = n + 1 + ": " + e[n];
  return e.join(`
`);
}
function vx(t) {
  switch (t) {
    case Bl:
      return ["Linear", "( value )"];
    case sx:
      return ["sRGB", "( value )"];
    case jA:
      return ["RGBE", "( value )"];
    case XA:
      return ["RGBM", "( value, 7.0 )"];
    case YA:
      return ["RGBM", "( value, 16.0 )"];
    case ZA:
      return ["RGBD", "( value, 256.0 )"];
    case $A:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case qA:
      return ["LogLuv", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];
  }
}
function ov(t, e, n) {
  const r = t.getShaderParameter(e, 35713), s = t.getShaderInfoLog(e).trim();
  if (r && s === "") return "";
  const o = t.getShaderSource(e);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + `
` + s + O3(o);
}
function wa(t, e) {
  const n = vx(e);
  return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
}
function F3(t, e) {
  const n = vx(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}
function B3(t, e) {
  let n;
  switch (e) {
    case WT:
      n = "Linear";
      break;
    case $T:
      n = "Reinhard";
      break;
    case jT:
      n = "OptimizedCineon";
      break;
    case qT:
      n = "ACESFilmic";
      break;
    case XT:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
function z3(t) {
  return [
    t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || t.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(Pa).join(`
`);
}
function U3(t) {
  const e = [];
  for (const n in t) {
    const r = t[n];
    r !== !1 && e.push("#define " + n + " " + r);
  }
  return e.join(`
`);
}
function H3(t, e) {
  const n = {}, r = t.getProgramParameter(e, 35721);
  for (let s = 0; s < r; s++) {
    const a = t.getActiveAttrib(e, s).name;
    n[a] = t.getAttribLocation(e, a);
  }
  return n;
}
function Pa(t) {
  return t !== "";
}
function av(t, e) {
  return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function lv(t, e) {
  return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const G3 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function yf(t) {
  return t.replace(G3, V3);
}
function V3(t, e) {
  const n = nt[e];
  if (n === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return yf(n);
}
const k3 = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, W3 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function cv(t) {
  return t.replace(W3, yx).replace(k3, $3);
}
function $3(t, e, n, r) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), yx(t, e, n, r);
}
function yx(t, e, n, r) {
  let s = "";
  for (let o = parseInt(e); o < parseInt(n); o++)
    s += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return s;
}
function hv(t) {
  let e = "precision " + t.precision + ` float;
precision ` + t.precision + " int;";
  return t.precision === "highp" ? e += `
#define HIGH_PRECISION` : t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : t.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function j3(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return t.shadowMapType === Qy ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === wT ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === Ra && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function q3(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case sp:
      case op:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ap:
      case lp:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function X3(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case op:
      case lp:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Y3(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case ou:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case VT:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case kT:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Z3(t, e, n, r) {
  const s = t.getContext(), o = n.defines;
  let a = n.vertexShader, l = n.fragmentShader;
  const c = j3(n), h = q3(n), d = X3(n), u = Y3(n), p = t.gammaFactor > 0 ? t.gammaFactor : 1, f = n.isWebGL2 ? "" : z3(n), m = U3(o), y = s.createProgram();
  let x, v, g = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (x = [
    m
  ].filter(Pa).join(`
`), x.length > 0 && (x += `
`), v = [
    f,
    m
  ].filter(Pa).join(`
`), v.length > 0 && (v += `
`)) : (x = [
    hv(n),
    "#define SHADER_NAME " + n.shaderName,
    m,
    n.instancing ? "#define USE_INSTANCING" : "",
    n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    "#define GAMMA_FACTOR " + p,
    "#define MAX_BONES " + n.maxBones,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + d : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.vertexTangents ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexUvs ? "#define USE_UV" : "",
    n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.useVertexTexture ? "#define BONE_TEXTURE" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#ifdef USE_COLOR",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_MORPHTARGETS",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Pa).join(`
`), v = [
    f,
    hv(n),
    "#define SHADER_NAME " + n.shaderName,
    m,
    n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "",
    // add '.0' if integer
    "#define GAMMA_FACTOR " + p,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + h : "",
    n.envMap ? "#define " + d : "",
    n.envMap ? "#define " + u : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.vertexTangents ? "#define USE_TANGENT" : "",
    n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
    n.vertexUvs ? "#define USE_UV" : "",
    n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== ka ? "#define TONE_MAPPING" : "",
    n.toneMapping !== ka ? nt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== ka ? B3("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    nt.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    n.map ? wa("mapTexelToLinear", n.mapEncoding) : "",
    n.matcap ? wa("matcapTexelToLinear", n.matcapEncoding) : "",
    n.envMap ? wa("envMapTexelToLinear", n.envMapEncoding) : "",
    n.emissiveMap ? wa("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "",
    n.lightMap ? wa("lightMapTexelToLinear", n.lightMapEncoding) : "",
    F3("linearToOutputTexel", n.outputEncoding),
    n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(Pa).join(`
`)), a = yf(a), a = av(a, n), a = lv(a, n), l = yf(l), l = av(l, n), l = lv(l, n), a = cv(a), l = cv(l), n.isWebGL2 && n.isRawShaderMaterial !== !0 && (g = `#version 300 es
`, x = [
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + x, v = [
    "#define varying in",
    n.glslVersion === Gg ? "" : "out highp vec4 pc_fragColor;",
    n.glslVersion === Gg ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + v);
  const S = g + x + a, T = g + v + l, E = sv(s, 35633, S), w = sv(s, 35632, T);
  if (s.attachShader(y, E), s.attachShader(y, w), n.index0AttributeName !== void 0 ? s.bindAttribLocation(y, 0, n.index0AttributeName) : n.morphTargets === !0 && s.bindAttribLocation(y, 0, "position"), s.linkProgram(y), t.debug.checkShaderErrors) {
    const Y = s.getProgramInfoLog(y).trim(), le = s.getShaderInfoLog(E).trim(), B = s.getShaderInfoLog(w).trim();
    let Z = !0, k = !0;
    if (s.getProgramParameter(y, 35714) === !1) {
      Z = !1;
      const O = ov(s, E, "vertex"), P = ov(s, w, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(y, 35715), "gl.getProgramInfoLog", Y, O, P);
    } else Y !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", Y) : (le === "" || B === "") && (k = !1);
    k && (this.diagnostics = {
      runnable: Z,
      programLog: Y,
      vertexShader: {
        log: le,
        prefix: x
      },
      fragmentShader: {
        log: B,
        prefix: v
      }
    });
  }
  s.deleteShader(E), s.deleteShader(w);
  let C;
  this.getUniforms = function() {
    return C === void 0 && (C = new zr(s, y)), C;
  };
  let ee;
  return this.getAttributes = function() {
    return ee === void 0 && (ee = H3(s, y)), ee;
  }, this.destroy = function() {
    r.releaseStatesOfProgram(this), s.deleteProgram(y), this.program = void 0;
  }, this.name = n.shaderName, this.id = N3++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = E, this.fragmentShader = w, this;
}
function J3(t, e, n, r, s, o) {
  const a = [], l = r.isWebGL2, c = r.logarithmicDepthBuffer, h = r.floatVertexTextures, d = r.maxVertexUniforms, u = r.vertexTextures;
  let p = r.precision;
  const f = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  }, m = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function y(w) {
    const ee = w.skeleton.bones;
    if (h)
      return 1024;
    {
      const le = Math.floor((d - 20) / 4), B = Math.min(le, ee.length);
      return B < ee.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + ee.length + " bones. This GPU supports " + B + "."), 0) : B;
    }
  }
  function x(w) {
    let C;
    return w && w.isTexture ? C = w.encoding : w && w.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), C = w.texture.encoding) : C = Bl, C;
  }
  function v(w, C, ee, Y, le) {
    const B = Y.fog, Z = w.isMeshStandardMaterial ? Y.environment : null, k = e.get(w.envMap || Z), O = f[w.type], P = le.isSkinnedMesh ? y(le) : 0;
    w.precision !== null && (p = r.getMaxPrecision(w.precision), p !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", p, "instead."));
    let j, re;
    if (O) {
      const pe = on[O];
      j = pe.vertexShader, re = pe.fragmentShader;
    } else
      j = w.vertexShader, re = w.fragmentShader;
    const ae = t.getRenderTarget();
    return {
      isWebGL2: l,
      shaderID: O,
      shaderName: w.type,
      vertexShader: j,
      fragmentShader: re,
      defines: w.defines,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: p,
      instancing: le.isInstancedMesh === !0,
      instancingColor: le.isInstancedMesh === !0 && le.instanceColor !== null,
      supportsVertexTextures: u,
      outputEncoding: ae !== null ? x(ae.texture) : t.outputEncoding,
      map: !!w.map,
      mapEncoding: x(w.map),
      matcap: !!w.matcap,
      matcapEncoding: x(w.matcap),
      envMap: !!k,
      envMapMode: k && k.mapping,
      envMapEncoding: x(k),
      envMapCubeUV: !!k && (k.mapping === ap || k.mapping === lp),
      lightMap: !!w.lightMap,
      lightMapEncoding: x(w.lightMap),
      aoMap: !!w.aoMap,
      emissiveMap: !!w.emissiveMap,
      emissiveMapEncoding: x(w.emissiveMap),
      bumpMap: !!w.bumpMap,
      normalMap: !!w.normalMap,
      objectSpaceNormalMap: w.normalMapType === QA,
      tangentSpaceNormalMap: w.normalMapType === Qo,
      clearcoatMap: !!w.clearcoatMap,
      clearcoatRoughnessMap: !!w.clearcoatRoughnessMap,
      clearcoatNormalMap: !!w.clearcoatNormalMap,
      displacementMap: !!w.displacementMap,
      roughnessMap: !!w.roughnessMap,
      metalnessMap: !!w.metalnessMap,
      specularMap: !!w.specularMap,
      alphaMap: !!w.alphaMap,
      gradientMap: !!w.gradientMap,
      sheen: !!w.sheen,
      transmissionMap: !!w.transmissionMap,
      combine: w.combine,
      vertexTangents: w.normalMap && w.vertexTangents,
      vertexColors: w.vertexColors,
      vertexUvs: !!w.map || !!w.bumpMap || !!w.normalMap || !!w.specularMap || !!w.alphaMap || !!w.emissiveMap || !!w.roughnessMap || !!w.metalnessMap || !!w.clearcoatMap || !!w.clearcoatRoughnessMap || !!w.clearcoatNormalMap || !!w.displacementMap || !!w.transmissionMap,
      uvsVertexOnly: !(w.map || w.bumpMap || w.normalMap || w.specularMap || w.alphaMap || w.emissiveMap || w.roughnessMap || w.metalnessMap || w.clearcoatNormalMap || w.transmissionMap) && !!w.displacementMap,
      fog: !!B,
      useFog: w.fog,
      fogExp2: B && B.isFogExp2,
      flatShading: w.flatShading,
      sizeAttenuation: w.sizeAttenuation,
      logarithmicDepthBuffer: c,
      skinning: w.skinning && P > 0,
      maxBones: P,
      useVertexTexture: h,
      morphTargets: w.morphTargets,
      morphNormals: w.morphNormals,
      maxMorphTargets: t.maxMorphTargets,
      maxMorphNormals: t.maxMorphNormals,
      numDirLights: C.directional.length,
      numPointLights: C.point.length,
      numSpotLights: C.spot.length,
      numRectAreaLights: C.rectArea.length,
      numHemiLights: C.hemi.length,
      numDirLightShadows: C.directionalShadowMap.length,
      numPointLightShadows: C.pointShadowMap.length,
      numSpotLightShadows: C.spotShadowMap.length,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: t.shadowMap.enabled && ee.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: w.toneMapped ? t.toneMapping : ka,
      physicallyCorrectLights: t.physicallyCorrectLights,
      premultipliedAlpha: w.premultipliedAlpha,
      alphaTest: w.alphaTest,
      doubleSided: w.side === su,
      flipSided: w.side === Ct,
      depthPacking: w.depthPacking !== void 0 ? w.depthPacking : !1,
      index0AttributeName: w.index0AttributeName,
      extensionDerivatives: w.extensions && w.extensions.derivatives,
      extensionFragDepth: w.extensions && w.extensions.fragDepth,
      extensionDrawBuffers: w.extensions && w.extensions.drawBuffers,
      extensionShaderTextureLOD: w.extensions && w.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: l || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: w.customProgramCacheKey()
    };
  }
  function g(w) {
    const C = [];
    if (w.shaderID ? C.push(w.shaderID) : (C.push(w.fragmentShader), C.push(w.vertexShader)), w.defines !== void 0)
      for (const ee in w.defines)
        C.push(ee), C.push(w.defines[ee]);
    if (w.isRawShaderMaterial === !1) {
      for (let ee = 0; ee < m.length; ee++)
        C.push(w[m[ee]]);
      C.push(t.outputEncoding), C.push(t.gammaFactor);
    }
    return C.push(w.customProgramCacheKey), C.join();
  }
  function S(w) {
    const C = f[w.type];
    let ee;
    if (C) {
      const Y = on[C];
      ee = dp.clone(Y.uniforms);
    } else
      ee = w.uniforms;
    return ee;
  }
  function T(w, C) {
    let ee;
    for (let Y = 0, le = a.length; Y < le; Y++) {
      const B = a[Y];
      if (B.cacheKey === C) {
        ee = B, ++ee.usedTimes;
        break;
      }
    }
    return ee === void 0 && (ee = new Z3(t, C, w, s), a.push(ee)), ee;
  }
  function E(w) {
    if (--w.usedTimes === 0) {
      const C = a.indexOf(w);
      a[C] = a[a.length - 1], a.pop(), w.destroy();
    }
  }
  return {
    getParameters: v,
    getProgramCacheKey: g,
    getUniforms: S,
    acquireProgram: T,
    releaseProgram: E,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: a
  };
}
function K3() {
  let t = /* @__PURE__ */ new WeakMap();
  function e(o) {
    let a = t.get(o);
    return a === void 0 && (a = {}, t.set(o, a)), a;
  }
  function n(o) {
    t.delete(o);
  }
  function r(o, a, l) {
    t.get(o)[a] = l;
  }
  function s() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: n,
    update: r,
    dispose: s
  };
}
function Q3(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
}
function eR(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
}
function uv(t) {
  const e = [];
  let n = 0;
  const r = [], s = [], o = { id: -1 };
  function a() {
    n = 0, r.length = 0, s.length = 0;
  }
  function l(p, f, m, y, x, v) {
    let g = e[n];
    const S = t.get(m);
    return g === void 0 ? (g = {
      id: p.id,
      object: p,
      geometry: f,
      material: m,
      program: S.program || o,
      groupOrder: y,
      renderOrder: p.renderOrder,
      z: x,
      group: v
    }, e[n] = g) : (g.id = p.id, g.object = p, g.geometry = f, g.material = m, g.program = S.program || o, g.groupOrder = y, g.renderOrder = p.renderOrder, g.z = x, g.group = v), n++, g;
  }
  function c(p, f, m, y, x, v) {
    const g = l(p, f, m, y, x, v);
    (m.transparent === !0 ? s : r).push(g);
  }
  function h(p, f, m, y, x, v) {
    const g = l(p, f, m, y, x, v);
    (m.transparent === !0 ? s : r).unshift(g);
  }
  function d(p, f) {
    r.length > 1 && r.sort(p || Q3), s.length > 1 && s.sort(f || eR);
  }
  function u() {
    for (let p = n, f = e.length; p < f; p++) {
      const m = e[p];
      if (m.id === null) break;
      m.id = null, m.object = null, m.geometry = null, m.material = null, m.program = null, m.group = null;
    }
  }
  return {
    opaque: r,
    transparent: s,
    init: a,
    push: c,
    unshift: h,
    finish: u,
    sort: d
  };
}
function tR(t) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(s, o) {
    const a = e.get(s);
    let l;
    return a === void 0 ? (l = new uv(t), e.set(s, /* @__PURE__ */ new WeakMap()), e.get(s).set(o, l)) : (l = a.get(o), l === void 0 && (l = new uv(t), a.set(o, l))), l;
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
function nR() {
  const t = {};
  return {
    get: function(e) {
      if (t[e.id] !== void 0)
        return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new F(),
            color: new De()
          };
          break;
        case "SpotLight":
          n = {
            position: new F(),
            direction: new F(),
            color: new De(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new F(),
            color: new De(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new F(),
            skyColor: new De(),
            groundColor: new De()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new De(),
            position: new F(),
            halfWidth: new F(),
            halfHeight: new F()
          };
          break;
      }
      return t[e.id] = n, n;
    }
  };
}
function iR() {
  const t = {};
  return {
    get: function(e) {
      if (t[e.id] !== void 0)
        return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe()
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe()
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return t[e.id] = n, n;
    }
  };
}
let rR = 0;
function sR(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}
function oR(t, e) {
  const n = new nR(), r = iR(), s = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let d = 0; d < 9; d++) s.probe.push(new F());
  const o = new F(), a = new Ye(), l = new Ye();
  function c(d) {
    let u = 0, p = 0, f = 0;
    for (let C = 0; C < 9; C++) s.probe[C].set(0, 0, 0);
    let m = 0, y = 0, x = 0, v = 0, g = 0, S = 0, T = 0, E = 0;
    d.sort(sR);
    for (let C = 0, ee = d.length; C < ee; C++) {
      const Y = d[C], le = Y.color, B = Y.intensity, Z = Y.distance, k = Y.shadow && Y.shadow.map ? Y.shadow.map.texture : null;
      if (Y.isAmbientLight)
        u += le.r * B, p += le.g * B, f += le.b * B;
      else if (Y.isLightProbe)
        for (let O = 0; O < 9; O++)
          s.probe[O].addScaledVector(Y.sh.coefficients[O], B);
      else if (Y.isDirectionalLight) {
        const O = n.get(Y);
        if (O.color.copy(Y.color).multiplyScalar(Y.intensity), Y.castShadow) {
          const P = Y.shadow, j = r.get(Y);
          j.shadowBias = P.bias, j.shadowNormalBias = P.normalBias, j.shadowRadius = P.radius, j.shadowMapSize = P.mapSize, s.directionalShadow[m] = j, s.directionalShadowMap[m] = k, s.directionalShadowMatrix[m] = Y.shadow.matrix, S++;
        }
        s.directional[m] = O, m++;
      } else if (Y.isSpotLight) {
        const O = n.get(Y);
        if (O.position.setFromMatrixPosition(Y.matrixWorld), O.color.copy(le).multiplyScalar(B), O.distance = Z, O.coneCos = Math.cos(Y.angle), O.penumbraCos = Math.cos(Y.angle * (1 - Y.penumbra)), O.decay = Y.decay, Y.castShadow) {
          const P = Y.shadow, j = r.get(Y);
          j.shadowBias = P.bias, j.shadowNormalBias = P.normalBias, j.shadowRadius = P.radius, j.shadowMapSize = P.mapSize, s.spotShadow[x] = j, s.spotShadowMap[x] = k, s.spotShadowMatrix[x] = Y.shadow.matrix, E++;
        }
        s.spot[x] = O, x++;
      } else if (Y.isRectAreaLight) {
        const O = n.get(Y);
        O.color.copy(le).multiplyScalar(B), O.halfWidth.set(Y.width * 0.5, 0, 0), O.halfHeight.set(0, Y.height * 0.5, 0), s.rectArea[v] = O, v++;
      } else if (Y.isPointLight) {
        const O = n.get(Y);
        if (O.color.copy(Y.color).multiplyScalar(Y.intensity), O.distance = Y.distance, O.decay = Y.decay, Y.castShadow) {
          const P = Y.shadow, j = r.get(Y);
          j.shadowBias = P.bias, j.shadowNormalBias = P.normalBias, j.shadowRadius = P.radius, j.shadowMapSize = P.mapSize, j.shadowCameraNear = P.camera.near, j.shadowCameraFar = P.camera.far, s.pointShadow[y] = j, s.pointShadowMap[y] = k, s.pointShadowMatrix[y] = Y.shadow.matrix, T++;
        }
        s.point[y] = O, y++;
      } else if (Y.isHemisphereLight) {
        const O = n.get(Y);
        O.skyColor.copy(Y.color).multiplyScalar(B), O.groundColor.copy(Y.groundColor).multiplyScalar(B), s.hemi[g] = O, g++;
      }
    }
    v > 0 && (e.isWebGL2 || t.has("OES_texture_float_linear") === !0 ? (s.rectAreaLTC1 = Te.LTC_FLOAT_1, s.rectAreaLTC2 = Te.LTC_FLOAT_2) : t.has("OES_texture_half_float_linear") === !0 ? (s.rectAreaLTC1 = Te.LTC_HALF_1, s.rectAreaLTC2 = Te.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), s.ambient[0] = u, s.ambient[1] = p, s.ambient[2] = f;
    const w = s.hash;
    (w.directionalLength !== m || w.pointLength !== y || w.spotLength !== x || w.rectAreaLength !== v || w.hemiLength !== g || w.numDirectionalShadows !== S || w.numPointShadows !== T || w.numSpotShadows !== E) && (s.directional.length = m, s.spot.length = x, s.rectArea.length = v, s.point.length = y, s.hemi.length = g, s.directionalShadow.length = S, s.directionalShadowMap.length = S, s.pointShadow.length = T, s.pointShadowMap.length = T, s.spotShadow.length = E, s.spotShadowMap.length = E, s.directionalShadowMatrix.length = S, s.pointShadowMatrix.length = T, s.spotShadowMatrix.length = E, w.directionalLength = m, w.pointLength = y, w.spotLength = x, w.rectAreaLength = v, w.hemiLength = g, w.numDirectionalShadows = S, w.numPointShadows = T, w.numSpotShadows = E, s.version = rR++);
  }
  function h(d, u) {
    let p = 0, f = 0, m = 0, y = 0, x = 0;
    const v = u.matrixWorldInverse;
    for (let g = 0, S = d.length; g < S; g++) {
      const T = d[g];
      if (T.isDirectionalLight) {
        const E = s.directional[p];
        E.direction.setFromMatrixPosition(T.matrixWorld), o.setFromMatrixPosition(T.target.matrixWorld), E.direction.sub(o), E.direction.transformDirection(v), p++;
      } else if (T.isSpotLight) {
        const E = s.spot[m];
        E.position.setFromMatrixPosition(T.matrixWorld), E.position.applyMatrix4(v), E.direction.setFromMatrixPosition(T.matrixWorld), o.setFromMatrixPosition(T.target.matrixWorld), E.direction.sub(o), E.direction.transformDirection(v), m++;
      } else if (T.isRectAreaLight) {
        const E = s.rectArea[y];
        E.position.setFromMatrixPosition(T.matrixWorld), E.position.applyMatrix4(v), l.identity(), a.copy(T.matrixWorld), a.premultiply(v), l.extractRotation(a), E.halfWidth.set(T.width * 0.5, 0, 0), E.halfHeight.set(0, T.height * 0.5, 0), E.halfWidth.applyMatrix4(l), E.halfHeight.applyMatrix4(l), y++;
      } else if (T.isPointLight) {
        const E = s.point[f];
        E.position.setFromMatrixPosition(T.matrixWorld), E.position.applyMatrix4(v), f++;
      } else if (T.isHemisphereLight) {
        const E = s.hemi[x];
        E.direction.setFromMatrixPosition(T.matrixWorld), E.direction.transformDirection(v), E.direction.normalize(), x++;
      }
    }
  }
  return {
    setup: c,
    setupView: h,
    state: s
  };
}
function dv(t, e) {
  const n = new oR(t, e), r = [], s = [];
  function o() {
    r.length = 0, s.length = 0;
  }
  function a(u) {
    r.push(u);
  }
  function l(u) {
    s.push(u);
  }
  function c() {
    n.setup(r);
  }
  function h(u) {
    n.setupView(r, u);
  }
  return {
    init: o,
    state: {
      lightsArray: r,
      shadowsArray: s,
      lights: n
    },
    setupLights: c,
    setupLightsView: h,
    pushLight: a,
    pushShadow: l
  };
}
function aR(t, e) {
  let n = /* @__PURE__ */ new WeakMap();
  function r(o, a = 0) {
    let l;
    return n.has(o) === !1 ? (l = new dv(t, e), n.set(o, []), n.get(o).push(l)) : a >= n.get(o).length ? (l = new dv(t, e), n.get(o).push(l)) : l = n.get(o)[a], l;
  }
  function s() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: s
  };
}
function ws(t) {
  ke.call(this), this.type = "MeshDepthMaterial", this.depthPacking = JA, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t);
}
ws.prototype = Object.create(ke.prototype);
ws.prototype.constructor = ws;
ws.prototype.isMeshDepthMaterial = !0;
ws.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
};
function Ms(t) {
  ke.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new F(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t);
}
Ms.prototype = Object.create(ke.prototype);
Ms.prototype.constructor = Ms;
Ms.prototype.isMeshDistanceMaterial = !0;
Ms.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
};
var lR = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`, cR = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
function xx(t, e, n) {
  let r = new cu();
  const s = new xe(), o = new xe(), a = new st(), l = [], c = [], h = {}, d = { 0: Ct, 1: Fl, 2: su }, u = new Kt({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new xe() },
      radius: { value: 4 }
    },
    vertexShader: cR,
    fragmentShader: lR
  }), p = u.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const f = new ot();
  f.setAttribute(
    "position",
    new qe(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const m = new at(f, u), y = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Qy, this.render = function(E, w, C) {
    if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || E.length === 0) return;
    const ee = t.getRenderTarget(), Y = t.getActiveCubeFace(), le = t.getActiveMipmapLevel(), B = t.state;
    B.setBlending(Ga), B.buffers.color.setClear(1, 1, 1, 1), B.buffers.depth.setTest(!0), B.setScissorTest(!1);
    for (let Z = 0, k = E.length; Z < k; Z++) {
      const O = E[Z], P = O.shadow;
      if (P === void 0) {
        console.warn("THREE.WebGLShadowMap:", O, "has no shadow.");
        continue;
      }
      if (P.autoUpdate === !1 && P.needsUpdate === !1) continue;
      s.copy(P.mapSize);
      const j = P.getFrameExtents();
      if (s.multiply(j), o.copy(P.mapSize), (s.x > n || s.y > n) && (s.x > n && (o.x = Math.floor(n / j.x), s.x = o.x * j.x, P.mapSize.x = o.x), s.y > n && (o.y = Math.floor(n / j.y), s.y = o.y * j.y, P.mapSize.y = o.y)), P.map === null && !P.isPointLightShadow && this.type === Ra) {
        const ae = { minFilter: At, magFilter: At, format: Nn };
        P.map = new ai(s.x, s.y, ae), P.map.texture.name = O.name + ".shadowMap", P.mapPass = new ai(s.x, s.y, ae), P.camera.updateProjectionMatrix();
      }
      if (P.map === null) {
        const ae = { minFilter: Xt, magFilter: Xt, format: Nn };
        P.map = new ai(s.x, s.y, ae), P.map.texture.name = O.name + ".shadowMap", P.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(P.map), t.clear();
      const re = P.getViewportCount();
      for (let ae = 0; ae < re; ae++) {
        const ce = P.getViewport(ae);
        a.set(
          o.x * ce.x,
          o.y * ce.y,
          o.x * ce.z,
          o.y * ce.w
        ), B.viewport(a), P.updateMatrices(O, ae), r = P.getFrustum(), T(w, C, P.camera, O, this.type);
      }
      !P.isPointLightShadow && this.type === Ra && x(P, C), P.needsUpdate = !1;
    }
    y.needsUpdate = !1, t.setRenderTarget(ee, Y, le);
  };
  function x(E, w) {
    const C = e.update(m);
    u.uniforms.shadow_pass.value = E.map.texture, u.uniforms.resolution.value = E.mapSize, u.uniforms.radius.value = E.radius, t.setRenderTarget(E.mapPass), t.clear(), t.renderBufferDirect(w, null, C, u, m, null), p.uniforms.shadow_pass.value = E.mapPass.texture, p.uniforms.resolution.value = E.mapSize, p.uniforms.radius.value = E.radius, t.setRenderTarget(E.map), t.clear(), t.renderBufferDirect(w, null, C, p, m, null);
  }
  function v(E, w, C) {
    const ee = E << 0 | w << 1 | C << 2;
    let Y = l[ee];
    return Y === void 0 && (Y = new ws({
      depthPacking: KA,
      morphTargets: E,
      skinning: w
    }), l[ee] = Y), Y;
  }
  function g(E, w, C) {
    const ee = E << 0 | w << 1 | C << 2;
    let Y = c[ee];
    return Y === void 0 && (Y = new Ms({
      morphTargets: E,
      skinning: w
    }), c[ee] = Y), Y;
  }
  function S(E, w, C, ee, Y, le, B) {
    let Z = null, k = v, O = E.customDepthMaterial;
    if (ee.isPointLight === !0 && (k = g, O = E.customDistanceMaterial), O === void 0) {
      let P = !1;
      C.morphTargets === !0 && (P = w.morphAttributes && w.morphAttributes.position && w.morphAttributes.position.length > 0);
      let j = !1;
      E.isSkinnedMesh === !0 && (C.skinning === !0 ? j = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", E));
      const re = E.isInstancedMesh === !0;
      Z = k(P, j, re);
    } else
      Z = O;
    if (t.localClippingEnabled && C.clipShadows === !0 && C.clippingPlanes.length !== 0) {
      const P = Z.uuid, j = C.uuid;
      let re = h[P];
      re === void 0 && (re = {}, h[P] = re);
      let ae = re[j];
      ae === void 0 && (ae = Z.clone(), re[j] = ae), Z = ae;
    }
    return Z.visible = C.visible, Z.wireframe = C.wireframe, B === Ra ? Z.side = C.shadowSide !== null ? C.shadowSide : C.side : Z.side = C.shadowSide !== null ? C.shadowSide : d[C.side], Z.clipShadows = C.clipShadows, Z.clippingPlanes = C.clippingPlanes, Z.clipIntersection = C.clipIntersection, Z.wireframeLinewidth = C.wireframeLinewidth, Z.linewidth = C.linewidth, ee.isPointLight === !0 && Z.isMeshDistanceMaterial === !0 && (Z.referencePosition.setFromMatrixPosition(ee.matrixWorld), Z.nearDistance = Y, Z.farDistance = le), Z;
  }
  function T(E, w, C, ee, Y) {
    if (E.visible === !1) return;
    if (E.layers.test(w.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && Y === Ra) && (!E.frustumCulled || r.intersectsObject(E))) {
      E.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, E.matrixWorld);
      const Z = e.update(E), k = E.material;
      if (Array.isArray(k)) {
        const O = Z.groups;
        for (let P = 0, j = O.length; P < j; P++) {
          const re = O[P], ae = k[re.materialIndex];
          if (ae && ae.visible) {
            const ce = S(E, Z, ae, ee, C.near, C.far, Y);
            t.renderBufferDirect(C, null, Z, ce, E, re);
          }
        }
      } else if (k.visible) {
        const O = S(E, Z, k, ee, C.near, C.far, Y);
        t.renderBufferDirect(C, null, Z, O, E, null);
      }
    }
    const B = E.children;
    for (let Z = 0, k = B.length; Z < k; Z++)
      T(B[Z], w, C, ee, Y);
  }
}
function hR(t, e, n) {
  const r = n.isWebGL2;
  function s() {
    let A = !1;
    const ie = new st();
    let oe = null;
    const he = new st(0, 0, 0, 0);
    return {
      setMask: function(se) {
        oe !== se && !A && (t.colorMask(se, se, se, se), oe = se);
      },
      setLocked: function(se) {
        A = se;
      },
      setClear: function(se, me, ve, be, fe) {
        fe === !0 && (se *= be, me *= be, ve *= be), ie.set(se, me, ve, be), he.equals(ie) === !1 && (t.clearColor(se, me, ve, be), he.copy(ie));
      },
      reset: function() {
        A = !1, oe = null, he.set(-1, 0, 0, 0);
      }
    };
  }
  function o() {
    let A = !1, ie = null, oe = null, he = null;
    return {
      setTest: function(se) {
        se ? pe(2929) : de(2929);
      },
      setMask: function(se) {
        ie !== se && !A && (t.depthMask(se), ie = se);
      },
      setFunc: function(se) {
        if (oe !== se) {
          if (se)
            switch (se) {
              case OT:
                t.depthFunc(512);
                break;
              case FT:
                t.depthFunc(519);
                break;
              case BT:
                t.depthFunc(513);
                break;
              case lf:
                t.depthFunc(515);
                break;
              case zT:
                t.depthFunc(514);
                break;
              case UT:
                t.depthFunc(518);
                break;
              case HT:
                t.depthFunc(516);
                break;
              case GT:
                t.depthFunc(517);
                break;
              default:
                t.depthFunc(515);
            }
          else
            t.depthFunc(515);
          oe = se;
        }
      },
      setLocked: function(se) {
        A = se;
      },
      setClear: function(se) {
        he !== se && (t.clearDepth(se), he = se);
      },
      reset: function() {
        A = !1, ie = null, oe = null, he = null;
      }
    };
  }
  function a() {
    let A = !1, ie = null, oe = null, he = null, se = null, me = null, ve = null, be = null, fe = null;
    return {
      setTest: function(_e) {
        A || (_e ? pe(2960) : de(2960));
      },
      setMask: function(_e) {
        ie !== _e && !A && (t.stencilMask(_e), ie = _e);
      },
      setFunc: function(_e, Pe, rt) {
        (oe !== _e || he !== Pe || se !== rt) && (t.stencilFunc(_e, Pe, rt), oe = _e, he = Pe, se = rt);
      },
      setOp: function(_e, Pe, rt) {
        (me !== _e || ve !== Pe || be !== rt) && (t.stencilOp(_e, Pe, rt), me = _e, ve = Pe, be = rt);
      },
      setLocked: function(_e) {
        A = _e;
      },
      setClear: function(_e) {
        fe !== _e && (t.clearStencil(_e), fe = _e);
      },
      reset: function() {
        A = !1, ie = null, oe = null, he = null, se = null, me = null, ve = null, be = null, fe = null;
      }
    };
  }
  const l = new s(), c = new o(), h = new a();
  let d = {}, u = null, p = null, f = null, m = null, y = null, x = null, v = null, g = null, S = null, T = !1, E = null, w = null, C = null, ee = null, Y = null;
  const le = t.getParameter(35661);
  let B = !1, Z = 0;
  const k = t.getParameter(7938);
  k.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec(k)[1]), B = Z >= 1) : k.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec(k)[1]), B = Z >= 2);
  let O = null, P = {};
  const j = new st(), re = new st();
  function ae(A, ie, oe) {
    const he = new Uint8Array(4), se = t.createTexture();
    t.bindTexture(A, se), t.texParameteri(A, 10241, 9728), t.texParameteri(A, 10240, 9728);
    for (let me = 0; me < oe; me++)
      t.texImage2D(ie + me, 0, 6408, 1, 1, 0, 6408, 5121, he);
    return se;
  }
  const ce = {};
  ce[3553] = ae(3553, 3553, 1), ce[34067] = ae(34067, 34069, 6), l.setClear(0, 0, 0, 1), c.setClear(1), h.setClear(0), pe(2929), c.setFunc(lf), L(!1), U(bg), pe(2884), te(Ga);
  function pe(A) {
    d[A] !== !0 && (t.enable(A), d[A] = !0);
  }
  function de(A) {
    d[A] !== !1 && (t.disable(A), d[A] = !1);
  }
  function ge(A) {
    return u !== A ? (t.useProgram(A), u = A, !0) : !1;
  }
  const we = {
    [lo]: 32774,
    [ST]: 32778,
    [ET]: 32779
  };
  if (r)
    we[Eg] = 32775, we[Tg] = 32776;
  else {
    const A = e.get("EXT_blend_minmax");
    A !== null && (we[Eg] = A.MIN_EXT, we[Tg] = A.MAX_EXT);
  }
  const Ge = {
    [TT]: 0,
    [AT]: 1,
    [LT]: 768,
    [tx]: 770,
    [NT]: 776,
    [IT]: 774,
    [RT]: 772,
    [CT]: 769,
    [nx]: 771,
    [DT]: 775,
    [PT]: 773
  };
  function te(A, ie, oe, he, se, me, ve, be) {
    if (A === Ga) {
      p && (de(3042), p = !1);
      return;
    }
    if (p || (pe(3042), p = !0), A !== MT) {
      if (A !== f || be !== T) {
        if ((m !== lo || v !== lo) && (t.blendEquation(32774), m = lo, v = lo), be)
          switch (A) {
            case Va:
              t.blendFuncSeparate(1, 771, 1, 771);
              break;
            case wg:
              t.blendFunc(1, 1);
              break;
            case Mg:
              t.blendFuncSeparate(0, 0, 769, 771);
              break;
            case Sg:
              t.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", A);
              break;
          }
        else
          switch (A) {
            case Va:
              t.blendFuncSeparate(770, 771, 1, 771);
              break;
            case wg:
              t.blendFunc(770, 1);
              break;
            case Mg:
              t.blendFunc(0, 769);
              break;
            case Sg:
              t.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", A);
              break;
          }
        y = null, x = null, g = null, S = null, f = A, T = be;
      }
      return;
    }
    se = se || ie, me = me || oe, ve = ve || he, (ie !== m || se !== v) && (t.blendEquationSeparate(we[ie], we[se]), m = ie, v = se), (oe !== y || he !== x || me !== g || ve !== S) && (t.blendFuncSeparate(Ge[oe], Ge[he], Ge[me], Ge[ve]), y = oe, x = he, g = me, S = ve), f = A, T = null;
  }
  function I(A, ie) {
    A.side === su ? de(2884) : pe(2884);
    let oe = A.side === Ct;
    ie && (oe = !oe), L(oe), A.blending === Va && A.transparent === !1 ? te(Ga) : te(A.blending, A.blendEquation, A.blendSrc, A.blendDst, A.blendEquationAlpha, A.blendSrcAlpha, A.blendDstAlpha, A.premultipliedAlpha), c.setFunc(A.depthFunc), c.setTest(A.depthTest), c.setMask(A.depthWrite), l.setMask(A.colorWrite);
    const he = A.stencilWrite;
    h.setTest(he), he && (h.setMask(A.stencilWriteMask), h.setFunc(A.stencilFunc, A.stencilRef, A.stencilFuncMask), h.setOp(A.stencilFail, A.stencilZFail, A.stencilZPass)), V(A.polygonOffset, A.polygonOffsetFactor, A.polygonOffsetUnits);
  }
  function L(A) {
    E !== A && (A ? t.frontFace(2304) : t.frontFace(2305), E = A);
  }
  function U(A) {
    A !== _T ? (pe(2884), A !== w && (A === bg ? t.cullFace(1029) : A === bT ? t.cullFace(1028) : t.cullFace(1032))) : de(2884), w = A;
  }
  function N(A) {
    A !== C && (B && t.lineWidth(A), C = A);
  }
  function V(A, ie, oe) {
    A ? (pe(32823), (ee !== ie || Y !== oe) && (t.polygonOffset(ie, oe), ee = ie, Y = oe)) : de(32823);
  }
  function W(A) {
    A ? pe(3089) : de(3089);
  }
  function R(A) {
    A === void 0 && (A = 33984 + le - 1), O !== A && (t.activeTexture(A), O = A);
  }
  function D(A, ie) {
    O === null && R();
    let oe = P[O];
    oe === void 0 && (oe = { type: void 0, texture: void 0 }, P[O] = oe), (oe.type !== A || oe.texture !== ie) && (t.bindTexture(A, ie || ce[A]), oe.type = A, oe.texture = ie);
  }
  function H() {
    const A = P[O];
    A !== void 0 && A.type !== void 0 && (t.bindTexture(A.type, null), A.type = void 0, A.texture = void 0);
  }
  function ne() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (A) {
      console.error("THREE.WebGLState:", A);
    }
  }
  function J() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (A) {
      console.error("THREE.WebGLState:", A);
    }
  }
  function b() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (A) {
      console.error("THREE.WebGLState:", A);
    }
  }
  function _(A) {
    j.equals(A) === !1 && (t.scissor(A.x, A.y, A.z, A.w), j.copy(A));
  }
  function Q(A) {
    re.equals(A) === !1 && (t.viewport(A.x, A.y, A.z, A.w), re.copy(A));
  }
  function X() {
    d = {}, O = null, P = {}, u = null, p = null, f = null, m = null, y = null, x = null, v = null, g = null, S = null, T = !1, E = null, w = null, C = null, ee = null, Y = null, l.reset(), c.reset(), h.reset();
  }
  return {
    buffers: {
      color: l,
      depth: c,
      stencil: h
    },
    enable: pe,
    disable: de,
    useProgram: ge,
    setBlending: te,
    setMaterial: I,
    setFlipSided: L,
    setCullFace: U,
    setLineWidth: N,
    setPolygonOffset: V,
    setScissorTest: W,
    activeTexture: R,
    bindTexture: D,
    unbindTexture: H,
    compressedTexImage2D: ne,
    texImage2D: J,
    texImage3D: b,
    scissor: _,
    viewport: Q,
    reset: X
  };
}
function uR(t, e, n, r, s, o, a) {
  const l = s.isWebGL2, c = s.maxTextures, h = s.maxCubemapSize, d = s.maxTextureSize, u = s.maxSamples, p = /* @__PURE__ */ new WeakMap();
  let f, m = !1;
  try {
    m = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function y(b, _) {
    return m ? new OffscreenCanvas(b, _) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function x(b, _, Q, X) {
    let A = 1;
    if ((b.width > X || b.height > X) && (A = X / Math.max(b.width, b.height)), A < 1 || _ === !0)
      if (typeof HTMLImageElement < "u" && b instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && b instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && b instanceof ImageBitmap) {
        const ie = _ ? Xe.floorPowerOfTwo : Math.floor, oe = ie(A * b.width), he = ie(A * b.height);
        f === void 0 && (f = y(oe, he));
        const se = Q ? y(oe, he) : f;
        return se.width = oe, se.height = he, se.getContext("2d").drawImage(b, 0, 0, oe, he), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + b.width + "x" + b.height + ") to (" + oe + "x" + he + ")."), se;
      } else
        return "data" in b && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + b.width + "x" + b.height + ")."), b;
    return b;
  }
  function v(b) {
    return Xe.isPowerOfTwo(b.width) && Xe.isPowerOfTwo(b.height);
  }
  function g(b) {
    return l ? !1 : b.wrapS !== yn || b.wrapT !== yn || b.minFilter !== Xt && b.minFilter !== At;
  }
  function S(b, _) {
    return b.generateMipmaps && _ && b.minFilter !== Xt && b.minFilter !== At;
  }
  function T(b, _, Q, X) {
    t.generateMipmap(b);
    const A = r.get(_);
    A.__maxMipLevel = Math.log(Math.max(Q, X)) * Math.LOG2E;
  }
  function E(b, _, Q) {
    if (l === !1) return _;
    if (b !== null) {
      if (t[b] !== void 0) return t[b];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + b + "'");
    }
    let X = _;
    return _ === 6403 && (Q === 5126 && (X = 33326), Q === 5131 && (X = 33325), Q === 5121 && (X = 33321)), _ === 6407 && (Q === 5126 && (X = 34837), Q === 5131 && (X = 34843), Q === 5121 && (X = 32849)), _ === 6408 && (Q === 5126 && (X = 34836), Q === 5131 && (X = 34842), Q === 5121 && (X = 32856)), (X === 33325 || X === 33326 || X === 34842 || X === 34836) && e.get("EXT_color_buffer_float"), X;
  }
  function w(b) {
    return b === Xt || b === Cg || b === Rg ? 9728 : 9729;
  }
  function C(b) {
    const _ = b.target;
    _.removeEventListener("dispose", C), Y(_), _.isVideoTexture && p.delete(_), a.memory.textures--;
  }
  function ee(b) {
    const _ = b.target;
    _.removeEventListener("dispose", ee), le(_), a.memory.textures--;
  }
  function Y(b) {
    const _ = r.get(b);
    _.__webglInit !== void 0 && (t.deleteTexture(_.__webglTexture), r.remove(b));
  }
  function le(b) {
    const _ = r.get(b), Q = r.get(b.texture);
    if (b) {
      if (Q.__webglTexture !== void 0 && t.deleteTexture(Q.__webglTexture), b.depthTexture && b.depthTexture.dispose(), b.isWebGLCubeRenderTarget)
        for (let X = 0; X < 6; X++)
          t.deleteFramebuffer(_.__webglFramebuffer[X]), _.__webglDepthbuffer && t.deleteRenderbuffer(_.__webglDepthbuffer[X]);
      else
        t.deleteFramebuffer(_.__webglFramebuffer), _.__webglDepthbuffer && t.deleteRenderbuffer(_.__webglDepthbuffer), _.__webglMultisampledFramebuffer && t.deleteFramebuffer(_.__webglMultisampledFramebuffer), _.__webglColorRenderbuffer && t.deleteRenderbuffer(_.__webglColorRenderbuffer), _.__webglDepthRenderbuffer && t.deleteRenderbuffer(_.__webglDepthRenderbuffer);
      r.remove(b.texture), r.remove(b);
    }
  }
  let B = 0;
  function Z() {
    B = 0;
  }
  function k() {
    const b = B;
    return b >= c && console.warn("THREE.WebGLTextures: Trying to use " + b + " texture units while this GPU supports only " + c), B += 1, b;
  }
  function O(b, _) {
    const Q = r.get(b);
    if (b.isVideoTexture && R(b), b.version > 0 && Q.__version !== b.version) {
      const X = b.image;
      if (X === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else if (X.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ge(Q, b, _);
        return;
      }
    }
    n.activeTexture(33984 + _), n.bindTexture(3553, Q.__webglTexture);
  }
  function P(b, _) {
    const Q = r.get(b);
    if (b.version > 0 && Q.__version !== b.version) {
      ge(Q, b, _);
      return;
    }
    n.activeTexture(33984 + _), n.bindTexture(35866, Q.__webglTexture);
  }
  function j(b, _) {
    const Q = r.get(b);
    if (b.version > 0 && Q.__version !== b.version) {
      ge(Q, b, _);
      return;
    }
    n.activeTexture(33984 + _), n.bindTexture(32879, Q.__webglTexture);
  }
  function re(b, _) {
    const Q = r.get(b);
    if (b.version > 0 && Q.__version !== b.version) {
      we(Q, b, _);
      return;
    }
    n.activeTexture(33984 + _), n.bindTexture(34067, Q.__webglTexture);
  }
  const ae = {
    [cf]: 10497,
    [yn]: 33071,
    [hf]: 33648
  }, ce = {
    [Xt]: 9728,
    [Cg]: 9984,
    [Rg]: 9986,
    [At]: 9729,
    [YT]: 9985,
    [au]: 9987
  };
  function pe(b, _, Q) {
    Q ? (t.texParameteri(b, 10242, ae[_.wrapS]), t.texParameteri(b, 10243, ae[_.wrapT]), (b === 32879 || b === 35866) && t.texParameteri(b, 32882, ae[_.wrapR]), t.texParameteri(b, 10240, ce[_.magFilter]), t.texParameteri(b, 10241, ce[_.minFilter])) : (t.texParameteri(b, 10242, 33071), t.texParameteri(b, 10243, 33071), (b === 32879 || b === 35866) && t.texParameteri(b, 32882, 33071), (_.wrapS !== yn || _.wrapT !== yn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(b, 10240, w(_.magFilter)), t.texParameteri(b, 10241, w(_.minFilter)), _.minFilter !== Xt && _.minFilter !== At && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
    const X = e.get("EXT_texture_filter_anisotropic");
    if (X) {
      if (_.type === Rr && e.get("OES_texture_float_linear") === null || _.type === Ih && (l || e.get("OES_texture_half_float_linear")) === null) return;
      (_.anisotropy > 1 || r.get(_).__currentAnisotropy) && (t.texParameterf(b, X.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(_.anisotropy, s.getMaxAnisotropy())), r.get(_).__currentAnisotropy = _.anisotropy);
    }
  }
  function de(b, _) {
    b.__webglInit === void 0 && (b.__webglInit = !0, _.addEventListener("dispose", C), b.__webglTexture = t.createTexture(), a.memory.textures++);
  }
  function ge(b, _, Q) {
    let X = 3553;
    _.isDataTexture2DArray && (X = 35866), _.isDataTexture3D && (X = 32879), de(b, _), n.activeTexture(33984 + Q), n.bindTexture(X, b.__webglTexture), t.pixelStorei(37440, _.flipY), t.pixelStorei(37441, _.premultiplyAlpha), t.pixelStorei(3317, _.unpackAlignment);
    const A = g(_) && v(_.image) === !1, ie = x(_.image, A, !1, d), oe = v(ie) || l, he = o.convert(_.format);
    let se = o.convert(_.type), me = E(_.internalFormat, he, se);
    pe(X, _, oe);
    let ve;
    const be = _.mipmaps;
    if (_.isDepthTexture)
      me = 6402, l ? _.type === Rr ? me = 36012 : _.type === ch ? me = 33190 : _.type === Wa ? me = 35056 : me = 33189 : _.type === Rr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), _.format === Eo && me === 6402 && _.type !== Ph && _.type !== ch && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), _.type = Ph, se = o.convert(_.type)), _.format === ml && me === 6402 && (me = 34041, _.type !== Wa && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), _.type = Wa, se = o.convert(_.type))), n.texImage2D(3553, 0, me, ie.width, ie.height, 0, he, se, null);
    else if (_.isDataTexture)
      if (be.length > 0 && oe) {
        for (let fe = 0, _e = be.length; fe < _e; fe++)
          ve = be[fe], n.texImage2D(3553, fe, me, ve.width, ve.height, 0, he, se, ve.data);
        _.generateMipmaps = !1, b.__maxMipLevel = be.length - 1;
      } else
        n.texImage2D(3553, 0, me, ie.width, ie.height, 0, he, se, ie.data), b.__maxMipLevel = 0;
    else if (_.isCompressedTexture) {
      for (let fe = 0, _e = be.length; fe < _e; fe++)
        ve = be[fe], _.format !== Nn && _.format !== Br ? he !== null ? n.compressedTexImage2D(3553, fe, me, ve.width, ve.height, 0, ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, fe, me, ve.width, ve.height, 0, he, se, ve.data);
      b.__maxMipLevel = be.length - 1;
    } else if (_.isDataTexture2DArray)
      n.texImage3D(35866, 0, me, ie.width, ie.height, ie.depth, 0, he, se, ie.data), b.__maxMipLevel = 0;
    else if (_.isDataTexture3D)
      n.texImage3D(32879, 0, me, ie.width, ie.height, ie.depth, 0, he, se, ie.data), b.__maxMipLevel = 0;
    else if (be.length > 0 && oe) {
      for (let fe = 0, _e = be.length; fe < _e; fe++)
        ve = be[fe], n.texImage2D(3553, fe, me, he, se, ve);
      _.generateMipmaps = !1, b.__maxMipLevel = be.length - 1;
    } else
      n.texImage2D(3553, 0, me, he, se, ie), b.__maxMipLevel = 0;
    S(_, oe) && T(X, _, ie.width, ie.height), b.__version = _.version, _.onUpdate && _.onUpdate(_);
  }
  function we(b, _, Q) {
    if (_.image.length !== 6) return;
    de(b, _), n.activeTexture(33984 + Q), n.bindTexture(34067, b.__webglTexture), t.pixelStorei(37440, _.flipY);
    const X = _ && (_.isCompressedTexture || _.image[0].isCompressedTexture), A = _.image[0] && _.image[0].isDataTexture, ie = [];
    for (let fe = 0; fe < 6; fe++)
      !X && !A ? ie[fe] = x(_.image[fe], !1, !0, h) : ie[fe] = A ? _.image[fe].image : _.image[fe];
    const oe = ie[0], he = v(oe) || l, se = o.convert(_.format), me = o.convert(_.type), ve = E(_.internalFormat, se, me);
    pe(34067, _, he);
    let be;
    if (X) {
      for (let fe = 0; fe < 6; fe++) {
        be = ie[fe].mipmaps;
        for (let _e = 0; _e < be.length; _e++) {
          const Pe = be[_e];
          _.format !== Nn && _.format !== Br ? se !== null ? n.compressedTexImage2D(34069 + fe, _e, ve, Pe.width, Pe.height, 0, Pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + fe, _e, ve, Pe.width, Pe.height, 0, se, me, Pe.data);
        }
      }
      b.__maxMipLevel = be.length - 1;
    } else {
      be = _.mipmaps;
      for (let fe = 0; fe < 6; fe++)
        if (A) {
          n.texImage2D(34069 + fe, 0, ve, ie[fe].width, ie[fe].height, 0, se, me, ie[fe].data);
          for (let _e = 0; _e < be.length; _e++) {
            const rt = be[_e].image[fe].image;
            n.texImage2D(34069 + fe, _e + 1, ve, rt.width, rt.height, 0, se, me, rt.data);
          }
        } else {
          n.texImage2D(34069 + fe, 0, ve, se, me, ie[fe]);
          for (let _e = 0; _e < be.length; _e++) {
            const Pe = be[_e];
            n.texImage2D(34069 + fe, _e + 1, ve, se, me, Pe.image[fe]);
          }
        }
      b.__maxMipLevel = be.length;
    }
    S(_, he) && T(34067, _, oe.width, oe.height), b.__version = _.version, _.onUpdate && _.onUpdate(_);
  }
  function Ge(b, _, Q, X) {
    const A = o.convert(_.texture.format), ie = o.convert(_.texture.type), oe = E(_.texture.internalFormat, A, ie);
    n.texImage2D(X, 0, oe, _.width, _.height, 0, A, ie, null), t.bindFramebuffer(36160, b), t.framebufferTexture2D(36160, Q, X, r.get(_.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function te(b, _, Q) {
    if (t.bindRenderbuffer(36161, b), _.depthBuffer && !_.stencilBuffer) {
      let X = 33189;
      if (Q) {
        const A = _.depthTexture;
        A && A.isDepthTexture && (A.type === Rr ? X = 36012 : A.type === ch && (X = 33190));
        const ie = W(_);
        t.renderbufferStorageMultisample(36161, ie, X, _.width, _.height);
      } else
        t.renderbufferStorage(36161, X, _.width, _.height);
      t.framebufferRenderbuffer(36160, 36096, 36161, b);
    } else if (_.depthBuffer && _.stencilBuffer) {
      if (Q) {
        const X = W(_);
        t.renderbufferStorageMultisample(36161, X, 35056, _.width, _.height);
      } else
        t.renderbufferStorage(36161, 34041, _.width, _.height);
      t.framebufferRenderbuffer(36160, 33306, 36161, b);
    } else {
      const X = o.convert(_.texture.format), A = o.convert(_.texture.type), ie = E(_.texture.internalFormat, X, A);
      if (Q) {
        const oe = W(_);
        t.renderbufferStorageMultisample(36161, oe, ie, _.width, _.height);
      } else
        t.renderbufferStorage(36161, ie, _.width, _.height);
    }
    t.bindRenderbuffer(36161, null);
  }
  function I(b, _) {
    if (_ && _.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, b), !(_.depthTexture && _.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!r.get(_.depthTexture).__webglTexture || _.depthTexture.image.width !== _.width || _.depthTexture.image.height !== _.height) && (_.depthTexture.image.width = _.width, _.depthTexture.image.height = _.height, _.depthTexture.needsUpdate = !0), O(_.depthTexture, 0);
    const X = r.get(_.depthTexture).__webglTexture;
    if (_.depthTexture.format === Eo)
      t.framebufferTexture2D(36160, 36096, 3553, X, 0);
    else if (_.depthTexture.format === ml)
      t.framebufferTexture2D(36160, 33306, 3553, X, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function L(b) {
    const _ = r.get(b), Q = b.isWebGLCubeRenderTarget === !0;
    if (b.depthTexture) {
      if (Q) throw new Error("target.depthTexture not supported in Cube render targets");
      I(_.__webglFramebuffer, b);
    } else if (Q) {
      _.__webglDepthbuffer = [];
      for (let X = 0; X < 6; X++)
        t.bindFramebuffer(36160, _.__webglFramebuffer[X]), _.__webglDepthbuffer[X] = t.createRenderbuffer(), te(_.__webglDepthbuffer[X], b, !1);
    } else
      t.bindFramebuffer(36160, _.__webglFramebuffer), _.__webglDepthbuffer = t.createRenderbuffer(), te(_.__webglDepthbuffer, b, !1);
    t.bindFramebuffer(36160, null);
  }
  function U(b) {
    const _ = r.get(b), Q = r.get(b.texture);
    b.addEventListener("dispose", ee), Q.__webglTexture = t.createTexture(), a.memory.textures++;
    const X = b.isWebGLCubeRenderTarget === !0, A = b.isWebGLMultisampleRenderTarget === !0, ie = v(b) || l;
    if (l && b.texture.format === Br && (b.texture.type === Rr || b.texture.type === Ih) && (b.texture.format = Nn, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), X) {
      _.__webglFramebuffer = [];
      for (let oe = 0; oe < 6; oe++)
        _.__webglFramebuffer[oe] = t.createFramebuffer();
    } else if (_.__webglFramebuffer = t.createFramebuffer(), A)
      if (l) {
        _.__webglMultisampledFramebuffer = t.createFramebuffer(), _.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, _.__webglColorRenderbuffer);
        const oe = o.convert(b.texture.format), he = o.convert(b.texture.type), se = E(b.texture.internalFormat, oe, he), me = W(b);
        t.renderbufferStorageMultisample(36161, me, se, b.width, b.height), t.bindFramebuffer(36160, _.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, _.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), b.depthBuffer && (_.__webglDepthRenderbuffer = t.createRenderbuffer(), te(_.__webglDepthRenderbuffer, b, !0)), t.bindFramebuffer(36160, null);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    if (X) {
      n.bindTexture(34067, Q.__webglTexture), pe(34067, b.texture, ie);
      for (let oe = 0; oe < 6; oe++)
        Ge(_.__webglFramebuffer[oe], b, 36064, 34069 + oe);
      S(b.texture, ie) && T(34067, b.texture, b.width, b.height), n.bindTexture(34067, null);
    } else
      n.bindTexture(3553, Q.__webglTexture), pe(3553, b.texture, ie), Ge(_.__webglFramebuffer, b, 36064, 3553), S(b.texture, ie) && T(3553, b.texture, b.width, b.height), n.bindTexture(3553, null);
    b.depthBuffer && L(b);
  }
  function N(b) {
    const _ = b.texture, Q = v(b) || l;
    if (S(_, Q)) {
      const X = b.isWebGLCubeRenderTarget ? 34067 : 3553, A = r.get(_).__webglTexture;
      n.bindTexture(X, A), T(X, _, b.width, b.height), n.bindTexture(X, null);
    }
  }
  function V(b) {
    if (b.isWebGLMultisampleRenderTarget)
      if (l) {
        const _ = r.get(b);
        t.bindFramebuffer(36008, _.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, _.__webglFramebuffer);
        const Q = b.width, X = b.height;
        let A = 16384;
        b.depthBuffer && (A |= 256), b.stencilBuffer && (A |= 1024), t.blitFramebuffer(0, 0, Q, X, 0, 0, Q, X, A, 9728), t.bindFramebuffer(36160, _.__webglMultisampledFramebuffer);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }
  function W(b) {
    return l && b.isWebGLMultisampleRenderTarget ? Math.min(u, b.samples) : 0;
  }
  function R(b) {
    const _ = a.render.frame;
    p.get(b) !== _ && (p.set(b, _), b.update());
  }
  let D = !1, H = !1;
  function ne(b, _) {
    b && b.isWebGLRenderTarget && (D === !1 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), D = !0), b = b.texture), O(b, _);
  }
  function J(b, _) {
    b && b.isWebGLCubeRenderTarget && (H === !1 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), b = b.texture), re(b, _);
  }
  this.allocateTextureUnit = k, this.resetTextureUnits = Z, this.setTexture2D = O, this.setTexture2DArray = P, this.setTexture3D = j, this.setTextureCube = re, this.setupRenderTarget = U, this.updateRenderTargetMipmap = N, this.updateMultisampleRenderTarget = V, this.safeSetTexture2D = ne, this.safeSetTextureCube = J;
}
function dR(t, e, n) {
  const r = n.isWebGL2;
  function s(o) {
    let a;
    if (o === cp) return 5121;
    if (o === QT) return 32819;
    if (o === eA) return 32820;
    if (o === tA) return 33635;
    if (o === ZT) return 5120;
    if (o === JT) return 5122;
    if (o === Ph) return 5123;
    if (o === KT) return 5124;
    if (o === ch) return 5125;
    if (o === Rr) return 5126;
    if (o === Ih)
      return r ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
    if (o === nA) return 6406;
    if (o === Br) return 6407;
    if (o === Nn) return 6408;
    if (o === iA) return 6409;
    if (o === rA) return 6410;
    if (o === Eo) return 6402;
    if (o === ml) return 34041;
    if (o === sA) return 6403;
    if (o === oA) return 36244;
    if (o === aA) return 33319;
    if (o === lA) return 33320;
    if (o === cA) return 36248;
    if (o === hA) return 36249;
    if (o === Pg || o === Ig || o === Dg || o === Ng)
      if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (o === Pg) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === Ig) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === Dg) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === Ng) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (o === Og || o === Fg || o === Bg || o === zg)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (o === Og) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === Fg) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === Bg) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === zg) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (o === uA)
      return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    if ((o === Ug || o === Hg) && (a = e.get("WEBGL_compressed_texture_etc"), a !== null)) {
      if (o === Ug) return a.COMPRESSED_RGB8_ETC2;
      if (o === Hg) return a.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (o === dA || o === fA || o === pA || o === mA || o === gA || o === vA || o === yA || o === xA || o === _A || o === bA || o === wA || o === MA || o === SA || o === EA || o === AA || o === LA || o === CA || o === RA || o === PA || o === IA || o === DA || o === NA || o === OA || o === FA || o === BA || o === zA || o === UA || o === HA)
      return a = e.get("WEBGL_compressed_texture_astc"), a !== null ? o : null;
    if (o === TA)
      return a = e.get("EXT_texture_compression_bptc"), a !== null ? o : null;
    if (o === Wa)
      return r ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: s };
}
function xf(t = []) {
  Pt.call(this), this.cameras = t;
}
xf.prototype = Object.assign(Object.create(Pt.prototype), {
  constructor: xf,
  isArrayCamera: !0
});
function bo() {
  Ie.call(this), this.type = "Group";
}
bo.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: bo,
  isGroup: !0
});
function ja() {
  this._targetRay = null, this._grip = null, this._hand = null;
}
Object.assign(ja.prototype, {
  constructor: ja,
  getHandSpace: function() {
    if (this._hand === null && (this._hand = new bo(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand))
      for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
        const e = new bo();
        e.matrixAutoUpdate = !1, e.visible = !1, this._hand.joints.push(e), this._hand.add(e);
      }
    return this._hand;
  },
  getTargetRaySpace: function() {
    return this._targetRay === null && (this._targetRay = new bo(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay;
  },
  getGripSpace: function() {
    return this._grip === null && (this._grip = new bo(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip;
  },
  dispatchEvent: function(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  },
  disconnect: function(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  },
  update: function(t, e, n) {
    let r = null, s = null, o = null;
    const a = this._targetRay, l = this._grip, c = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred")
      if (c && t.hand) {
        o = !0;
        for (let h = 0; h <= window.XRHand.LITTLE_PHALANX_TIP; h++)
          if (t.hand[h]) {
            const d = e.getJointPose(t.hand[h], n), u = c.joints[h];
            d !== null && (u.matrix.fromArray(d.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.jointRadius = d.radius), u.visible = d !== null;
            const p = c.joints[window.XRHand.INDEX_PHALANX_TIP], f = c.joints[window.XRHand.THUMB_PHALANX_TIP], m = p.position.distanceTo(f.position), y = 0.02, x = 5e-3;
            c.inputState.pinching && m > y + x ? (c.inputState.pinching = !1, this.dispatchEvent({
              type: "pinchend",
              handedness: t.handedness,
              target: this
            })) : !c.inputState.pinching && m <= y - x && (c.inputState.pinching = !0, this.dispatchEvent({
              type: "pinchstart",
              handedness: t.handedness,
              target: this
            }));
          }
      } else
        a !== null && (r = e.getPose(t.targetRaySpace, n), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale))), l !== null && t.gripSpace && (s = e.getPose(t.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale)));
    return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this;
  }
});
function _x(t, e) {
  const n = this;
  let r = null, s = 1, o = null, a = "local-floor", l = null;
  const c = [], h = /* @__PURE__ */ new Map(), d = new Pt();
  d.layers.enable(1), d.viewport = new st();
  const u = new Pt();
  u.layers.enable(2), u.viewport = new st();
  const p = [d, u], f = new xf();
  f.layers.enable(1), f.layers.enable(2);
  let m = null, y = null;
  this.enabled = !1, this.isPresenting = !1, this.getController = function(B) {
    let Z = c[B];
    return Z === void 0 && (Z = new ja(), c[B] = Z), Z.getTargetRaySpace();
  }, this.getControllerGrip = function(B) {
    let Z = c[B];
    return Z === void 0 && (Z = new ja(), c[B] = Z), Z.getGripSpace();
  }, this.getHand = function(B) {
    let Z = c[B];
    return Z === void 0 && (Z = new ja(), c[B] = Z), Z.getHandSpace();
  };
  function x(B) {
    const Z = h.get(B.inputSource);
    Z && Z.dispatchEvent({ type: B.type, data: B.inputSource });
  }
  function v() {
    h.forEach(function(B, Z) {
      B.disconnect(Z);
    }), h.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), le.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" });
  }
  function g(B) {
    o = B, le.setContext(r), le.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
  }
  this.setFramebufferScaleFactor = function(B) {
    s = B, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
  }, this.setReferenceSpaceType = function(B) {
    a = B, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
  }, this.getReferenceSpace = function() {
    return o;
  }, this.getSession = function() {
    return r;
  }, this.setSession = function(B) {
    if (r = B, r !== null) {
      r.addEventListener("select", x), r.addEventListener("selectstart", x), r.addEventListener("selectend", x), r.addEventListener("squeeze", x), r.addEventListener("squeezestart", x), r.addEventListener("squeezeend", x), r.addEventListener("end", v);
      const Z = e.getContextAttributes();
      Z.xrCompatible !== !0 && e.makeXRCompatible();
      const k = {
        antialias: Z.antialias,
        alpha: Z.alpha,
        depth: Z.depth,
        stencil: Z.stencil,
        framebufferScaleFactor: s
      }, O = new XRWebGLLayer(r, e, k);
      r.updateRenderState({ baseLayer: O }), r.requestReferenceSpace(a).then(g), r.addEventListener("inputsourceschange", S);
    }
  };
  function S(B) {
    const Z = r.inputSources;
    for (let k = 0; k < c.length; k++)
      h.set(Z[k], c[k]);
    for (let k = 0; k < B.removed.length; k++) {
      const O = B.removed[k], P = h.get(O);
      P && (P.dispatchEvent({ type: "disconnected", data: O }), h.delete(O));
    }
    for (let k = 0; k < B.added.length; k++) {
      const O = B.added[k], P = h.get(O);
      P && P.dispatchEvent({ type: "connected", data: O });
    }
  }
  const T = new F(), E = new F();
  function w(B, Z, k) {
    T.setFromMatrixPosition(Z.matrixWorld), E.setFromMatrixPosition(k.matrixWorld);
    const O = T.distanceTo(E), P = Z.projectionMatrix.elements, j = k.projectionMatrix.elements, re = P[14] / (P[10] - 1), ae = P[14] / (P[10] + 1), ce = (P[9] + 1) / P[5], pe = (P[9] - 1) / P[5], de = (P[8] - 1) / P[0], ge = (j[8] + 1) / j[0], we = re * de, Ge = re * ge, te = O / (-de + ge), I = te * -de;
    Z.matrixWorld.decompose(B.position, B.quaternion, B.scale), B.translateX(I), B.translateZ(te), B.matrixWorld.compose(B.position, B.quaternion, B.scale), B.matrixWorldInverse.copy(B.matrixWorld).invert();
    const L = re + te, U = ae + te, N = we - I, V = Ge + (O - I), W = ce * ae / U * L, R = pe * ae / U * L;
    B.projectionMatrix.makePerspective(N, V, W, R, L, U);
  }
  function C(B, Z) {
    Z === null ? B.matrixWorld.copy(B.matrix) : B.matrixWorld.multiplyMatrices(Z.matrixWorld, B.matrix), B.matrixWorldInverse.copy(B.matrixWorld).invert();
  }
  this.getCamera = function(B) {
    f.near = u.near = d.near = B.near, f.far = u.far = d.far = B.far, (m !== f.near || y !== f.far) && (r.updateRenderState({
      depthNear: f.near,
      depthFar: f.far
    }), m = f.near, y = f.far);
    const Z = B.parent, k = f.cameras;
    C(f, Z);
    for (let P = 0; P < k.length; P++)
      C(k[P], Z);
    B.matrixWorld.copy(f.matrixWorld);
    const O = B.children;
    for (let P = 0, j = O.length; P < j; P++)
      O[P].updateMatrixWorld(!0);
    return k.length === 2 ? w(f, d, u) : f.projectionMatrix.copy(d.projectionMatrix), f;
  };
  let ee = null;
  function Y(B, Z) {
    if (l = Z.getViewerPose(o), l !== null) {
      const O = l.views, P = r.renderState.baseLayer;
      t.setFramebuffer(P.framebuffer);
      let j = !1;
      O.length !== f.cameras.length && (f.cameras.length = 0, j = !0);
      for (let re = 0; re < O.length; re++) {
        const ae = O[re], ce = P.getViewport(ae), pe = p[re];
        pe.matrix.fromArray(ae.transform.matrix), pe.projectionMatrix.fromArray(ae.projectionMatrix), pe.viewport.set(ce.x, ce.y, ce.width, ce.height), re === 0 && f.matrix.copy(pe.matrix), j === !0 && f.cameras.push(pe);
      }
    }
    const k = r.inputSources;
    for (let O = 0; O < c.length; O++) {
      const P = c[O], j = k[O];
      P.update(j, Z, o);
    }
    ee && ee(B, Z);
  }
  const le = new hx();
  le.setAnimationLoop(Y), this.setAnimationLoop = function(B) {
    ee = B;
  }, this.dispose = function() {
  };
}
Object.assign(_x.prototype, lr.prototype);
function fR(t) {
  function e(v, g) {
    v.fogColor.value.copy(g.color), g.isFog ? (v.fogNear.value = g.near, v.fogFar.value = g.far) : g.isFogExp2 && (v.fogDensity.value = g.density);
  }
  function n(v, g, S, T) {
    g.isMeshBasicMaterial ? r(v, g) : g.isMeshLambertMaterial ? (r(v, g), c(v, g)) : g.isMeshToonMaterial ? (r(v, g), d(v, g)) : g.isMeshPhongMaterial ? (r(v, g), h(v, g)) : g.isMeshStandardMaterial ? (r(v, g), g.isMeshPhysicalMaterial ? p(v, g) : u(v, g)) : g.isMeshMatcapMaterial ? (r(v, g), f(v, g)) : g.isMeshDepthMaterial ? (r(v, g), m(v, g)) : g.isMeshDistanceMaterial ? (r(v, g), y(v, g)) : g.isMeshNormalMaterial ? (r(v, g), x(v, g)) : g.isLineBasicMaterial ? (s(v, g), g.isLineDashedMaterial && o(v, g)) : g.isPointsMaterial ? a(v, g, S, T) : g.isSpriteMaterial ? l(v, g) : g.isShadowMaterial ? (v.color.value.copy(g.color), v.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function r(v, g) {
    v.opacity.value = g.opacity, g.color && v.diffuse.value.copy(g.color), g.emissive && v.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (v.map.value = g.map), g.alphaMap && (v.alphaMap.value = g.alphaMap), g.specularMap && (v.specularMap.value = g.specularMap);
    const S = t.get(g).envMap;
    if (S) {
      v.envMap.value = S, v.flipEnvMap.value = S.isCubeTexture && S._needsFlipEnvMap ? -1 : 1, v.reflectivity.value = g.reflectivity, v.refractionRatio.value = g.refractionRatio;
      const w = t.get(S).__maxMipLevel;
      w !== void 0 && (v.maxMipLevel.value = w);
    }
    g.lightMap && (v.lightMap.value = g.lightMap, v.lightMapIntensity.value = g.lightMapIntensity), g.aoMap && (v.aoMap.value = g.aoMap, v.aoMapIntensity.value = g.aoMapIntensity);
    let T;
    g.map ? T = g.map : g.specularMap ? T = g.specularMap : g.displacementMap ? T = g.displacementMap : g.normalMap ? T = g.normalMap : g.bumpMap ? T = g.bumpMap : g.roughnessMap ? T = g.roughnessMap : g.metalnessMap ? T = g.metalnessMap : g.alphaMap ? T = g.alphaMap : g.emissiveMap ? T = g.emissiveMap : g.clearcoatMap ? T = g.clearcoatMap : g.clearcoatNormalMap ? T = g.clearcoatNormalMap : g.clearcoatRoughnessMap && (T = g.clearcoatRoughnessMap), T !== void 0 && (T.isWebGLRenderTarget && (T = T.texture), T.matrixAutoUpdate === !0 && T.updateMatrix(), v.uvTransform.value.copy(T.matrix));
    let E;
    g.aoMap ? E = g.aoMap : g.lightMap && (E = g.lightMap), E !== void 0 && (E.isWebGLRenderTarget && (E = E.texture), E.matrixAutoUpdate === !0 && E.updateMatrix(), v.uv2Transform.value.copy(E.matrix));
  }
  function s(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity;
  }
  function o(v, g) {
    v.dashSize.value = g.dashSize, v.totalSize.value = g.dashSize + g.gapSize, v.scale.value = g.scale;
  }
  function a(v, g, S, T) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.size.value = g.size * S, v.scale.value = T * 0.5, g.map && (v.map.value = g.map), g.alphaMap && (v.alphaMap.value = g.alphaMap);
    let E;
    g.map ? E = g.map : g.alphaMap && (E = g.alphaMap), E !== void 0 && (E.matrixAutoUpdate === !0 && E.updateMatrix(), v.uvTransform.value.copy(E.matrix));
  }
  function l(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.rotation.value = g.rotation, g.map && (v.map.value = g.map), g.alphaMap && (v.alphaMap.value = g.alphaMap);
    let S;
    g.map ? S = g.map : g.alphaMap && (S = g.alphaMap), S !== void 0 && (S.matrixAutoUpdate === !0 && S.updateMatrix(), v.uvTransform.value.copy(S.matrix));
  }
  function c(v, g) {
    g.emissiveMap && (v.emissiveMap.value = g.emissiveMap);
  }
  function h(v, g) {
    v.specular.value.copy(g.specular), v.shininess.value = Math.max(g.shininess, 1e-4), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap), g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ct && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ct && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  function d(v, g) {
    g.gradientMap && (v.gradientMap.value = g.gradientMap), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap), g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ct && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ct && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  function u(v, g) {
    v.roughness.value = g.roughness, v.metalness.value = g.metalness, g.roughnessMap && (v.roughnessMap.value = g.roughnessMap), g.metalnessMap && (v.metalnessMap.value = g.metalnessMap), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap), g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ct && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ct && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias), t.get(g).envMap && (v.envMapIntensity.value = g.envMapIntensity);
  }
  function p(v, g) {
    u(v, g), v.reflectivity.value = g.reflectivity, v.clearcoat.value = g.clearcoat, v.clearcoatRoughness.value = g.clearcoatRoughness, g.sheen && v.sheen.value.copy(g.sheen), g.clearcoatMap && (v.clearcoatMap.value = g.clearcoatMap), g.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap), g.clearcoatNormalMap && (v.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), v.clearcoatNormalMap.value = g.clearcoatNormalMap, g.side === Ct && v.clearcoatNormalScale.value.negate()), v.transmission.value = g.transmission, g.transmissionMap && (v.transmissionMap.value = g.transmissionMap);
  }
  function f(v, g) {
    g.matcap && (v.matcap.value = g.matcap), g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ct && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ct && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  function m(v, g) {
    g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  function y(v, g) {
    g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias), v.referencePosition.value.copy(g.referencePosition), v.nearDistance.value = g.nearDistance, v.farDistance.value = g.farDistance;
  }
  function x(v, g) {
    g.bumpMap && (v.bumpMap.value = g.bumpMap, v.bumpScale.value = g.bumpScale, g.side === Ct && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, v.normalScale.value.copy(g.normalScale), g.side === Ct && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias);
  }
  return {
    refreshFogUniforms: e,
    refreshMaterialUniforms: n
  };
}
function pR() {
  const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  return t.style.display = "block", t;
}
function hu(t) {
  t = t || {};
  const e = t.canvas !== void 0 ? t.canvas : pR(), n = t.context !== void 0 ? t.context : null, r = t.alpha !== void 0 ? t.alpha : !1, s = t.depth !== void 0 ? t.depth : !0, o = t.stencil !== void 0 ? t.stencil : !0, a = t.antialias !== void 0 ? t.antialias : !1, l = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0, c = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1, h = t.powerPreference !== void 0 ? t.powerPreference : "default", d = t.failIfMajorPerformanceCaveat !== void 0 ? t.failIfMajorPerformanceCaveat : !1;
  let u = null, p = null;
  const f = [];
  this.domElement = e, this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Bl, this.physicallyCorrectLights = !1, this.toneMapping = ka, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
  const m = this;
  let y = !1, x = null, v = 0, g = 0, S = null, T = null, E = -1, w = null;
  const C = new st(), ee = new st();
  let Y = null, le = e.width, B = e.height, Z = 1, k = null, O = null;
  const P = new st(0, 0, le, B), j = new st(0, 0, le, B);
  let re = !1;
  const ae = new cu();
  let ce = !1, pe = !1;
  const de = new Ye(), ge = new F(), we = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function Ge() {
    return S === null ? Z : 1;
  }
  let te = n;
  function I(M, q) {
    for (let G = 0; G < M.length; G++) {
      const K = M[G], ue = e.getContext(K, q);
      if (ue !== null) return ue;
    }
    return null;
  }
  try {
    const M = {
      alpha: r,
      depth: s,
      stencil: o,
      antialias: a,
      premultipliedAlpha: l,
      preserveDrawingBuffer: c,
      powerPreference: h,
      failIfMajorPerformanceCaveat: d
    };
    if (e.addEventListener("webglcontextlost", Pe, !1), e.addEventListener("webglcontextrestored", rt, !1), te === null) {
      const q = ["webgl2", "webgl", "experimental-webgl"];
      if (m.isWebGL1Renderer === !0 && q.shift(), te = I(q, M), te === null)
        throw I(q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    te.getShaderPrecisionFormat === void 0 && (te.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (M) {
    throw console.error("THREE.WebGLRenderer: " + M.message), M;
  }
  let L, U, N, V, W, R, D, H, ne, J, b, _, Q, X, A, ie, oe, he, se, me, ve;
  function be() {
    L = new $C(te), U = new VC(te, L, t), U.isWebGL2 === !1 && (L.get("WEBGL_depth_texture"), L.get("OES_texture_float"), L.get("OES_texture_half_float"), L.get("OES_texture_half_float_linear"), L.get("OES_standard_derivatives"), L.get("OES_element_index_uint"), L.get("OES_vertex_array_object"), L.get("ANGLE_instanced_arrays")), L.get("OES_texture_float_linear"), me = new dR(te, L, U), N = new hR(te, L, U), N.scissor(ee.copy(j).multiplyScalar(Z).floor()), N.viewport(C.copy(P).multiplyScalar(Z).floor()), V = new XC(), W = new K3(), R = new uR(te, L, N, W, U, me, V), D = new WC(m), H = new vL(te, U), ve = new HC(te, L, H, U), ne = new jC(te, H, V, ve), J = new KC(te, ne, H, V), oe = new JC(te), A = new kC(W), b = new J3(m, D, L, U, ve, A), _ = new fR(W), Q = new tR(W), X = new aR(L, U), ie = new UC(m, D, N, J, l), he = new GC(te, L, V, U), se = new qC(te, L, V, U), V.programs = b.programs, m.capabilities = U, m.extensions = L, m.properties = W, m.renderLists = Q, m.state = N, m.info = V;
  }
  be();
  const fe = new _x(m, te);
  this.xr = fe;
  const _e = new xx(m, J, U.maxTextureSize);
  this.shadowMap = _e, this.getContext = function() {
    return te;
  }, this.getContextAttributes = function() {
    return te.getContextAttributes();
  }, this.forceContextLoss = function() {
    const M = L.get("WEBGL_lose_context");
    M && M.loseContext();
  }, this.forceContextRestore = function() {
    const M = L.get("WEBGL_lose_context");
    M && M.restoreContext();
  }, this.getPixelRatio = function() {
    return Z;
  }, this.setPixelRatio = function(M) {
    M !== void 0 && (Z = M, this.setSize(le, B, !1));
  }, this.getSize = function(M) {
    return M === void 0 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), M = new xe()), M.set(le, B);
  }, this.setSize = function(M, q, G) {
    if (fe.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    le = M, B = q, e.width = Math.floor(M * Z), e.height = Math.floor(q * Z), G !== !1 && (e.style.width = M + "px", e.style.height = q + "px"), this.setViewport(0, 0, M, q);
  }, this.getDrawingBufferSize = function(M) {
    return M === void 0 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), M = new xe()), M.set(le * Z, B * Z).floor();
  }, this.setDrawingBufferSize = function(M, q, G) {
    le = M, B = q, Z = G, e.width = Math.floor(M * G), e.height = Math.floor(q * G), this.setViewport(0, 0, M, q);
  }, this.getCurrentViewport = function(M) {
    return M === void 0 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), M = new st()), M.copy(C);
  }, this.getViewport = function(M) {
    return M.copy(P);
  }, this.setViewport = function(M, q, G, K) {
    M.isVector4 ? P.set(M.x, M.y, M.z, M.w) : P.set(M, q, G, K), N.viewport(C.copy(P).multiplyScalar(Z).floor());
  }, this.getScissor = function(M) {
    return M.copy(j);
  }, this.setScissor = function(M, q, G, K) {
    M.isVector4 ? j.set(M.x, M.y, M.z, M.w) : j.set(M, q, G, K), N.scissor(ee.copy(j).multiplyScalar(Z).floor());
  }, this.getScissorTest = function() {
    return re;
  }, this.setScissorTest = function(M) {
    N.setScissorTest(re = M);
  }, this.setOpaqueSort = function(M) {
    k = M;
  }, this.setTransparentSort = function(M) {
    O = M;
  }, this.getClearColor = function(M) {
    return M === void 0 && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), M = new De()), M.copy(ie.getClearColor());
  }, this.setClearColor = function() {
    ie.setClearColor.apply(ie, arguments);
  }, this.getClearAlpha = function() {
    return ie.getClearAlpha();
  }, this.setClearAlpha = function() {
    ie.setClearAlpha.apply(ie, arguments);
  }, this.clear = function(M, q, G) {
    let K = 0;
    (M === void 0 || M) && (K |= 16384), (q === void 0 || q) && (K |= 256), (G === void 0 || G) && (K |= 1024), te.clear(K);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", Pe, !1), e.removeEventListener("webglcontextrestored", rt, !1), Q.dispose(), X.dispose(), W.dispose(), D.dispose(), J.dispose(), ve.dispose(), fe.dispose(), Wt.stop();
  };
  function Pe(M) {
    M.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0;
  }
  function rt() {
    console.log("THREE.WebGLRenderer: Context Restored."), y = !1, be();
  }
  function dn(M) {
    const q = M.target;
    q.removeEventListener("dispose", dn), es(q);
  }
  function es(M) {
    Fi(M), W.remove(M);
  }
  function Fi(M) {
    const q = W.get(M).program;
    q !== void 0 && b.releaseProgram(q);
  }
  function cr(M, q) {
    M.render(function(G) {
      m.renderBufferImmediate(G, q);
    });
  }
  this.renderBufferImmediate = function(M, q) {
    ve.initAttributes();
    const G = W.get(M);
    M.hasPositions && !G.position && (G.position = te.createBuffer()), M.hasNormals && !G.normal && (G.normal = te.createBuffer()), M.hasUvs && !G.uv && (G.uv = te.createBuffer()), M.hasColors && !G.color && (G.color = te.createBuffer());
    const K = q.getAttributes();
    M.hasPositions && (te.bindBuffer(34962, G.position), te.bufferData(34962, M.positionArray, 35048), ve.enableAttribute(K.position), te.vertexAttribPointer(K.position, 3, 5126, !1, 0, 0)), M.hasNormals && (te.bindBuffer(34962, G.normal), te.bufferData(34962, M.normalArray, 35048), ve.enableAttribute(K.normal), te.vertexAttribPointer(K.normal, 3, 5126, !1, 0, 0)), M.hasUvs && (te.bindBuffer(34962, G.uv), te.bufferData(34962, M.uvArray, 35048), ve.enableAttribute(K.uv), te.vertexAttribPointer(K.uv, 2, 5126, !1, 0, 0)), M.hasColors && (te.bindBuffer(34962, G.color), te.bufferData(34962, M.colorArray, 35048), ve.enableAttribute(K.color), te.vertexAttribPointer(K.color, 3, 5126, !1, 0, 0)), ve.disableUnusedAttributes(), te.drawArrays(4, 0, M.count), M.count = 0;
  }, this.renderBufferDirect = function(M, q, G, K, ue, Le) {
    q === null && (q = we);
    const Se = ue.isMesh && ue.matrixWorld.determinant() < 0, Re = zi(M, q, K, ue);
    N.setMaterial(K, Se);
    let Ee = G.index;
    const Ze = G.attributes.position;
    if (Ee === null) {
      if (Ze === void 0 || Ze.count === 0) return;
    } else if (Ee.count === 0)
      return;
    let je = 1;
    K.wireframe === !0 && (Ee = ne.getWireframeAttribute(G), je = 2), (K.morphTargets || K.morphNormals) && oe.update(ue, G, K, Re), ve.setup(ue, K, Re, G, Ee);
    let Me, Be = he;
    Ee !== null && (Me = H.get(Ee), Be = se, Be.setIndex(Me));
    const Lt = Ee !== null ? Ee.count : Ze.count, ze = G.drawRange.start * je, tn = G.drawRange.count * je, et = Le !== null ? Le.start * je : 0, ns = Le !== null ? Le.count * je : 1 / 0, lt = Math.max(ze, et), Wn = Math.min(Lt, ze + tn, et + ns) - 1, fn = Math.max(0, Wn - lt + 1);
    if (fn !== 0) {
      if (ue.isMesh)
        K.wireframe === !0 ? (N.setLineWidth(K.wireframeLinewidth * Ge()), Be.setMode(1)) : Be.setMode(4);
      else if (ue.isLine) {
        let $n = K.linewidth;
        $n === void 0 && ($n = 1), N.setLineWidth($n * Ge()), ue.isLineSegments ? Be.setMode(1) : ue.isLineLoop ? Be.setMode(2) : Be.setMode(3);
      } else ue.isPoints ? Be.setMode(0) : ue.isSprite && Be.setMode(4);
      if (ue.isInstancedMesh)
        Be.renderInstances(lt, fn, ue.count);
      else if (G.isInstancedBufferGeometry) {
        const $n = Math.min(G.instanceCount, G._maxInstanceCount);
        Be.renderInstances(lt, fn, $n);
      } else
        Be.render(lt, fn);
    }
  }, this.compile = function(M, q) {
    p = X.get(M), p.init(), M.traverseVisible(function(K) {
      K.isLight && K.layers.test(q.layers) && (p.pushLight(K), K.castShadow && p.pushShadow(K));
    }), p.setupLights();
    const G = /* @__PURE__ */ new WeakMap();
    M.traverse(function(K) {
      const ue = K.material;
      if (ue)
        if (Array.isArray(ue))
          for (let Le = 0; Le < ue.length; Le++) {
            const Se = ue[Le];
            G.has(Se) === !1 && (ct(Se, M, K), G.set(Se));
          }
        else G.has(ue) === !1 && (ct(ue, M, K), G.set(ue));
    });
  };
  let Bi = null;
  function ra(M) {
    fe.isPresenting || Bi && Bi(M);
  }
  const Wt = new hx();
  Wt.setAnimationLoop(ra), typeof window < "u" && Wt.setContext(window), this.setAnimationLoop = function(M) {
    Bi = M, fe.setAnimationLoop(M), M === null ? Wt.stop() : Wt.start();
  }, this.render = function(M, q) {
    let G, K;
    if (arguments[2] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), G = arguments[2]), arguments[3] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), K = arguments[3]), q !== void 0 && q.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (y === !0) return;
    ve.resetDefaultState(), E = -1, w = null, M.autoUpdate === !0 && M.updateMatrixWorld(), q.parent === null && q.updateMatrixWorld(), fe.enabled === !0 && fe.isPresenting === !0 && (q = fe.getCamera(q)), M.isScene === !0 && M.onBeforeRender(m, M, q, G || S), p = X.get(M, f.length), p.init(), f.push(p), de.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse), ae.setFromProjectionMatrix(de), pe = this.localClippingEnabled, ce = A.init(this.clippingPlanes, pe, q), u = Q.get(M, q), u.init(), en(M, q, 0, m.sortObjects), u.finish(), m.sortObjects === !0 && u.sort(k, O), ce === !0 && A.beginShadows();
    const ue = p.state.shadowsArray;
    _e.render(ue, M, q), p.setupLights(), p.setupLightsView(q), ce === !0 && A.endShadows(), this.info.autoReset === !0 && this.info.reset(), G !== void 0 && this.setRenderTarget(G), ie.render(u, M, q, K);
    const Le = u.opaque, Se = u.transparent;
    Le.length > 0 && kn(Le, M, q), Se.length > 0 && kn(Se, M, q), M.isScene === !0 && M.onAfterRender(m, M, q), S !== null && (R.updateRenderTargetMipmap(S), R.updateMultisampleRenderTarget(S)), N.buffers.depth.setTest(!0), N.buffers.depth.setMask(!0), N.buffers.color.setMask(!0), N.setPolygonOffset(!1), f.pop(), f.length > 0 ? p = f[f.length - 1] : p = null, u = null;
  };
  function en(M, q, G, K) {
    if (M.visible === !1) return;
    if (M.layers.test(q.layers)) {
      if (M.isGroup)
        G = M.renderOrder;
      else if (M.isLOD)
        M.autoUpdate === !0 && M.update(q);
      else if (M.isLight)
        p.pushLight(M), M.castShadow && p.pushShadow(M);
      else if (M.isSprite) {
        if (!M.frustumCulled || ae.intersectsSprite(M)) {
          K && ge.setFromMatrixPosition(M.matrixWorld).applyMatrix4(de);
          const Se = J.update(M), Re = M.material;
          Re.visible && u.push(M, Se, Re, G, ge.z, null);
        }
      } else if (M.isImmediateRenderObject)
        K && ge.setFromMatrixPosition(M.matrixWorld).applyMatrix4(de), u.push(M, null, M.material, G, ge.z, null);
      else if ((M.isMesh || M.isLine || M.isPoints) && (M.isSkinnedMesh && M.skeleton.frame !== V.render.frame && (M.skeleton.update(), M.skeleton.frame = V.render.frame), !M.frustumCulled || ae.intersectsObject(M))) {
        K && ge.setFromMatrixPosition(M.matrixWorld).applyMatrix4(de);
        const Se = J.update(M), Re = M.material;
        if (Array.isArray(Re)) {
          const Ee = Se.groups;
          for (let Ze = 0, je = Ee.length; Ze < je; Ze++) {
            const Me = Ee[Ze], Be = Re[Me.materialIndex];
            Be && Be.visible && u.push(M, Se, Be, G, ge.z, Me);
          }
        } else Re.visible && u.push(M, Se, Re, G, ge.z, null);
      }
    }
    const Le = M.children;
    for (let Se = 0, Re = Le.length; Se < Re; Se++)
      en(Le[Se], q, G, K);
  }
  function kn(M, q, G) {
    const K = q.isScene === !0 ? q.overrideMaterial : null;
    for (let ue = 0, Le = M.length; ue < Le; ue++) {
      const Se = M[ue], Re = Se.object, Ee = Se.geometry, Ze = K === null ? Se.material : K, je = Se.group;
      if (G.isArrayCamera) {
        const Me = G.cameras;
        for (let Be = 0, Lt = Me.length; Be < Lt; Be++) {
          const ze = Me[Be];
          Re.layers.test(ze.layers) && (N.viewport(C.copy(ze.viewport)), p.setupLightsView(ze), hr(Re, q, ze, Ee, Ze, je));
        }
      } else
        hr(Re, q, G, Ee, Ze, je);
    }
  }
  function hr(M, q, G, K, ue, Le) {
    if (M.onBeforeRender(m, q, G, K, ue, Le), M.modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, M.matrixWorld), M.normalMatrix.getNormalMatrix(M.modelViewMatrix), M.isImmediateRenderObject) {
      const Se = zi(G, q, ue, M);
      N.setMaterial(ue), ve.reset(), cr(M, Se);
    } else
      m.renderBufferDirect(G, q, K, ue, M, Le);
    M.onAfterRender(m, q, G, K, ue, Le);
  }
  function ct(M, q, G) {
    q.isScene !== !0 && (q = we);
    const K = W.get(M), ue = p.state.lights, Le = p.state.shadowsArray, Se = ue.state.version, Re = b.getParameters(M, ue.state, Le, q, G), Ee = b.getProgramCacheKey(Re);
    let Ze = K.program, je = !0;
    if (Ze === void 0)
      M.addEventListener("dispose", dn);
    else if (Ze.cacheKey !== Ee)
      Fi(M);
    else if (K.lightsStateVersion !== Se)
      je = !1;
    else if (Re.shaderID !== void 0) {
      const ze = M.isMeshStandardMaterial ? q.environment : null;
      K.envMap = D.get(M.envMap || ze);
      return;
    } else
      je = !1;
    je && (Re.uniforms = b.getUniforms(M), M.onBeforeCompile(Re, m), Ze = b.acquireProgram(Re, Ee), K.program = Ze, K.uniforms = Re.uniforms, K.outputEncoding = Re.outputEncoding);
    const Me = K.uniforms;
    (!M.isShaderMaterial && !M.isRawShaderMaterial || M.clipping === !0) && (K.numClippingPlanes = A.numPlanes, K.numIntersection = A.numIntersection, Me.clippingPlanes = A.uniform), K.environment = M.isMeshStandardMaterial ? q.environment : null, K.fog = q.fog, K.envMap = D.get(M.envMap || K.environment), K.needsLights = sa(M), K.lightsStateVersion = Se, K.needsLights && (Me.ambientLightColor.value = ue.state.ambient, Me.lightProbe.value = ue.state.probe, Me.directionalLights.value = ue.state.directional, Me.directionalLightShadows.value = ue.state.directionalShadow, Me.spotLights.value = ue.state.spot, Me.spotLightShadows.value = ue.state.spotShadow, Me.rectAreaLights.value = ue.state.rectArea, Me.ltc_1.value = ue.state.rectAreaLTC1, Me.ltc_2.value = ue.state.rectAreaLTC2, Me.pointLights.value = ue.state.point, Me.pointLightShadows.value = ue.state.pointShadow, Me.hemisphereLights.value = ue.state.hemi, Me.directionalShadowMap.value = ue.state.directionalShadowMap, Me.directionalShadowMatrix.value = ue.state.directionalShadowMatrix, Me.spotShadowMap.value = ue.state.spotShadowMap, Me.spotShadowMatrix.value = ue.state.spotShadowMatrix, Me.pointShadowMap.value = ue.state.pointShadowMap, Me.pointShadowMatrix.value = ue.state.pointShadowMatrix);
    const Be = K.program.getUniforms(), Lt = zr.seqWithValue(Be.seq, Me);
    K.uniformsList = Lt;
  }
  function zi(M, q, G, K) {
    q.isScene !== !0 && (q = we), R.resetTextureUnits();
    const ue = q.fog, Le = G.isMeshStandardMaterial ? q.environment : null, Se = S === null ? m.outputEncoding : S.texture.encoding, Re = D.get(G.envMap || Le), Ee = W.get(G), Ze = p.state.lights;
    if (ce === !0 && (pe === !0 || M !== w)) {
      const et = M === w && G.id === E;
      A.setState(G, M, et);
    }
    G.version === Ee.__version ? (G.fog && Ee.fog !== ue || Ee.environment !== Le || Ee.needsLights && Ee.lightsStateVersion !== Ze.state.version || Ee.numClippingPlanes !== void 0 && (Ee.numClippingPlanes !== A.numPlanes || Ee.numIntersection !== A.numIntersection) || Ee.outputEncoding !== Se || Ee.envMap !== Re) && ct(G, q, K) : (ct(G, q, K), Ee.__version = G.version);
    let je = !1, Me = !1, Be = !1;
    const Lt = Ee.program, ze = Lt.getUniforms(), tn = Ee.uniforms;
    if (N.useProgram(Lt.program) && (je = !0, Me = !0, Be = !0), G.id !== E && (E = G.id, Me = !0), je || w !== M) {
      if (ze.setValue(te, "projectionMatrix", M.projectionMatrix), U.logarithmicDepthBuffer && ze.setValue(
        te,
        "logDepthBufFC",
        2 / (Math.log(M.far + 1) / Math.LN2)
      ), w !== M && (w = M, Me = !0, Be = !0), G.isShaderMaterial || G.isMeshPhongMaterial || G.isMeshToonMaterial || G.isMeshStandardMaterial || G.envMap) {
        const et = ze.map.cameraPosition;
        et !== void 0 && et.setValue(
          te,
          ge.setFromMatrixPosition(M.matrixWorld)
        );
      }
      (G.isMeshPhongMaterial || G.isMeshToonMaterial || G.isMeshLambertMaterial || G.isMeshBasicMaterial || G.isMeshStandardMaterial || G.isShaderMaterial) && ze.setValue(te, "isOrthographic", M.isOrthographicCamera === !0), (G.isMeshPhongMaterial || G.isMeshToonMaterial || G.isMeshLambertMaterial || G.isMeshBasicMaterial || G.isMeshStandardMaterial || G.isShaderMaterial || G.isShadowMaterial || G.skinning) && ze.setValue(te, "viewMatrix", M.matrixWorldInverse);
    }
    if (G.skinning) {
      ze.setOptional(te, K, "bindMatrix"), ze.setOptional(te, K, "bindMatrixInverse");
      const et = K.skeleton;
      if (et) {
        const ns = et.bones;
        if (U.floatVertexTextures) {
          if (et.boneTexture === null) {
            let lt = Math.sqrt(ns.length * 4);
            lt = Xe.ceilPowerOfTwo(lt), lt = Math.max(lt, 4);
            const Wn = new Float32Array(lt * lt * 4);
            Wn.set(et.boneMatrices);
            const fn = new Yr(Wn, lt, lt, Nn, Rr);
            et.boneMatrices = Wn, et.boneTexture = fn, et.boneTextureSize = lt;
          }
          ze.setValue(te, "boneTexture", et.boneTexture, R), ze.setValue(te, "boneTextureSize", et.boneTextureSize);
        } else
          ze.setOptional(te, et, "boneMatrices");
      }
    }
    return (Me || Ee.receiveShadow !== K.receiveShadow) && (Ee.receiveShadow = K.receiveShadow, ze.setValue(te, "receiveShadow", K.receiveShadow)), Me && (ze.setValue(te, "toneMappingExposure", m.toneMappingExposure), Ee.needsLights && ts(tn, Be), ue && G.fog && _.refreshFogUniforms(tn, ue), _.refreshMaterialUniforms(tn, G, Z, B), zr.upload(te, Ee.uniformsList, tn, R)), G.isShaderMaterial && G.uniformsNeedUpdate === !0 && (zr.upload(te, Ee.uniformsList, tn, R), G.uniformsNeedUpdate = !1), G.isSpriteMaterial && ze.setValue(te, "center", K.center), ze.setValue(te, "modelViewMatrix", K.modelViewMatrix), ze.setValue(te, "normalMatrix", K.normalMatrix), ze.setValue(te, "modelMatrix", K.matrixWorld), Lt;
  }
  function ts(M, q) {
    M.ambientLightColor.needsUpdate = q, M.lightProbe.needsUpdate = q, M.directionalLights.needsUpdate = q, M.directionalLightShadows.needsUpdate = q, M.pointLights.needsUpdate = q, M.pointLightShadows.needsUpdate = q, M.spotLights.needsUpdate = q, M.spotLightShadows.needsUpdate = q, M.rectAreaLights.needsUpdate = q, M.hemisphereLights.needsUpdate = q;
  }
  function sa(M) {
    return M.isMeshLambertMaterial || M.isMeshToonMaterial || M.isMeshPhongMaterial || M.isMeshStandardMaterial || M.isShadowMaterial || M.isShaderMaterial && M.lights === !0;
  }
  this.setFramebuffer = function(M) {
    x !== M && S === null && te.bindFramebuffer(36160, M), x = M;
  }, this.getActiveCubeFace = function() {
    return v;
  }, this.getActiveMipmapLevel = function() {
    return g;
  }, this.getRenderList = function() {
    return u;
  }, this.setRenderList = function(M) {
    u = M;
  }, this.getRenderTarget = function() {
    return S;
  }, this.setRenderTarget = function(M, q = 0, G = 0) {
    S = M, v = q, g = G, M && W.get(M).__webglFramebuffer === void 0 && R.setupRenderTarget(M);
    let K = x, ue = !1;
    if (M) {
      const Le = W.get(M).__webglFramebuffer;
      M.isWebGLCubeRenderTarget ? (K = Le[q], ue = !0) : M.isWebGLMultisampleRenderTarget ? K = W.get(M).__webglMultisampledFramebuffer : K = Le, C.copy(M.viewport), ee.copy(M.scissor), Y = M.scissorTest;
    } else
      C.copy(P).multiplyScalar(Z).floor(), ee.copy(j).multiplyScalar(Z).floor(), Y = re;
    if (T !== K && (te.bindFramebuffer(36160, K), T = K), N.viewport(C), N.scissor(ee), N.setScissorTest(Y), ue) {
      const Le = W.get(M.texture);
      te.framebufferTexture2D(36160, 36064, 34069 + q, Le.__webglTexture, G);
    }
  }, this.readRenderTargetPixels = function(M, q, G, K, ue, Le, Se) {
    if (!(M && M.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let Re = W.get(M).__webglFramebuffer;
    if (M.isWebGLCubeRenderTarget && Se !== void 0 && (Re = Re[Se]), Re) {
      let Ee = !1;
      Re !== T && (te.bindFramebuffer(36160, Re), Ee = !0);
      try {
        const Ze = M.texture, je = Ze.format, Me = Ze.type;
        if (je !== Nn && me.convert(je) !== te.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (Me !== cp && me.convert(Me) !== te.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(Me === Rr && (U.isWebGL2 || L.get("OES_texture_float") || L.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !(Me === Ih && (U.isWebGL2 ? L.get("EXT_color_buffer_float") : L.get("EXT_color_buffer_half_float")))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        te.checkFramebufferStatus(36160) === 36053 ? q >= 0 && q <= M.width - K && G >= 0 && G <= M.height - ue && te.readPixels(q, G, K, ue, me.convert(je), me.convert(Me), Le) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        Ee && te.bindFramebuffer(36160, T);
      }
    }
  }, this.copyFramebufferToTexture = function(M, q, G = 0) {
    const K = Math.pow(2, -G), ue = Math.floor(q.image.width * K), Le = Math.floor(q.image.height * K), Se = me.convert(q.format);
    R.setTexture2D(q, 0), te.copyTexImage2D(3553, G, Se, M.x, M.y, ue, Le, 0), N.unbindTexture();
  }, this.copyTextureToTexture = function(M, q, G, K = 0) {
    const ue = q.image.width, Le = q.image.height, Se = me.convert(G.format), Re = me.convert(G.type);
    R.setTexture2D(G, 0), te.pixelStorei(37440, G.flipY), te.pixelStorei(37441, G.premultiplyAlpha), te.pixelStorei(3317, G.unpackAlignment), q.isDataTexture ? te.texSubImage2D(3553, K, M.x, M.y, ue, Le, Se, Re, q.image.data) : q.isCompressedTexture ? te.compressedTexSubImage2D(3553, K, M.x, M.y, q.mipmaps[0].width, q.mipmaps[0].height, Se, q.mipmaps[0].data) : te.texSubImage2D(3553, K, M.x, M.y, Se, Re, q.image), K === 0 && G.generateMipmaps && te.generateMipmap(3553), N.unbindTexture();
  }, this.initTexture = function(M) {
    R.setTexture2D(M, 0), N.unbindTexture();
  }, this.resetState = function() {
    N.reset(), ve.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
function fv(t) {
  hu.call(this, t);
}
fv.prototype = Object.assign(Object.create(hu.prototype), {
  constructor: fv,
  isWebGL1Renderer: !0
});
class uu extends Ie {
  constructor() {
    super(), Object.defineProperty(this, "isScene", { value: !0 }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.background !== null && (n.object.background = this.background.toJSON(e)), this.environment !== null && (n.object.environment = this.environment.toJSON(e)), this.fog !== null && (n.object.fog = this.fog.toJSON()), n;
  }
}
function In(t, e) {
  this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = lu, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Xe.generateUUID();
}
Object.defineProperty(In.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
Object.assign(In.prototype, {
  isInterleavedBuffer: !0,
  onUploadCallback: function() {
  },
  setUsage: function(t) {
    return this.usage = t, this;
  },
  copy: function(t) {
    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
  },
  copyAt: function(t, e, n) {
    t *= this.stride, n *= e.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[t + r] = e.array[n + r];
    return this;
  },
  set: function(t, e = 0) {
    return this.array.set(t, e), this;
  },
  clone: function(t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Xe.generateUUID()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new In(e, this.stride);
    return n.setUsage(this.usage), n;
  },
  onUpload: function(t) {
    return this.onUploadCallback = t, this;
  },
  toJSON: function(t) {
    return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Xe.generateUUID()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
const hs = new F();
function _n(t, e, n, r) {
  this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = r === !0;
}
Object.defineProperties(_n.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(t) {
      this.data.needsUpdate = t;
    }
  }
});
Object.assign(_n.prototype, {
  isInterleavedBufferAttribute: !0,
  applyMatrix4: function(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      hs.x = this.getX(e), hs.y = this.getY(e), hs.z = this.getZ(e), hs.applyMatrix4(t), this.setXYZ(e, hs.x, hs.y, hs.z);
    return this;
  },
  setX: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset] = e, this;
  },
  setY: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
  },
  setZ: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
  },
  setW: function(t, e) {
    return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
  },
  getX: function(t) {
    return this.data.array[t * this.data.stride + this.offset];
  },
  getY: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 1];
  },
  getZ: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 2];
  },
  getW: function(t) {
    return this.data.array[t * this.data.stride + this.offset + 3];
  },
  setXY: function(t, e, n) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
  },
  setXYZ: function(t, e, n, r) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this;
  },
  setXYZW: function(t, e, n, r, s) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = s, this;
  },
  clone: function(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          e.push(this.data.array[r + s]);
      }
      return new qe(new this.array.constructor(e), this.itemSize, this.normalized);
    } else
      return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new _n(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  },
  toJSON: function(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          e.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized
      };
    } else
      return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
});
function Zr(t) {
  ke.call(this), this.type = "SpriteMaterial", this.color = new De(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t);
}
Zr.prototype = Object.create(ke.prototype);
Zr.prototype.constructor = Zr;
Zr.prototype.isSpriteMaterial = !0;
Zr.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
};
let no;
const Ma = new F(), io = new F(), ro = new F(), so = new xe(), Sa = new xe(), bx = new Ye(), Gc = new F(), Ea = new F(), Vc = new F(), pv = new xe(), gd = new xe(), mv = new xe();
function _f(t) {
  if (Ie.call(this), this.type = "Sprite", no === void 0) {
    no = new ot();
    const e = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0,
      0.5,
      -0.5,
      0,
      1,
      0,
      0.5,
      0.5,
      0,
      1,
      1,
      -0.5,
      0.5,
      0,
      0,
      1
    ]), n = new In(e, 5);
    no.setIndex([0, 1, 2, 0, 2, 3]), no.setAttribute("position", new _n(n, 3, 0, !1)), no.setAttribute("uv", new _n(n, 2, 3, !1));
  }
  this.geometry = no, this.material = t !== void 0 ? t : new Zr(), this.center = new xe(0.5, 0.5);
}
_f.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: _f,
  isSprite: !0,
  raycast: function(t, e) {
    t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), io.setFromMatrixScale(this.matrixWorld), bx.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ro.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && io.multiplyScalar(-ro.z);
    const n = this.material.rotation;
    let r, s;
    n !== 0 && (s = Math.cos(n), r = Math.sin(n));
    const o = this.center;
    kc(Gc.set(-0.5, -0.5, 0), ro, o, io, r, s), kc(Ea.set(0.5, -0.5, 0), ro, o, io, r, s), kc(Vc.set(0.5, 0.5, 0), ro, o, io, r, s), pv.set(0, 0), gd.set(1, 0), mv.set(1, 1);
    let a = t.ray.intersectTriangle(Gc, Ea, Vc, !1, Ma);
    if (a === null && (kc(Ea.set(-0.5, 0.5, 0), ro, o, io, r, s), gd.set(0, 1), a = t.ray.intersectTriangle(Gc, Vc, Ea, !1, Ma), a === null))
      return;
    const l = t.ray.origin.distanceTo(Ma);
    l < t.near || l > t.far || e.push({
      distance: l,
      point: Ma.clone(),
      uv: Yt.getUV(Ma, Gc, Ea, Vc, pv, gd, mv, new xe()),
      face: null,
      object: this
    });
  },
  copy: function(t) {
    return Ie.prototype.copy.call(this, t), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this;
  }
});
function kc(t, e, n, r, s, o) {
  so.subVectors(t, n).addScalar(0.5).multiply(r), s !== void 0 ? (Sa.x = o * so.x - s * so.y, Sa.y = s * so.x + o * so.y) : Sa.copy(so), t.copy(e), t.x += Sa.x, t.y += Sa.y, t.applyMatrix4(bx);
}
const Wc = new F(), gv = new F();
function bf() {
  Ie.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
    levels: {
      enumerable: !0,
      value: []
    }
  }), this.autoUpdate = !0;
}
bf.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: bf,
  isLOD: !0,
  copy: function(t) {
    Ie.prototype.copy.call(this, t, !1);
    const e = t.levels;
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      this.addLevel(s.object.clone(), s.distance);
    }
    return this.autoUpdate = t.autoUpdate, this;
  },
  addLevel: function(t, e = 0) {
    e = Math.abs(e);
    const n = this.levels;
    let r;
    for (r = 0; r < n.length && !(e < n[r].distance); r++)
      ;
    return n.splice(r, 0, { distance: e, object: t }), this.add(t), this;
  },
  getCurrentLevel: function() {
    return this._currentLevel;
  },
  getObjectForDistance: function(t) {
    const e = this.levels;
    if (e.length > 0) {
      let n, r;
      for (n = 1, r = e.length; n < r && !(t < e[n].distance); n++)
        ;
      return e[n - 1].object;
    }
    return null;
  },
  raycast: function(t, e) {
    if (this.levels.length > 0) {
      Wc.setFromMatrixPosition(this.matrixWorld);
      const r = t.ray.origin.distanceTo(Wc);
      this.getObjectForDistance(r).raycast(t, e);
    }
  },
  update: function(t) {
    const e = this.levels;
    if (e.length > 1) {
      Wc.setFromMatrixPosition(t.matrixWorld), gv.setFromMatrixPosition(this.matrixWorld);
      const n = Wc.distanceTo(gv) / t.zoom;
      e[0].object.visible = !0;
      let r, s;
      for (r = 1, s = e.length; r < s && n >= e[r].distance; r++)
        e[r - 1].object.visible = !1, e[r].object.visible = !0;
      for (this._currentLevel = r - 1; r < s; r++)
        e[r].object.visible = !1;
    }
  },
  toJSON: function(t) {
    const e = Ie.prototype.toJSON.call(this, t);
    this.autoUpdate === !1 && (e.object.autoUpdate = !1), e.object.levels = [];
    const n = this.levels;
    for (let r = 0, s = n.length; r < s; r++) {
      const o = n[r];
      e.object.levels.push({
        object: o.object.uuid,
        distance: o.distance
      });
    }
    return e;
  }
});
const vv = new F(), yv = new st(), xv = new st(), mR = new F(), _v = new Ye();
function wf(t, e) {
  t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), at.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ye(), this.bindMatrixInverse = new Ye();
}
wf.prototype = Object.assign(Object.create(at.prototype), {
  constructor: wf,
  isSkinnedMesh: !0,
  copy: function(t) {
    return at.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
  },
  bind: function(t, e) {
    this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const t = new st(), e = this.geometry.attributes.skinWeight;
    for (let n = 0, r = e.count; n < r; n++) {
      t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
      const s = 1 / t.manhattanLength();
      s !== 1 / 0 ? t.multiplyScalar(s) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
    }
  },
  updateMatrixWorld: function(t) {
    at.prototype.updateMatrixWorld.call(this, t), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  },
  boneTransform: function(t, e) {
    const n = this.skeleton, r = this.geometry;
    yv.fromBufferAttribute(r.attributes.skinIndex, t), xv.fromBufferAttribute(r.attributes.skinWeight, t), vv.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = xv.getComponent(s);
      if (o !== 0) {
        const a = yv.getComponent(s);
        _v.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), e.addScaledVector(mR.copy(vv).applyMatrix4(_v), o);
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse);
  }
});
function Mf() {
  Ie.call(this), this.type = "Bone";
}
Mf.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: Mf,
  isBone: !0
});
const bv = new Ye(), gR = new Ye();
function Sf(t = [], e = []) {
  this.uuid = Xe.generateUUID(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
}
Object.assign(Sf.prototype, {
  init: function() {
    const t = this.bones, e = this.boneInverses;
    if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0)
      this.calculateInverses();
    else if (t.length !== e.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new Ye());
    }
  },
  calculateInverses: function() {
    this.boneInverses.length = 0;
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = new Ye();
      this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n);
    }
  },
  pose: function() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && n.matrixWorld.copy(this.boneInverses[t]).invert();
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  },
  update: function() {
    const t = this.bones, e = this.boneInverses, n = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s] ? t[s].matrixWorld : gR;
      bv.multiplyMatrices(a, e[s]), bv.toArray(n, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  },
  clone: function() {
    return new Sf(this.bones, this.boneInverses);
  },
  getBoneByName: function(t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      if (r.name === t)
        return r;
    }
  },
  dispose: function() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  },
  fromJSON: function(t, e) {
    this.uuid = t.uuid;
    for (let n = 0, r = t.bones.length; n < r; n++) {
      const s = t.bones[n];
      let o = e[s];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Mf()), this.bones.push(o), this.boneInverses.push(new Ye().fromArray(t.boneInverses[n]));
    }
    return this.init(), this;
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    t.uuid = this.uuid;
    const e = this.bones, n = this.boneInverses;
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      t.bones.push(o.uuid);
      const a = n[r];
      t.boneInverses.push(a.toArray());
    }
    return t;
  }
});
const wv = new Ye(), Mv = new Ye(), $c = [], Ta = new at();
function Sv(t, e, n) {
  at.call(this, t, e), this.instanceMatrix = new qe(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1;
}
Sv.prototype = Object.assign(Object.create(at.prototype), {
  constructor: Sv,
  isInstancedMesh: !0,
  copy: function(t) {
    return at.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this;
  },
  getColorAt: function(t, e) {
    e.fromArray(this.instanceColor.array, t * 3);
  },
  getMatrixAt: function(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  },
  raycast: function(t, e) {
    const n = this.matrixWorld, r = this.count;
    if (Ta.geometry = this.geometry, Ta.material = this.material, Ta.material !== void 0)
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, wv), Mv.multiplyMatrices(n, wv), Ta.matrixWorld = Mv, Ta.raycast(t, $c);
        for (let o = 0, a = $c.length; o < a; o++) {
          const l = $c[o];
          l.instanceId = s, l.object = this, e.push(l);
        }
        $c.length = 0;
      }
  },
  setColorAt: function(t, e) {
    this.instanceColor === null && (this.instanceColor = new qe(new Float32Array(this.count * 3), 3)), e.toArray(this.instanceColor.array, t * 3);
  },
  setMatrixAt: function(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  },
  updateMorphTargets: function() {
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function Vt(t) {
  ke.call(this), this.type = "LineBasicMaterial", this.color = new De(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t);
}
Vt.prototype = Object.create(ke.prototype);
Vt.prototype.constructor = Vt;
Vt.prototype.isLineBasicMaterial = !0;
Vt.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this;
};
const Ev = new F(), Tv = new F(), Av = new Ye(), jc = new ta(), qc = new Oi();
function Ci(t = new ot(), e = new Vt()) {
  Ie.call(this), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
}
Ci.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: Ci,
  isLine: !0,
  copy: function(t) {
    return Ie.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
  },
  computeLineDistances: function() {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position, n = [0];
        for (let r = 1, s = e.count; r < s; r++)
          Ev.fromBufferAttribute(e, r - 1), Tv.fromBufferAttribute(e, r), n[r] = n[r - 1], n[r] += Ev.distanceTo(Tv);
        t.setAttribute("lineDistance", new Qe(n, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (t.isGeometry) {
      const e = t.vertices, n = t.lineDistances;
      n[0] = 0;
      for (let r = 1, s = e.length; r < s; r++)
        n[r] = n[r - 1], n[r] += e[r - 1].distanceTo(e[r]);
    }
    return this;
  },
  raycast: function(t, e) {
    const n = this.geometry, r = this.matrixWorld, s = t.params.Line.threshold;
    if (n.boundingSphere === null && n.computeBoundingSphere(), qc.copy(n.boundingSphere), qc.applyMatrix4(r), qc.radius += s, t.ray.intersectsSphere(qc) === !1) return;
    Av.copy(r).invert(), jc.copy(t.ray).applyMatrix4(Av);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o, l = new F(), c = new F(), h = new F(), d = new F(), u = this.isLineSegments ? 2 : 1;
    if (n.isBufferGeometry) {
      const p = n.index, m = n.attributes.position;
      if (p !== null) {
        const y = p.array;
        for (let x = 0, v = y.length - 1; x < v; x += u) {
          const g = y[x], S = y[x + 1];
          if (l.fromBufferAttribute(m, g), c.fromBufferAttribute(m, S), jc.distanceSqToSegment(l, c, d, h) > a) continue;
          d.applyMatrix4(this.matrixWorld);
          const E = t.ray.origin.distanceTo(d);
          E < t.near || E > t.far || e.push({
            distance: E,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: x,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else
        for (let y = 0, x = m.count - 1; y < x; y += u) {
          if (l.fromBufferAttribute(m, y), c.fromBufferAttribute(m, y + 1), jc.distanceSqToSegment(l, c, d, h) > a) continue;
          d.applyMatrix4(this.matrixWorld);
          const g = t.ray.origin.distanceTo(d);
          g < t.near || g > t.far || e.push({
            distance: g,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this
          });
        }
    } else if (n.isGeometry) {
      const p = n.vertices, f = p.length;
      for (let m = 0; m < f - 1; m += u) {
        if (jc.distanceSqToSegment(p[m], p[m + 1], d, h) > a) continue;
        d.applyMatrix4(this.matrixWorld);
        const x = t.ray.origin.distanceTo(d);
        x < t.near || x > t.far || e.push({
          distance: x,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: h.clone().applyMatrix4(this.matrixWorld),
          index: m,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const r = e[n[0]];
        if (r !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
const Xc = new F(), Yc = new F();
function bl(t, e) {
  Ci.call(this, t, e), this.type = "LineSegments";
}
bl.prototype = Object.assign(Object.create(Ci.prototype), {
  constructor: bl,
  isLineSegments: !0,
  computeLineDistances: function() {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position, n = [];
        for (let r = 0, s = e.count; r < s; r += 2)
          Xc.fromBufferAttribute(e, r), Yc.fromBufferAttribute(e, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + Xc.distanceTo(Yc);
        t.setAttribute("lineDistance", new Qe(n, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (t.isGeometry) {
      const e = t.vertices, n = t.lineDistances;
      for (let r = 0, s = e.length; r < s; r += 2)
        Xc.copy(e[r]), Yc.copy(e[r + 1]), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + Xc.distanceTo(Yc);
    }
    return this;
  }
});
function Lv(t, e) {
  Ci.call(this, t, e), this.type = "LineLoop";
}
Lv.prototype = Object.assign(Object.create(Ci.prototype), {
  constructor: Lv,
  isLineLoop: !0
});
function Ss(t) {
  ke.call(this), this.type = "PointsMaterial", this.color = new De(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t);
}
Ss.prototype = Object.create(ke.prototype);
Ss.prototype.constructor = Ss;
Ss.prototype.isPointsMaterial = !0;
Ss.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
};
const Cv = new Ye(), Ef = new ta(), Zc = new Oi(), Jc = new F();
function Rv(t = new ot(), e = new Ss()) {
  Ie.call(this), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets();
}
Rv.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: Rv,
  isPoints: !0,
  copy: function(t) {
    return Ie.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
  },
  raycast: function(t, e) {
    const n = this.geometry, r = this.matrixWorld, s = t.params.Points.threshold;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Zc.copy(n.boundingSphere), Zc.applyMatrix4(r), Zc.radius += s, t.ray.intersectsSphere(Zc) === !1) return;
    Cv.copy(r).invert(), Ef.copy(t.ray).applyMatrix4(Cv);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o;
    if (n.isBufferGeometry) {
      const l = n.index, h = n.attributes.position;
      if (l !== null) {
        const d = l.array;
        for (let u = 0, p = d.length; u < p; u++) {
          const f = d[u];
          Jc.fromBufferAttribute(h, f), vd(Jc, f, a, r, t, e, this);
        }
      } else
        for (let d = 0, u = h.count; d < u; d++)
          Jc.fromBufferAttribute(h, d), vd(Jc, d, a, r, t, e, this);
    } else {
      const l = n.vertices;
      for (let c = 0, h = l.length; c < h; c++)
        vd(l[c], c, a, r, t, e, this);
    }
  },
  updateMorphTargets: function() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes, n = Object.keys(e);
      if (n.length > 0) {
        const r = e[n[0]];
        if (r !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function vd(t, e, n, r, s, o, a) {
  const l = Ef.distanceSqToPoint(t);
  if (l < n) {
    const c = new F();
    Ef.closestPointToPoint(t, c), c.applyMatrix4(r);
    const h = s.ray.origin.distanceTo(c);
    if (h < s.near || h > s.far) return;
    o.push({
      distance: h,
      distanceToRay: Math.sqrt(l),
      point: c,
      index: e,
      face: null,
      object: a
    });
  }
}
function Pv(t, e, n, r, s, o, a, l, c) {
  ut.call(this, t, e, n, r, s, o, a, l, c), this.format = a !== void 0 ? a : Br, this.minFilter = o !== void 0 ? o : At, this.magFilter = s !== void 0 ? s : At, this.generateMipmaps = !1;
  const h = this;
  function d() {
    h.needsUpdate = !0, t.requestVideoFrameCallback(d);
  }
  "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(d);
}
Pv.prototype = Object.assign(Object.create(ut.prototype), {
  constructor: Pv,
  clone: function() {
    return new this.constructor(this.image).copy(this);
  },
  isVideoTexture: !0,
  update: function() {
    const t = this.image;
    "requestVideoFrameCallback" in t === !1 && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
});
function wl(t, e, n, r, s, o, a, l, c, h, d, u) {
  ut.call(this, null, o, a, l, c, h, r, s, d, u), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
}
wl.prototype = Object.create(ut.prototype);
wl.prototype.constructor = wl;
wl.prototype.isCompressedTexture = !0;
function Fh(t, e, n, r, s, o, a, l, c) {
  ut.call(this, t, e, n, r, s, o, a, l, c), this.needsUpdate = !0;
}
Fh.prototype = Object.create(ut.prototype);
Fh.prototype.constructor = Fh;
Fh.prototype.isCanvasTexture = !0;
function Bh(t, e, n, r, s, o, a, l, c, h) {
  if (h = h !== void 0 ? h : Eo, h !== Eo && h !== ml)
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  n === void 0 && h === Eo && (n = Ph), n === void 0 && h === ml && (n = Wa), ut.call(this, null, r, s, o, a, l, h, n, c), this.image = { width: t, height: e }, this.magFilter = a !== void 0 ? a : Xt, this.minFilter = l !== void 0 ? l : Xt, this.flipY = !1, this.generateMipmaps = !1;
}
Bh.prototype = Object.create(ut.prototype);
Bh.prototype.constructor = Bh;
Bh.prototype.isDepthTexture = !0;
let vR = 0;
const gi = new Ye(), yd = new Ie(), Kc = new F();
function Gt() {
  Object.defineProperty(this, "id", { value: vR += 2 }), this.uuid = Xe.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
Gt.prototype = Object.assign(Object.create(lr.prototype), {
  constructor: Gt,
  isGeometry: !0,
  applyMatrix4: function(t) {
    const e = new hn().getNormalMatrix(t);
    for (let n = 0, r = this.vertices.length; n < r; n++)
      this.vertices[n].applyMatrix4(t);
    for (let n = 0, r = this.faces.length; n < r; n++) {
      const s = this.faces[n];
      s.normal.applyMatrix3(e).normalize();
      for (let o = 0, a = s.vertexNormals.length; o < a; o++)
        s.vertexNormals[o].applyMatrix3(e).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
  },
  rotateX: function(t) {
    return gi.makeRotationX(t), this.applyMatrix4(gi), this;
  },
  rotateY: function(t) {
    return gi.makeRotationY(t), this.applyMatrix4(gi), this;
  },
  rotateZ: function(t) {
    return gi.makeRotationZ(t), this.applyMatrix4(gi), this;
  },
  translate: function(t, e, n) {
    return gi.makeTranslation(t, e, n), this.applyMatrix4(gi), this;
  },
  scale: function(t, e, n) {
    return gi.makeScale(t, e, n), this.applyMatrix4(gi), this;
  },
  lookAt: function(t) {
    return yd.lookAt(t), yd.updateMatrix(), this.applyMatrix4(yd.matrix), this;
  },
  fromBufferGeometry: function(t) {
    const e = this, n = t.index !== null ? t.index : void 0, r = t.attributes;
    if (r.position === void 0)
      return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    const s = r.position, o = r.normal, a = r.color, l = r.uv, c = r.uv2;
    c !== void 0 && (this.faceVertexUvs[1] = []);
    for (let u = 0; u < s.count; u++)
      e.vertices.push(new F().fromBufferAttribute(s, u)), a !== void 0 && e.colors.push(new De().fromBufferAttribute(a, u));
    function h(u, p, f, m) {
      const y = a === void 0 ? [] : [
        e.colors[u].clone(),
        e.colors[p].clone(),
        e.colors[f].clone()
      ], x = o === void 0 ? [] : [
        new F().fromBufferAttribute(o, u),
        new F().fromBufferAttribute(o, p),
        new F().fromBufferAttribute(o, f)
      ], v = new uf(u, p, f, x, y, m);
      e.faces.push(v), l !== void 0 && e.faceVertexUvs[0].push([
        new xe().fromBufferAttribute(l, u),
        new xe().fromBufferAttribute(l, p),
        new xe().fromBufferAttribute(l, f)
      ]), c !== void 0 && e.faceVertexUvs[1].push([
        new xe().fromBufferAttribute(c, u),
        new xe().fromBufferAttribute(c, p),
        new xe().fromBufferAttribute(c, f)
      ]);
    }
    const d = t.groups;
    if (d.length > 0)
      for (let u = 0; u < d.length; u++) {
        const p = d[u], f = p.start, m = p.count;
        for (let y = f, x = f + m; y < x; y += 3)
          n !== void 0 ? h(n.getX(y), n.getX(y + 1), n.getX(y + 2), p.materialIndex) : h(y, y + 1, y + 2, p.materialIndex);
      }
    else if (n !== void 0)
      for (let u = 0; u < n.count; u += 3)
        h(n.getX(u), n.getX(u + 1), n.getX(u + 2));
    else
      for (let u = 0; u < s.count; u += 3)
        h(u, u + 1, u + 2);
    return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
  },
  center: function() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Kc).negate(), this.translate(Kc.x, Kc.y, Kc.z), this;
  },
  normalize: function() {
    this.computeBoundingSphere();
    const t = this.boundingSphere.center, e = this.boundingSphere.radius, n = e === 0 ? 1 : 1 / e, r = new Ye();
    return r.set(
      n,
      0,
      0,
      -n * t.x,
      0,
      n,
      0,
      -n * t.y,
      0,
      0,
      n,
      -n * t.z,
      0,
      0,
      0,
      1
    ), this.applyMatrix4(r), this;
  },
  computeFaceNormals: function() {
    const t = new F(), e = new F();
    for (let n = 0, r = this.faces.length; n < r; n++) {
      const s = this.faces[n], o = this.vertices[s.a], a = this.vertices[s.b], l = this.vertices[s.c];
      t.subVectors(l, a), e.subVectors(o, a), t.cross(e), t.normalize(), s.normal.copy(t);
    }
  },
  computeVertexNormals: function(t = !0) {
    const e = new Array(this.vertices.length);
    for (let n = 0, r = this.vertices.length; n < r; n++)
      e[n] = new F();
    if (t) {
      const n = new F(), r = new F();
      for (let s = 0, o = this.faces.length; s < o; s++) {
        const a = this.faces[s], l = this.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c];
        n.subVectors(h, c), r.subVectors(l, c), n.cross(r), e[a.a].add(n), e[a.b].add(n), e[a.c].add(n);
      }
    } else {
      this.computeFaceNormals();
      for (let n = 0, r = this.faces.length; n < r; n++) {
        const s = this.faces[n];
        e[s.a].add(s.normal), e[s.b].add(s.normal), e[s.c].add(s.normal);
      }
    }
    for (let n = 0, r = this.vertices.length; n < r; n++)
      e[n].normalize();
    for (let n = 0, r = this.faces.length; n < r; n++) {
      const s = this.faces[n], o = s.vertexNormals;
      o.length === 3 ? (o[0].copy(e[s.a]), o[1].copy(e[s.b]), o[2].copy(e[s.c])) : (o[0] = e[s.a].clone(), o[1] = e[s.b].clone(), o[2] = e[s.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function() {
    this.computeFaceNormals();
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const n = this.faces[t], r = n.vertexNormals;
      r.length === 3 ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function() {
    for (let e = 0, n = this.faces.length; e < n; e++) {
      const r = this.faces[e];
      r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []);
      for (let s = 0, o = r.vertexNormals.length; s < o; s++)
        r.__originalVertexNormals[s] ? r.__originalVertexNormals[s].copy(r.vertexNormals[s]) : r.__originalVertexNormals[s] = r.vertexNormals[s].clone();
    }
    const t = new Gt();
    t.faces = this.faces;
    for (let e = 0, n = this.morphTargets.length; e < n; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        const s = this.morphNormals[e].faceNormals, o = this.morphNormals[e].vertexNormals;
        for (let a = 0, l = this.faces.length; a < l; a++) {
          const c = new F(), h = { a: new F(), b: new F(), c: new F() };
          s.push(c), o.push(h);
        }
      }
      const r = this.morphNormals[e];
      t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
      for (let s = 0, o = this.faces.length; s < o; s++) {
        const a = this.faces[s], l = r.faceNormals[s], c = r.vertexNormals[s];
        l.copy(a.normal), c.a.copy(a.vertexNormals[0]), c.b.copy(a.vertexNormals[1]), c.c.copy(a.vertexNormals[2]);
      }
    }
    for (let e = 0, n = this.faces.length; e < n; e++) {
      const r = this.faces[e];
      r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals;
    }
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new Un()), this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new Oi()), this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(t, e, n = 0) {
    if (!(t && t.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
      return;
    }
    let r;
    const s = this.vertices.length, o = this.vertices, a = t.vertices, l = this.faces, c = t.faces, h = this.colors, d = t.colors;
    e !== void 0 && (r = new hn().getNormalMatrix(e));
    for (let u = 0, p = a.length; u < p; u++) {
      const m = a[u].clone();
      e !== void 0 && m.applyMatrix4(e), o.push(m);
    }
    for (let u = 0, p = d.length; u < p; u++)
      h.push(d[u].clone());
    for (let u = 0, p = c.length; u < p; u++) {
      const f = c[u];
      let m, y;
      const x = f.vertexNormals, v = f.vertexColors, g = new uf(f.a + s, f.b + s, f.c + s);
      g.normal.copy(f.normal), r !== void 0 && g.normal.applyMatrix3(r).normalize();
      for (let S = 0, T = x.length; S < T; S++)
        m = x[S].clone(), r !== void 0 && m.applyMatrix3(r).normalize(), g.vertexNormals.push(m);
      g.color.copy(f.color);
      for (let S = 0, T = v.length; S < T; S++)
        y = v[S], g.vertexColors.push(y.clone());
      g.materialIndex = f.materialIndex + n, l.push(g);
    }
    for (let u = 0, p = t.faceVertexUvs.length; u < p; u++) {
      const f = t.faceVertexUvs[u];
      this.faceVertexUvs[u] === void 0 && (this.faceVertexUvs[u] = []);
      for (let m = 0, y = f.length; m < y; m++) {
        const x = f[m], v = [];
        for (let g = 0, S = x.length; g < S; g++)
          v.push(x[g].clone());
        this.faceVertexUvs[u].push(v);
      }
    }
  },
  mergeMesh: function(t) {
    if (!(t && t.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t);
      return;
    }
    t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix);
  },
  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function(t = 4) {
    const e = {}, n = [], r = [], s = Math.pow(10, t);
    for (let l = 0, c = this.vertices.length; l < c; l++) {
      const h = this.vertices[l], d = Math.round(h.x * s) + "_" + Math.round(h.y * s) + "_" + Math.round(h.z * s);
      e[d] === void 0 ? (e[d] = l, n.push(this.vertices[l]), r[l] = n.length - 1) : r[l] = r[e[d]];
    }
    const o = [];
    for (let l = 0, c = this.faces.length; l < c; l++) {
      const h = this.faces[l];
      h.a = r[h.a], h.b = r[h.b], h.c = r[h.c];
      const d = [h.a, h.b, h.c];
      for (let u = 0; u < 3; u++)
        if (d[u] === d[(u + 1) % 3]) {
          o.push(l);
          break;
        }
    }
    for (let l = o.length - 1; l >= 0; l--) {
      const c = o[l];
      this.faces.splice(c, 1);
      for (let h = 0, d = this.faceVertexUvs.length; h < d; h++)
        this.faceVertexUvs[h].splice(c, 1);
    }
    const a = this.vertices.length - n.length;
    return this.vertices = n, a;
  },
  setFromPoints: function(t) {
    this.vertices = [];
    for (let e = 0, n = t.length; e < n; e++) {
      const r = t[e];
      this.vertices.push(new F(r.x, r.y, r.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function() {
    const t = this.faces, e = t.length;
    for (let l = 0; l < e; l++)
      t[l]._id = l;
    function n(l, c) {
      return l.materialIndex - c.materialIndex;
    }
    t.sort(n);
    const r = this.faceVertexUvs[0], s = this.faceVertexUvs[1];
    let o, a;
    r && r.length === e && (o = []), s && s.length === e && (a = []);
    for (let l = 0; l < e; l++) {
      const c = t[l]._id;
      o && o.push(r[c]), a && a.push(s[c]);
    }
    o && (this.faceVertexUvs[0] = o), a && (this.faceVertexUvs[1] = a);
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), this.parameters !== void 0) {
      const f = this.parameters;
      for (const m in f)
        f[m] !== void 0 && (t[m] = f[m]);
      return t;
    }
    const e = [];
    for (let f = 0; f < this.vertices.length; f++) {
      const m = this.vertices[f];
      e.push(m.x, m.y, m.z);
    }
    const n = [], r = [], s = {}, o = [], a = {}, l = [], c = {};
    for (let f = 0; f < this.faces.length; f++) {
      const m = this.faces[f], y = !0, x = !1, v = this.faceVertexUvs[0][f] !== void 0, g = m.normal.length() > 0, S = m.vertexNormals.length > 0, T = m.color.r !== 1 || m.color.g !== 1 || m.color.b !== 1, E = m.vertexColors.length > 0;
      let w = 0;
      if (w = h(w, 0, 0), w = h(w, 1, y), w = h(w, 2, x), w = h(w, 3, v), w = h(w, 4, g), w = h(w, 5, S), w = h(w, 6, T), w = h(w, 7, E), n.push(w), n.push(m.a, m.b, m.c), n.push(m.materialIndex), v) {
        const C = this.faceVertexUvs[0][f];
        n.push(
          p(C[0]),
          p(C[1]),
          p(C[2])
        );
      }
      if (g && n.push(d(m.normal)), S) {
        const C = m.vertexNormals;
        n.push(
          d(C[0]),
          d(C[1]),
          d(C[2])
        );
      }
      if (T && n.push(u(m.color)), E) {
        const C = m.vertexColors;
        n.push(
          u(C[0]),
          u(C[1]),
          u(C[2])
        );
      }
    }
    function h(f, m, y) {
      return y ? f | 1 << m : f & ~(1 << m);
    }
    function d(f) {
      const m = f.x.toString() + f.y.toString() + f.z.toString();
      return s[m] !== void 0 || (s[m] = r.length / 3, r.push(f.x, f.y, f.z)), s[m];
    }
    function u(f) {
      const m = f.r.toString() + f.g.toString() + f.b.toString();
      return a[m] !== void 0 || (a[m] = o.length, o.push(f.getHex())), a[m];
    }
    function p(f) {
      const m = f.x.toString() + f.y.toString();
      return c[m] !== void 0 || (c[m] = l.length / 2, l.push(f.x, f.y)), c[m];
    }
    return t.data = {}, t.data.vertices = e, t.data.normals = r, o.length > 0 && (t.data.colors = o), l.length > 0 && (t.data.uvs = [l]), t.data.faces = n, t;
  },
  clone: function() {
    return new Gt().copy(this);
  },
  copy: function(t) {
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
    const e = t.vertices;
    for (let u = 0, p = e.length; u < p; u++)
      this.vertices.push(e[u].clone());
    const n = t.colors;
    for (let u = 0, p = n.length; u < p; u++)
      this.colors.push(n[u].clone());
    const r = t.faces;
    for (let u = 0, p = r.length; u < p; u++)
      this.faces.push(r[u].clone());
    for (let u = 0, p = t.faceVertexUvs.length; u < p; u++) {
      const f = t.faceVertexUvs[u];
      this.faceVertexUvs[u] === void 0 && (this.faceVertexUvs[u] = []);
      for (let m = 0, y = f.length; m < y; m++) {
        const x = f[m], v = [];
        for (let g = 0, S = x.length; g < S; g++) {
          const T = x[g];
          v.push(T.clone());
        }
        this.faceVertexUvs[u].push(v);
      }
    }
    const s = t.morphTargets;
    for (let u = 0, p = s.length; u < p; u++) {
      const f = {};
      if (f.name = s[u].name, s[u].vertices !== void 0) {
        f.vertices = [];
        for (let m = 0, y = s[u].vertices.length; m < y; m++)
          f.vertices.push(s[u].vertices[m].clone());
      }
      if (s[u].normals !== void 0) {
        f.normals = [];
        for (let m = 0, y = s[u].normals.length; m < y; m++)
          f.normals.push(s[u].normals[m].clone());
      }
      this.morphTargets.push(f);
    }
    const o = t.morphNormals;
    for (let u = 0, p = o.length; u < p; u++) {
      const f = {};
      if (o[u].vertexNormals !== void 0) {
        f.vertexNormals = [];
        for (let m = 0, y = o[u].vertexNormals.length; m < y; m++) {
          const x = o[u].vertexNormals[m], v = {};
          v.a = x.a.clone(), v.b = x.b.clone(), v.c = x.c.clone(), f.vertexNormals.push(v);
        }
      }
      if (o[u].faceNormals !== void 0) {
        f.faceNormals = [];
        for (let m = 0, y = o[u].faceNormals.length; m < y; m++)
          f.faceNormals.push(o[u].faceNormals[m].clone());
      }
      this.morphNormals.push(f);
    }
    const a = t.skinWeights;
    for (let u = 0, p = a.length; u < p; u++)
      this.skinWeights.push(a[u].clone());
    const l = t.skinIndices;
    for (let u = 0, p = l.length; u < p; u++)
      this.skinIndices.push(l[u].clone());
    const c = t.lineDistances;
    for (let u = 0, p = c.length; u < p; u++)
      this.lineDistances.push(c[u]);
    const h = t.boundingBox;
    h !== null && (this.boundingBox = h.clone());
    const d = t.boundingSphere;
    return d !== null && (this.boundingSphere = d.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
class wx extends Gt {
  constructor(e, n, r, s, o, a) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: r,
      widthSegments: s,
      heightSegments: o,
      depthSegments: a
    }, this.fromBufferGeometry(new up(e, n, r, s, o, a)), this.mergeVertices();
  }
}
new F();
new F();
new F();
new Yt();
const yR = {
  triangulate: function(t, e, n) {
    n = n || 2;
    const r = e && e.length, s = r ? e[0] * n : t.length;
    let o = Mx(t, 0, s, n, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let l, c, h, d, u, p, f;
    if (r && (o = MR(t, e, o, n)), t.length > 80 * n) {
      l = h = t[0], c = d = t[1];
      for (let m = n; m < s; m += n)
        u = t[m], p = t[m + 1], u < l && (l = u), p < c && (c = p), u > h && (h = u), p > d && (d = p);
      f = Math.max(h - l, d - c), f = f !== 0 ? 1 / f : 0;
    }
    return Ml(o, a, n, l, c, f), a;
  }
};
function Mx(t, e, n, r, s) {
  let o, a;
  if (s === NR(t, e, n, r) > 0)
    for (o = e; o < n; o += r) a = Iv(o, t[o], t[o + 1], a);
  else
    for (o = n - r; o >= e; o -= r) a = Iv(o, t[o], t[o + 1], a);
  return a && du(a, a.next) && (El(a), a = a.next), a;
}
function Jr(t, e) {
  if (!t) return t;
  e || (e = t);
  let n = t, r;
  do
    if (r = !1, !n.steiner && (du(n, n.next) || St(n.prev, n, n.next) === 0)) {
      if (El(n), n = e = n.prev, n === n.next) break;
      r = !0;
    } else
      n = n.next;
  while (r || n !== e);
  return e;
}
function Ml(t, e, n, r, s, o, a) {
  if (!t) return;
  !a && o && LR(t, r, s, o);
  let l = t, c, h;
  for (; t.prev !== t.next; ) {
    if (c = t.prev, h = t.next, o ? _R(t, r, s, o) : xR(t)) {
      e.push(c.i / n), e.push(t.i / n), e.push(h.i / n), El(t), t = h.next, l = h.next;
      continue;
    }
    if (t = h, t === l) {
      a ? a === 1 ? (t = bR(Jr(t), e, n), Ml(t, e, n, r, s, o, 2)) : a === 2 && wR(t, e, n, r, s, o) : Ml(Jr(t), e, n, r, s, o, 1);
      break;
    }
  }
}
function xR(t) {
  const e = t.prev, n = t, r = t.next;
  if (St(e, n, r) >= 0) return !1;
  let s = t.next.next;
  for (; s !== t.prev; ) {
    if (wo(e.x, e.y, n.x, n.y, r.x, r.y, s.x, s.y) && St(s.prev, s, s.next) >= 0) return !1;
    s = s.next;
  }
  return !0;
}
function _R(t, e, n, r) {
  const s = t.prev, o = t, a = t.next;
  if (St(s, o, a) >= 0) return !1;
  const l = s.x < o.x ? s.x < a.x ? s.x : a.x : o.x < a.x ? o.x : a.x, c = s.y < o.y ? s.y < a.y ? s.y : a.y : o.y < a.y ? o.y : a.y, h = s.x > o.x ? s.x > a.x ? s.x : a.x : o.x > a.x ? o.x : a.x, d = s.y > o.y ? s.y > a.y ? s.y : a.y : o.y > a.y ? o.y : a.y, u = Tf(l, c, e, n, r), p = Tf(h, d, e, n, r);
  let f = t.prevZ, m = t.nextZ;
  for (; f && f.z >= u && m && m.z <= p; ) {
    if (f !== t.prev && f !== t.next && wo(s.x, s.y, o.x, o.y, a.x, a.y, f.x, f.y) && St(f.prev, f, f.next) >= 0 || (f = f.prevZ, m !== t.prev && m !== t.next && wo(s.x, s.y, o.x, o.y, a.x, a.y, m.x, m.y) && St(m.prev, m, m.next) >= 0)) return !1;
    m = m.nextZ;
  }
  for (; f && f.z >= u; ) {
    if (f !== t.prev && f !== t.next && wo(s.x, s.y, o.x, o.y, a.x, a.y, f.x, f.y) && St(f.prev, f, f.next) >= 0) return !1;
    f = f.prevZ;
  }
  for (; m && m.z <= p; ) {
    if (m !== t.prev && m !== t.next && wo(s.x, s.y, o.x, o.y, a.x, a.y, m.x, m.y) && St(m.prev, m, m.next) >= 0) return !1;
    m = m.nextZ;
  }
  return !0;
}
function bR(t, e, n) {
  let r = t;
  do {
    const s = r.prev, o = r.next.next;
    !du(s, o) && Sx(s, r, r.next, o) && Sl(s, o) && Sl(o, s) && (e.push(s.i / n), e.push(r.i / n), e.push(o.i / n), El(r), El(r.next), r = t = o), r = r.next;
  } while (r !== t);
  return Jr(r);
}
function wR(t, e, n, r, s, o) {
  let a = t;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && PR(a, l)) {
        let c = Ex(a, l);
        a = Jr(a, a.next), c = Jr(c, c.next), Ml(a, e, n, r, s, o), Ml(c, e, n, r, s, o);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== t);
}
function MR(t, e, n, r) {
  const s = [];
  let o, a, l, c, h;
  for (o = 0, a = e.length; o < a; o++)
    l = e[o] * r, c = o < a - 1 ? e[o + 1] * r : t.length, h = Mx(t, l, c, r, !1), h === h.next && (h.steiner = !0), s.push(RR(h));
  for (s.sort(SR), o = 0; o < s.length; o++)
    ER(s[o], n), n = Jr(n, n.next);
  return n;
}
function SR(t, e) {
  return t.x - e.x;
}
function ER(t, e) {
  if (e = TR(t, e), e) {
    const n = Ex(e, t);
    Jr(e, e.next), Jr(n, n.next);
  }
}
function TR(t, e) {
  let n = e;
  const r = t.x, s = t.y;
  let o = -1 / 0, a;
  do {
    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
      const p = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (p <= r && p > o) {
        if (o = p, p === r) {
          if (s === n.y) return n;
          if (s === n.next.y) return n.next;
        }
        a = n.x < n.next.x ? n : n.next;
      }
    }
    n = n.next;
  } while (n !== e);
  if (!a) return null;
  if (r === o) return a;
  const l = a, c = a.x, h = a.y;
  let d = 1 / 0, u;
  n = a;
  do
    r >= n.x && n.x >= c && r !== n.x && wo(s < h ? r : o, s, c, h, s < h ? o : r, s, n.x, n.y) && (u = Math.abs(s - n.y) / (r - n.x), Sl(n, t) && (u < d || u === d && (n.x > a.x || n.x === a.x && AR(a, n))) && (a = n, d = u)), n = n.next;
  while (n !== l);
  return a;
}
function AR(t, e) {
  return St(t.prev, t, e.prev) < 0 && St(e.next, t, t.next) < 0;
}
function LR(t, e, n, r) {
  let s = t;
  do
    s.z === null && (s.z = Tf(s.x, s.y, e, n, r)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== t);
  s.prevZ.nextZ = null, s.prevZ = null, CR(s);
}
function CR(t) {
  let e, n, r, s, o, a, l, c, h = 1;
  do {
    for (n = t, t = null, o = null, a = 0; n; ) {
      for (a++, r = n, l = 0, e = 0; e < h && (l++, r = r.nextZ, !!r); e++)
        ;
      for (c = h; l > 0 || c > 0 && r; )
        l !== 0 && (c === 0 || !r || n.z <= r.z) ? (s = n, n = n.nextZ, l--) : (s = r, r = r.nextZ, c--), o ? o.nextZ = s : t = s, s.prevZ = o, o = s;
      n = r;
    }
    o.nextZ = null, h *= 2;
  } while (a > 1);
  return t;
}
function Tf(t, e, n, r, s) {
  return t = 32767 * (t - n) * s, e = 32767 * (e - r) * s, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1;
}
function RR(t) {
  let e = t, n = t;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== t);
  return n;
}
function wo(t, e, n, r, s, o, a, l) {
  return (s - a) * (e - l) - (t - a) * (o - l) >= 0 && (t - a) * (r - l) - (n - a) * (e - l) >= 0 && (n - a) * (o - l) - (s - a) * (r - l) >= 0;
}
function PR(t, e) {
  return t.next.i !== e.i && t.prev.i !== e.i && !IR(t, e) && // dones't intersect other edges
  (Sl(t, e) && Sl(e, t) && DR(t, e) && // locally visible
  (St(t.prev, t, e.prev) || St(t, e.prev, e)) || // does not create opposite-facing sectors
  du(t, e) && St(t.prev, t, t.next) > 0 && St(e.prev, e, e.next) > 0);
}
function St(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function du(t, e) {
  return t.x === e.x && t.y === e.y;
}
function Sx(t, e, n, r) {
  const s = eh(St(t, e, n)), o = eh(St(t, e, r)), a = eh(St(n, r, t)), l = eh(St(n, r, e));
  return !!(s !== o && a !== l || s === 0 && Qc(t, n, e) || o === 0 && Qc(t, r, e) || a === 0 && Qc(n, t, r) || l === 0 && Qc(n, e, r));
}
function Qc(t, e, n) {
  return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
}
function eh(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function IR(t, e) {
  let n = t;
  do {
    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Sx(n, n.next, t, e)) return !0;
    n = n.next;
  } while (n !== t);
  return !1;
}
function Sl(t, e) {
  return St(t.prev, t, t.next) < 0 ? St(t, e, t.next) >= 0 && St(t, t.prev, e) >= 0 : St(t, e, t.prev) < 0 || St(t, t.next, e) < 0;
}
function DR(t, e) {
  let n = t, r = !1;
  const s = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && s < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next;
  while (n !== t);
  return r;
}
function Ex(t, e) {
  const n = new Af(t.i, t.x, t.y), r = new Af(e.i, e.x, e.y), s = t.next, o = e.prev;
  return t.next = e, e.prev = t, n.next = s, s.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r;
}
function Iv(t, e, n, r) {
  const s = new Af(t, e, n);
  return r ? (s.next = r.next, s.prev = r, r.next.prev = s, r.next = s) : (s.prev = s, s.next = s), s;
}
function El(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Af(t, e, n) {
  this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function NR(t, e, n, r) {
  let s = 0;
  for (let o = e, a = n - r; o < n; o += r)
    s += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
  return s;
}
const Ur = {
  // calculate area of the contour polygon
  area: function(t) {
    const e = t.length;
    let n = 0;
    for (let r = e - 1, s = 0; s < e; r = s++)
      n += t[r].x * t[s].y - t[s].x * t[r].y;
    return n * 0.5;
  },
  isClockWise: function(t) {
    return Ur.area(t) < 0;
  },
  triangulateShape: function(t, e) {
    const n = [], r = [], s = [];
    Dv(t), Nv(n, t);
    let o = t.length;
    e.forEach(Dv);
    for (let l = 0; l < e.length; l++)
      r.push(o), o += e[l].length, Nv(n, e[l]);
    const a = yR.triangulate(n, r);
    for (let l = 0; l < a.length; l += 3)
      s.push(a.slice(l, l + 3));
    return s;
  }
};
function Dv(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function Nv(t, e) {
  for (let n = 0; n < e.length; n++)
    t.push(e[n].x), t.push(e[n].y);
}
class Tx extends ot {
  constructor(e, n) {
    super(), this.type = "ExtrudeBufferGeometry", this.parameters = {
      shapes: e,
      options: n
    }, e = Array.isArray(e) ? e : [e];
    const r = this, s = [], o = [];
    for (let l = 0, c = e.length; l < c; l++) {
      const h = e[l];
      a(h);
    }
    this.setAttribute("position", new Qe(s, 3)), this.setAttribute("uv", new Qe(o, 2)), this.computeVertexNormals();
    function a(l) {
      const c = [], h = n.curveSegments !== void 0 ? n.curveSegments : 12, d = n.steps !== void 0 ? n.steps : 1;
      let u = n.depth !== void 0 ? n.depth : 100, p = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0, f = n.bevelThickness !== void 0 ? n.bevelThickness : 6, m = n.bevelSize !== void 0 ? n.bevelSize : f - 2, y = n.bevelOffset !== void 0 ? n.bevelOffset : 0, x = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
      const v = n.extrudePath, g = n.UVGenerator !== void 0 ? n.UVGenerator : OR;
      n.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), u = n.amount);
      let S, T = !1, E, w, C, ee;
      v && (S = v.getSpacedPoints(d), T = !0, p = !1, E = v.computeFrenetFrames(d, !1), w = new F(), C = new F(), ee = new F()), p || (x = 0, f = 0, m = 0, y = 0);
      const Y = l.extractPoints(h);
      let le = Y.shape;
      const B = Y.holes;
      if (!Ur.isClockWise(le)) {
        le = le.reverse();
        for (let R = 0, D = B.length; R < D; R++) {
          const H = B[R];
          Ur.isClockWise(H) && (B[R] = H.reverse());
        }
      }
      const k = Ur.triangulateShape(le, B), O = le;
      for (let R = 0, D = B.length; R < D; R++) {
        const H = B[R];
        le = le.concat(H);
      }
      function P(R, D, H) {
        return D || console.error("THREE.ExtrudeGeometry: vec does not exist"), D.clone().multiplyScalar(H).add(R);
      }
      const j = le.length, re = k.length;
      function ae(R, D, H) {
        let ne, J, b;
        const _ = R.x - D.x, Q = R.y - D.y, X = H.x - R.x, A = H.y - R.y, ie = _ * _ + Q * Q, oe = _ * A - Q * X;
        if (Math.abs(oe) > Number.EPSILON) {
          const he = Math.sqrt(ie), se = Math.sqrt(X * X + A * A), me = D.x - Q / he, ve = D.y + _ / he, be = H.x - A / se, fe = H.y + X / se, _e = ((be - me) * A - (fe - ve) * X) / (_ * A - Q * X);
          ne = me + _ * _e - R.x, J = ve + Q * _e - R.y;
          const Pe = ne * ne + J * J;
          if (Pe <= 2)
            return new xe(ne, J);
          b = Math.sqrt(Pe / 2);
        } else {
          let he = !1;
          _ > Number.EPSILON ? X > Number.EPSILON && (he = !0) : _ < -Number.EPSILON ? X < -Number.EPSILON && (he = !0) : Math.sign(Q) === Math.sign(A) && (he = !0), he ? (ne = -Q, J = _, b = Math.sqrt(ie)) : (ne = _, J = Q, b = Math.sqrt(ie / 2));
        }
        return new xe(ne / b, J / b);
      }
      const ce = [];
      for (let R = 0, D = O.length, H = D - 1, ne = R + 1; R < D; R++, H++, ne++)
        H === D && (H = 0), ne === D && (ne = 0), ce[R] = ae(O[R], O[H], O[ne]);
      const pe = [];
      let de, ge = ce.concat();
      for (let R = 0, D = B.length; R < D; R++) {
        const H = B[R];
        de = [];
        for (let ne = 0, J = H.length, b = J - 1, _ = ne + 1; ne < J; ne++, b++, _++)
          b === J && (b = 0), _ === J && (_ = 0), de[ne] = ae(H[ne], H[b], H[_]);
        pe.push(de), ge = ge.concat(de);
      }
      for (let R = 0; R < x; R++) {
        const D = R / x, H = f * Math.cos(D * Math.PI / 2), ne = m * Math.sin(D * Math.PI / 2) + y;
        for (let J = 0, b = O.length; J < b; J++) {
          const _ = P(O[J], ce[J], ne);
          L(_.x, _.y, -H);
        }
        for (let J = 0, b = B.length; J < b; J++) {
          const _ = B[J];
          de = pe[J];
          for (let Q = 0, X = _.length; Q < X; Q++) {
            const A = P(_[Q], de[Q], ne);
            L(A.x, A.y, -H);
          }
        }
      }
      const we = m + y;
      for (let R = 0; R < j; R++) {
        const D = p ? P(le[R], ge[R], we) : le[R];
        T ? (C.copy(E.normals[0]).multiplyScalar(D.x), w.copy(E.binormals[0]).multiplyScalar(D.y), ee.copy(S[0]).add(C).add(w), L(ee.x, ee.y, ee.z)) : L(D.x, D.y, 0);
      }
      for (let R = 1; R <= d; R++)
        for (let D = 0; D < j; D++) {
          const H = p ? P(le[D], ge[D], we) : le[D];
          T ? (C.copy(E.normals[R]).multiplyScalar(H.x), w.copy(E.binormals[R]).multiplyScalar(H.y), ee.copy(S[R]).add(C).add(w), L(ee.x, ee.y, ee.z)) : L(H.x, H.y, u / d * R);
        }
      for (let R = x - 1; R >= 0; R--) {
        const D = R / x, H = f * Math.cos(D * Math.PI / 2), ne = m * Math.sin(D * Math.PI / 2) + y;
        for (let J = 0, b = O.length; J < b; J++) {
          const _ = P(O[J], ce[J], ne);
          L(_.x, _.y, u + H);
        }
        for (let J = 0, b = B.length; J < b; J++) {
          const _ = B[J];
          de = pe[J];
          for (let Q = 0, X = _.length; Q < X; Q++) {
            const A = P(_[Q], de[Q], ne);
            T ? L(A.x, A.y + S[d - 1].y, S[d - 1].x + H) : L(A.x, A.y, u + H);
          }
        }
      }
      Ge(), te();
      function Ge() {
        const R = s.length / 3;
        if (p) {
          let D = 0, H = j * D;
          for (let ne = 0; ne < re; ne++) {
            const J = k[ne];
            U(J[2] + H, J[1] + H, J[0] + H);
          }
          D = d + x * 2, H = j * D;
          for (let ne = 0; ne < re; ne++) {
            const J = k[ne];
            U(J[0] + H, J[1] + H, J[2] + H);
          }
        } else {
          for (let D = 0; D < re; D++) {
            const H = k[D];
            U(H[2], H[1], H[0]);
          }
          for (let D = 0; D < re; D++) {
            const H = k[D];
            U(H[0] + j * d, H[1] + j * d, H[2] + j * d);
          }
        }
        r.addGroup(R, s.length / 3 - R, 0);
      }
      function te() {
        const R = s.length / 3;
        let D = 0;
        I(O, D), D += O.length;
        for (let H = 0, ne = B.length; H < ne; H++) {
          const J = B[H];
          I(J, D), D += J.length;
        }
        r.addGroup(R, s.length / 3 - R, 1);
      }
      function I(R, D) {
        let H = R.length;
        for (; --H >= 0; ) {
          const ne = H;
          let J = H - 1;
          J < 0 && (J = R.length - 1);
          for (let b = 0, _ = d + x * 2; b < _; b++) {
            const Q = j * b, X = j * (b + 1), A = D + ne + Q, ie = D + J + Q, oe = D + J + X, he = D + ne + X;
            N(A, ie, oe, he);
          }
        }
      }
      function L(R, D, H) {
        c.push(R), c.push(D), c.push(H);
      }
      function U(R, D, H) {
        V(R), V(D), V(H);
        const ne = s.length / 3, J = g.generateTopUV(r, s, ne - 3, ne - 2, ne - 1);
        W(J[0]), W(J[1]), W(J[2]);
      }
      function N(R, D, H, ne) {
        V(R), V(D), V(ne), V(D), V(H), V(ne);
        const J = s.length / 3, b = g.generateSideWallUV(r, s, J - 6, J - 3, J - 2, J - 1);
        W(b[0]), W(b[1]), W(b[3]), W(b[1]), W(b[2]), W(b[3]);
      }
      function V(R) {
        s.push(c[R * 3 + 0]), s.push(c[R * 3 + 1]), s.push(c[R * 3 + 2]);
      }
      function W(R) {
        o.push(R.x), o.push(R.y);
      }
    }
  }
  toJSON() {
    const e = ot.prototype.toJSON.call(this), n = this.parameters.shapes, r = this.parameters.options;
    return FR(n, r, e);
  }
}
const OR = {
  generateTopUV: function(t, e, n, r, s) {
    const o = e[n * 3], a = e[n * 3 + 1], l = e[r * 3], c = e[r * 3 + 1], h = e[s * 3], d = e[s * 3 + 1];
    return [
      new xe(o, a),
      new xe(l, c),
      new xe(h, d)
    ];
  },
  generateSideWallUV: function(t, e, n, r, s, o) {
    const a = e[n * 3], l = e[n * 3 + 1], c = e[n * 3 + 2], h = e[r * 3], d = e[r * 3 + 1], u = e[r * 3 + 2], p = e[s * 3], f = e[s * 3 + 1], m = e[s * 3 + 2], y = e[o * 3], x = e[o * 3 + 1], v = e[o * 3 + 2];
    return Math.abs(l - d) < 0.01 ? [
      new xe(a, 1 - c),
      new xe(h, 1 - u),
      new xe(p, 1 - m),
      new xe(y, 1 - v)
    ] : [
      new xe(l, 1 - c),
      new xe(d, 1 - u),
      new xe(f, 1 - m),
      new xe(x, 1 - v)
    ];
  }
};
function FR(t, e, n) {
  if (n.shapes = [], Array.isArray(t))
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      n.shapes.push(o.uuid);
    }
  else
    n.shapes.push(t.uuid);
  return e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}
class BR extends Gt {
  constructor(e, n) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: n
    }, this.fromBufferGeometry(new Tx(e, n)), this.mergeVertices();
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes, r = this.parameters.options;
    return zR(n, r, e);
  }
}
function zR(t, e, n) {
  if (n.shapes = [], Array.isArray(t))
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      n.shapes.push(o.uuid);
    }
  else
    n.shapes.push(t.uuid);
  return e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}
function zh(t, e, n) {
  ot.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
    func: t,
    slices: e,
    stacks: n
  };
  const r = [], s = [], o = [], a = [], l = 1e-5, c = new F(), h = new F(), d = new F(), u = new F(), p = new F();
  t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  const f = e + 1;
  for (let m = 0; m <= n; m++) {
    const y = m / n;
    for (let x = 0; x <= e; x++) {
      const v = x / e;
      t(v, y, h), s.push(h.x, h.y, h.z), v - l >= 0 ? (t(v - l, y, d), u.subVectors(h, d)) : (t(v + l, y, d), u.subVectors(d, h)), y - l >= 0 ? (t(v, y - l, d), p.subVectors(h, d)) : (t(v, y + l, d), p.subVectors(d, h)), c.crossVectors(u, p).normalize(), o.push(c.x, c.y, c.z), a.push(v, y);
    }
  }
  for (let m = 0; m < n; m++)
    for (let y = 0; y < e; y++) {
      const x = m * f + y, v = m * f + y + 1, g = (m + 1) * f + y + 1, S = (m + 1) * f + y;
      r.push(x, v, S), r.push(v, g, S);
    }
  this.setIndex(r), this.setAttribute("position", new Qe(s, 3)), this.setAttribute("normal", new Qe(o, 3)), this.setAttribute("uv", new Qe(a, 2));
}
zh.prototype = Object.create(ot.prototype);
zh.prototype.constructor = zh;
function Lf(t, e, n) {
  Gt.call(this), this.type = "ParametricGeometry", this.parameters = {
    func: t,
    slices: e,
    stacks: n
  }, this.fromBufferGeometry(new zh(t, e, n)), this.mergeVertices();
}
Lf.prototype = Object.create(Gt.prototype);
Lf.prototype.constructor = Lf;
class UR extends ot {
  constructor(e, n = 12) {
    super(), this.type = "ShapeBufferGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const r = [], s = [], o = [], a = [];
    let l = 0, c = 0;
    if (Array.isArray(e) === !1)
      h(e);
    else
      for (let d = 0; d < e.length; d++)
        h(e[d]), this.addGroup(l, c, d), l += c, c = 0;
    this.setIndex(r), this.setAttribute("position", new Qe(s, 3)), this.setAttribute("normal", new Qe(o, 3)), this.setAttribute("uv", new Qe(a, 2));
    function h(d) {
      const u = s.length / 3, p = d.extractPoints(n);
      let f = p.shape;
      const m = p.holes;
      Ur.isClockWise(f) === !1 && (f = f.reverse());
      for (let x = 0, v = m.length; x < v; x++) {
        const g = m[x];
        Ur.isClockWise(g) === !0 && (m[x] = g.reverse());
      }
      const y = Ur.triangulateShape(f, m);
      for (let x = 0, v = m.length; x < v; x++) {
        const g = m[x];
        f = f.concat(g);
      }
      for (let x = 0, v = f.length; x < v; x++) {
        const g = f[x];
        s.push(g.x, g.y, 0), o.push(0, 0, 1), a.push(g.x, g.y);
      }
      for (let x = 0, v = y.length; x < v; x++) {
        const g = y[x], S = g[0] + u, T = g[1] + u, E = g[2] + u;
        r.push(S, T, E), c += 3;
      }
    }
  }
  toJSON() {
    const e = ot.prototype.toJSON.call(this), n = this.parameters.shapes;
    return HR(n, e);
  }
}
function HR(t, e) {
  if (e.shapes = [], Array.isArray(t))
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.shapes.push(s.uuid);
    }
  else
    e.shapes.push(t.uuid);
  return e;
}
class GR extends Gt {
  constructor(e, n) {
    super(), this.type = "ShapeGeometry", typeof n == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), n = n.curveSegments), this.parameters = {
      shapes: e,
      curveSegments: n
    }, this.fromBufferGeometry(new UR(e, n)), this.mergeVertices();
  }
  toJSON() {
    const e = Gt.prototype.toJSON.call(this), n = this.parameters.shapes;
    return VR(n, e);
  }
}
function VR(t, e) {
  if (e.shapes = [], Array.isArray(t))
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.shapes.push(s.uuid);
    }
  else
    e.shapes.push(t.uuid);
  return e;
}
class kR extends ot {
  constructor(e = 1, n = 8, r = 6, s = 0, o = Math.PI * 2, a = 0, l = Math.PI) {
    super(), this.type = "SphereBufferGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: r,
      phiStart: s,
      phiLength: o,
      thetaStart: a,
      thetaLength: l
    }, n = Math.max(3, Math.floor(n)), r = Math.max(2, Math.floor(r));
    const c = Math.min(a + l, Math.PI);
    let h = 0;
    const d = [], u = new F(), p = new F(), f = [], m = [], y = [], x = [];
    for (let v = 0; v <= r; v++) {
      const g = [], S = v / r;
      let T = 0;
      v == 0 && a == 0 ? T = 0.5 / n : v == r && c == Math.PI && (T = -0.5 / n);
      for (let E = 0; E <= n; E++) {
        const w = E / n;
        u.x = -e * Math.cos(s + w * o) * Math.sin(a + S * l), u.y = e * Math.cos(a + S * l), u.z = e * Math.sin(s + w * o) * Math.sin(a + S * l), m.push(u.x, u.y, u.z), p.copy(u).normalize(), y.push(p.x, p.y, p.z), x.push(w + T, 1 - S), g.push(h++);
      }
      d.push(g);
    }
    for (let v = 0; v < r; v++)
      for (let g = 0; g < n; g++) {
        const S = d[v][g + 1], T = d[v][g], E = d[v + 1][g], w = d[v + 1][g + 1];
        (v !== 0 || a > 0) && f.push(S, T, w), (v !== r - 1 || c < Math.PI) && f.push(T, E, w);
      }
    this.setIndex(f), this.setAttribute("position", new Qe(m, 3)), this.setAttribute("normal", new Qe(y, 3)), this.setAttribute("uv", new Qe(x, 2));
  }
}
class ia extends Gt {
  constructor(e, n, r, s, o, a, l) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: r,
      phiStart: s,
      phiLength: o,
      thetaStart: a,
      thetaLength: l
    }, this.fromBufferGeometry(new kR(e, n, r, s, o, a, l)), this.mergeVertices();
  }
}
class WR extends ot {
  constructor(e) {
    super(), this.type = "WireframeGeometry";
    const n = [], r = [0, 0], s = {}, o = ["a", "b", "c"];
    if (e && e.isGeometry) {
      const a = e.faces;
      for (let l = 0, c = a.length; l < c; l++) {
        const h = a[l];
        for (let d = 0; d < 3; d++) {
          const u = h[o[d]], p = h[o[(d + 1) % 3]];
          r[0] = Math.min(u, p), r[1] = Math.max(u, p);
          const f = r[0] + "," + r[1];
          s[f] === void 0 && (s[f] = { index1: r[0], index2: r[1] });
        }
      }
      for (const l in s) {
        const c = s[l];
        let h = e.vertices[c.index1];
        n.push(h.x, h.y, h.z), h = e.vertices[c.index2], n.push(h.x, h.y, h.z);
      }
    } else if (e && e.isBufferGeometry) {
      const a = new F();
      if (e.index !== null) {
        const l = e.attributes.position, c = e.index;
        let h = e.groups;
        h.length === 0 && (h = [{ start: 0, count: c.count, materialIndex: 0 }]);
        for (let d = 0, u = h.length; d < u; ++d) {
          const p = h[d], f = p.start, m = p.count;
          for (let y = f, x = f + m; y < x; y += 3)
            for (let v = 0; v < 3; v++) {
              const g = c.getX(y + v), S = c.getX(y + (v + 1) % 3);
              r[0] = Math.min(g, S), r[1] = Math.max(g, S);
              const T = r[0] + "," + r[1];
              s[T] === void 0 && (s[T] = { index1: r[0], index2: r[1] });
            }
        }
        for (const d in s) {
          const u = s[d];
          a.fromBufferAttribute(l, u.index1), n.push(a.x, a.y, a.z), a.fromBufferAttribute(l, u.index2), n.push(a.x, a.y, a.z);
        }
      } else {
        const l = e.attributes.position;
        for (let c = 0, h = l.count / 3; c < h; c++)
          for (let d = 0; d < 3; d++) {
            const u = 3 * c + d;
            a.fromBufferAttribute(l, u), n.push(a.x, a.y, a.z);
            const p = 3 * c + (d + 1) % 3;
            a.fromBufferAttribute(l, p), n.push(a.x, a.y, a.z);
          }
      }
    }
    this.setAttribute("position", new Qe(n, 3));
  }
}
function Wo(t) {
  ke.call(this), this.type = "ShadowMaterial", this.color = new De(0), this.transparent = !0, this.setValues(t);
}
Wo.prototype = Object.create(ke.prototype);
Wo.prototype.constructor = Wo;
Wo.prototype.isShadowMaterial = !0;
Wo.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.color.copy(t.color), this;
};
function Tl(t) {
  Kt.call(this, t), this.type = "RawShaderMaterial";
}
Tl.prototype = Object.create(Kt.prototype);
Tl.prototype.constructor = Tl;
Tl.prototype.isRawShaderMaterial = !0;
function tr(t) {
  ke.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new De(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new De(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Qo, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t);
}
tr.prototype = Object.create(ke.prototype);
tr.prototype.constructor = tr;
tr.prototype.isMeshStandardMaterial = !0;
tr.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this;
};
function Es(t) {
  tr.call(this), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new xe(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", {
    get: function() {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function(e) {
      this.reflectivity = Xe.clamp(2.5 * (e - 1) / (e + 1), 0, 1);
    }
  }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t);
}
Es.prototype = Object.create(tr.prototype);
Es.prototype.constructor = Es;
Es.prototype.isMeshPhysicalMaterial = !0;
Es.prototype.copy = function(t) {
  return tr.prototype.copy.call(this, t), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new De()).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this;
};
function Ts(t) {
  ke.call(this), this.type = "MeshPhongMaterial", this.color = new De(16777215), this.specular = new De(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new De(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Qo, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ou, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
Ts.prototype = Object.create(ke.prototype);
Ts.prototype.constructor = Ts;
Ts.prototype.isMeshPhongMaterial = !0;
Ts.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function $o(t) {
  ke.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new De(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new De(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Qo, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
$o.prototype = Object.create(ke.prototype);
$o.prototype.constructor = $o;
$o.prototype.isMeshToonMaterial = !0;
$o.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function Ri(t) {
  ke.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Qo, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
Ri.prototype = Object.create(ke.prototype);
Ri.prototype.constructor = Ri;
Ri.prototype.isMeshNormalMaterial = !0;
Ri.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function Kr(t) {
  ke.call(this), this.type = "MeshLambertMaterial", this.color = new De(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new De(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ou, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
Kr.prototype = Object.create(ke.prototype);
Kr.prototype.constructor = Kr;
Kr.prototype.isMeshLambertMaterial = !0;
Kr.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function jo(t) {
  ke.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new De(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Qo, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}
jo.prototype = Object.create(ke.prototype);
jo.prototype.constructor = jo;
jo.prototype.isMeshMatcapMaterial = !0;
jo.prototype.copy = function(t) {
  return ke.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
};
function qo(t) {
  Vt.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
}
qo.prototype = Object.create(Vt.prototype);
qo.prototype.constructor = qo;
qo.prototype.isLineDashedMaterial = !0;
qo.prototype.copy = function(t) {
  return Vt.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
};
var $R = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial: Wo,
  SpriteMaterial: Zr,
  RawShaderMaterial: Tl,
  ShaderMaterial: Kt,
  PointsMaterial: Ss,
  MeshPhysicalMaterial: Es,
  MeshStandardMaterial: tr,
  MeshPhongMaterial: Ts,
  MeshToonMaterial: $o,
  MeshNormalMaterial: Ri,
  MeshLambertMaterial: Kr,
  MeshDepthMaterial: ws,
  MeshDistanceMaterial: Ms,
  MeshBasicMaterial: ci,
  MeshMatcapMaterial: jo,
  LineDashedMaterial: qo,
  LineBasicMaterial: Vt,
  Material: ke
});
const bt = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(t, e, n) {
    return bt.isTypedArray(t) ? new t.constructor(t.subarray(e, n !== void 0 ? n : t.length)) : t.slice(e, n);
  },
  // converts an array to a specific type
  convertArray: function(t, e, n) {
    return !t || // let 'undefined' and 'null' pass
    !n && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t);
  },
  isTypedArray: function(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(t) {
    function e(s, o) {
      return t[s] - t[o];
    }
    const n = t.length, r = new Array(n);
    for (let s = 0; s !== n; ++s) r[s] = s;
    return r.sort(e), r;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(t, e, n) {
    const r = t.length, s = new t.constructor(r);
    for (let o = 0, a = 0; a !== r; ++o) {
      const l = n[o] * e;
      for (let c = 0; c !== e; ++c)
        s[a++] = t[l + c];
    }
    return s;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(t, e, n, r) {
    let s = 1, o = t[0];
    for (; o !== void 0 && o[r] === void 0; )
      o = t[s++];
    if (o === void 0) return;
    let a = o[r];
    if (a !== void 0)
      if (Array.isArray(a))
        do
          a = o[r], a !== void 0 && (e.push(o.time), n.push.apply(n, a)), o = t[s++];
        while (o !== void 0);
      else if (a.toArray !== void 0)
        do
          a = o[r], a !== void 0 && (e.push(o.time), a.toArray(n, n.length)), o = t[s++];
        while (o !== void 0);
      else
        do
          a = o[r], a !== void 0 && (e.push(o.time), n.push(a)), o = t[s++];
        while (o !== void 0);
  },
  subclip: function(t, e, n, r, s = 30) {
    const o = t.clone();
    o.name = e;
    const a = [];
    for (let c = 0; c < o.tracks.length; ++c) {
      const h = o.tracks[c], d = h.getValueSize(), u = [], p = [];
      for (let f = 0; f < h.times.length; ++f) {
        const m = h.times[f] * s;
        if (!(m < n || m >= r)) {
          u.push(h.times[f]);
          for (let y = 0; y < d; ++y)
            p.push(h.values[f * d + y]);
        }
      }
      u.length !== 0 && (h.times = bt.convertArray(u, h.times.constructor), h.values = bt.convertArray(p, h.values.constructor), a.push(h));
    }
    o.tracks = a;
    let l = 1 / 0;
    for (let c = 0; c < o.tracks.length; ++c)
      l > o.tracks[c].times[0] && (l = o.tracks[c].times[0]);
    for (let c = 0; c < o.tracks.length; ++c)
      o.tracks[c].shift(-1 * l);
    return o.resetDuration(), o;
  },
  makeClipAdditive: function(t, e = 0, n = t, r = 30) {
    r <= 0 && (r = 30);
    const s = n.tracks.length, o = e / r;
    for (let a = 0; a < s; ++a) {
      const l = n.tracks[a], c = l.ValueTypeName;
      if (c === "bool" || c === "string") continue;
      const h = t.tracks.find(function(v) {
        return v.name === l.name && v.ValueTypeName === c;
      });
      if (h === void 0) continue;
      let d = 0;
      const u = l.getValueSize();
      l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = u / 3);
      let p = 0;
      const f = h.getValueSize();
      h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = f / 3);
      const m = l.times.length - 1;
      let y;
      if (o <= l.times[0]) {
        const v = d, g = u - d;
        y = bt.arraySlice(l.values, v, g);
      } else if (o >= l.times[m]) {
        const v = m * u + d, g = v + u - d;
        y = bt.arraySlice(l.values, v, g);
      } else {
        const v = l.createInterpolant(), g = d, S = u - d;
        v.evaluate(o), y = bt.arraySlice(v.resultBuffer, g, S);
      }
      c === "quaternion" && new Mn().fromArray(y).normalize().conjugate().toArray(y);
      const x = h.times.length;
      for (let v = 0; v < x; ++v) {
        const g = v * f + p;
        if (c === "quaternion")
          Mn.multiplyQuaternionsFlat(
            h.values,
            g,
            y,
            0,
            h.values,
            g
          );
        else {
          const S = f - p * 2;
          for (let T = 0; T < S; ++T)
            h.values[g + T] -= y[T];
        }
      }
    }
    return t.blendMode = rx, t;
  }
};
function On(t, e, n, r) {
  this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n;
}
Object.assign(On.prototype, {
  evaluate: function(t) {
    const e = this.parameterPositions;
    let n = this._cachedIndex, r = e[n], s = e[n - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(t < r)) {
            for (let a = n + 2; ; ) {
              if (r === void 0) {
                if (t < s) break i;
                return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, s);
              }
              if (n === a) break;
              if (s = r, r = e[++n], t < r)
                break t;
            }
            o = e.length;
            break n;
          }
          if (!(t >= s)) {
            const a = e[1];
            t < a && (n = 2, s = a);
            for (let l = n - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t, r);
              if (n === l) break;
              if (r = s, s = e[--n - 1], t >= s)
                break t;
            }
            o = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < o; ) {
          const a = n + o >>> 1;
          t < e[a] ? o = a : n = a + 1;
        }
        if (r = e[n], s = e[n - 1], s === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, t, r);
        if (r === void 0)
          return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, s, t);
      }
      this._cachedIndex = n, this.intervalChanged_(n, s, r);
    }
    return this.interpolate_(n, s, t, r);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(t) {
    const e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = t * r;
    for (let o = 0; o !== r; ++o)
      e[o] = n[s + o];
    return e;
  },
  // Template methods for derived classes:
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(On.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: On.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: On.prototype.copySampleValue_
});
function Cf(t, e, n, r) {
  On.call(this, t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
}
Cf.prototype = Object.assign(Object.create(On.prototype), {
  constructor: Cf,
  DefaultSettings_: {
    endingStart: go,
    endingEnd: go
  },
  intervalChanged_: function(t, e, n) {
    const r = this.parameterPositions;
    let s = t - 2, o = t + 1, a = r[s], l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case vo:
          s = t, a = 2 * e - n;
          break;
        case Nh:
          s = r.length - 2, a = e + r[s] - r[s + 1];
          break;
        default:
          s = t, a = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case vo:
          o = t, l = 2 * n - e;
          break;
        case Nh:
          o = 1, l = n + r[1] - r[0];
          break;
        default:
          o = t - 1, l = e;
      }
    const c = (n - e) * 0.5, h = this.valueSize;
    this._weightPrev = c / (e - a), this._weightNext = c / (l - n), this._offsetPrev = s * h, this._offsetNext = o * h;
  },
  interpolate_: function(t, e, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, c = l - a, h = this._offsetPrev, d = this._offsetNext, u = this._weightPrev, p = this._weightNext, f = (n - e) / (r - e), m = f * f, y = m * f, x = -u * y + 2 * u * m - u * f, v = (1 + u) * y + (-1.5 - 2 * u) * m + (-0.5 + u) * f + 1, g = (-1 - p) * y + (1.5 + p) * m + 0.5 * f, S = p * y - p * m;
    for (let T = 0; T !== a; ++T)
      s[T] = x * o[h + T] + v * o[c + T] + g * o[l + T] + S * o[d + T];
    return s;
  }
});
function Uh(t, e, n, r) {
  On.call(this, t, e, n, r);
}
Uh.prototype = Object.assign(Object.create(On.prototype), {
  constructor: Uh,
  interpolate_: function(t, e, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, c = l - a, h = (n - e) / (r - e), d = 1 - h;
    for (let u = 0; u !== a; ++u)
      s[u] = o[c + u] * d + o[l + u] * h;
    return s;
  }
});
function Rf(t, e, n, r) {
  On.call(this, t, e, n, r);
}
Rf.prototype = Object.assign(Object.create(On.prototype), {
  constructor: Rf,
  interpolate_: function(t) {
    return this.copySampleValue_(t - 1);
  }
});
function Qt(t, e, n, r) {
  if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
  this.name = t, this.times = bt.convertArray(e, this.TimeBufferType), this.values = bt.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
}
Object.assign(Qt, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function(t) {
    const e = t.constructor;
    let n;
    if (e.toJSON !== void 0)
      n = e.toJSON(t);
    else {
      n = {
        name: t.name,
        times: bt.convertArray(t.times, Array),
        values: bt.convertArray(t.values, Array)
      };
      const r = t.getInterpolation();
      r !== t.DefaultInterpolation && (n.interpolation = r);
    }
    return n.type = t.ValueTypeName, n;
  }
});
Object.assign(Qt.prototype, {
  constructor: Qt,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: hh,
  InterpolantFactoryMethodDiscrete: function(t) {
    return new Rf(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodLinear: function(t) {
    return new Uh(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: function(t) {
    return new Cf(this.times, this.values, this.getValueSize(), t);
  },
  setInterpolation: function(t) {
    let e;
    switch (t) {
      case Dh:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case hh:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case qu:
        e = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (e === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (t !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = e, this;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Dh;
      case this.InterpolantFactoryMethodLinear:
        return hh;
      case this.InterpolantFactoryMethodSmooth:
        return qu;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function(t) {
    if (t !== 0) {
      const e = this.times;
      for (let n = 0, r = e.length; n !== r; ++n)
        e[n] += t;
    }
    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function(t) {
    if (t !== 1) {
      const e = this.times;
      for (let n = 0, r = e.length; n !== r; ++n)
        e[n] *= t;
    }
    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function(t, e) {
    const n = this.times, r = n.length;
    let s = 0, o = r - 1;
    for (; s !== r && n[s] < t; )
      ++s;
    for (; o !== -1 && n[o] > e; )
      --o;
    if (++o, s !== 0 || o !== r) {
      s >= o && (o = Math.max(o, 1), s = o - 1);
      const a = this.getValueSize();
      this.times = bt.arraySlice(n, s, o), this.values = bt.arraySlice(this.values, s * a, o * a);
    }
    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function() {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
    const n = this.times, r = this.values, s = n.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = n[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), t = !1;
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), t = !1;
        break;
      }
      o = l;
    }
    if (r !== void 0 && bt.isTypedArray(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), t = !1;
          break;
        }
      }
    return t;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function() {
    const t = bt.arraySlice(this.times), e = bt.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === qu, s = t.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = t[a], h = t[a + 1];
      if (c !== h && (a !== 1 || c !== c[0]))
        if (r)
          l = !0;
        else {
          const d = a * n, u = d - n, p = d + n;
          for (let f = 0; f !== n; ++f) {
            const m = e[d + f];
            if (m !== e[u + f] || m !== e[p + f]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          t[o] = t[a];
          const d = a * n, u = o * n;
          for (let p = 0; p !== n; ++p)
            e[u + p] = e[d + p];
        }
        ++o;
      }
    }
    if (s > 0) {
      t[o] = t[s];
      for (let a = s * n, l = o * n, c = 0; c !== n; ++c)
        e[l + c] = e[a + c];
      ++o;
    }
    return o !== t.length ? (this.times = bt.arraySlice(t, 0, o), this.values = bt.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this;
  },
  clone: function() {
    const t = bt.arraySlice(this.times, 0), e = bt.arraySlice(this.values, 0), n = this.constructor, r = new n(this.name, t, e);
    return r.createInterpolant = this.createInterpolant, r;
  }
});
function Pf(t, e, n) {
  Qt.call(this, t, e, n);
}
Pf.prototype = Object.assign(Object.create(Qt.prototype), {
  constructor: Pf,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: Dh,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
});
function If(t, e, n, r) {
  Qt.call(this, t, e, n, r);
}
If.prototype = Object.assign(Object.create(Qt.prototype), {
  constructor: If,
  ValueTypeName: "color"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
});
function Al(t, e, n, r) {
  Qt.call(this, t, e, n, r);
}
Al.prototype = Object.assign(Object.create(Qt.prototype), {
  constructor: Al,
  ValueTypeName: "number"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function Df(t, e, n, r) {
  On.call(this, t, e, n, r);
}
Df.prototype = Object.assign(Object.create(On.prototype), {
  constructor: Df,
  interpolate_: function(t, e, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - e) / (r - e);
    let c = t * a;
    for (let h = c + a; c !== h; c += 4)
      Mn.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
});
function Hh(t, e, n, r) {
  Qt.call(this, t, e, n, r);
}
Hh.prototype = Object.assign(Object.create(Qt.prototype), {
  constructor: Hh,
  ValueTypeName: "quaternion",
  // ValueBufferType is inherited
  DefaultInterpolation: hh,
  InterpolantFactoryMethodLinear: function(t) {
    return new Df(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: void 0
  // not yet implemented
});
function Nf(t, e, n, r) {
  Qt.call(this, t, e, n, r);
}
Nf.prototype = Object.assign(Object.create(Qt.prototype), {
  constructor: Nf,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: Dh,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function Ll(t, e, n, r) {
  Qt.call(this, t, e, n, r);
}
Ll.prototype = Object.assign(Object.create(Qt.prototype), {
  constructor: Ll,
  ValueTypeName: "vector"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function ii(t, e = -1, n, r = hp) {
  this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = Xe.generateUUID(), this.duration < 0 && this.resetDuration();
}
function jR(t) {
  switch (t.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Al;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Ll;
    case "color":
      return If;
    case "quaternion":
      return Hh;
    case "bool":
    case "boolean":
      return Pf;
    case "string":
      return Nf;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
}
function qR(t) {
  if (t.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = jR(t.type);
  if (t.times === void 0) {
    const n = [], r = [];
    bt.flattenJSON(t.keys, n, r, "value"), t.times = n, t.values = r;
  }
  return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
}
Object.assign(ii, {
  parse: function(t) {
    const e = [], n = t.tracks, r = 1 / (t.fps || 1);
    for (let o = 0, a = n.length; o !== a; ++o)
      e.push(qR(n[o]).scale(r));
    const s = new ii(t.name, t.duration, e, t.blendMode);
    return s.uuid = t.uuid, s;
  },
  toJSON: function(t) {
    const e = [], n = t.tracks, r = {
      name: t.name,
      duration: t.duration,
      tracks: e,
      uuid: t.uuid,
      blendMode: t.blendMode
    };
    for (let s = 0, o = n.length; s !== o; ++s)
      e.push(Qt.toJSON(n[s]));
    return r;
  },
  CreateFromMorphTargetSequence: function(t, e, n, r) {
    const s = e.length, o = [];
    for (let a = 0; a < s; a++) {
      let l = [], c = [];
      l.push(
        (a + s - 1) % s,
        a,
        (a + 1) % s
      ), c.push(0, 1, 0);
      const h = bt.getKeyframeOrder(l);
      l = bt.sortedArray(l, 1, h), c = bt.sortedArray(c, 1, h), !r && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(
        new Al(
          ".morphTargetInfluences[" + e[a].name + "]",
          l,
          c
        ).scale(1 / n)
      );
    }
    return new ii(t, -1, o);
  },
  findByName: function(t, e) {
    let n = t;
    if (!Array.isArray(t)) {
      const r = t;
      n = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < n.length; r++)
      if (n[r].name === e)
        return n[r];
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(t, e, n) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = t.length; a < l; a++) {
      const c = t[a], h = c.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let u = r[d];
        u || (r[d] = u = []), u.push(c);
      }
    }
    const o = [];
    for (const a in r)
      o.push(ii.CreateFromMorphTargetSequence(a, r[a], e, n));
    return o;
  },
  // parse the animation.hierarchy format
  parseAnimation: function(t, e) {
    if (!t)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(d, u, p, f, m) {
      if (p.length !== 0) {
        const y = [], x = [];
        bt.flattenJSON(p, y, x, f), y.length !== 0 && m.push(new d(u, y, x));
      }
    }, r = [], s = t.name || "default", o = t.fps || 30, a = t.blendMode;
    let l = t.length || -1;
    const c = t.hierarchy || [];
    for (let d = 0; d < c.length; d++) {
      const u = c[d].keys;
      if (!(!u || u.length === 0))
        if (u[0].morphTargets) {
          const p = {};
          let f;
          for (f = 0; f < u.length; f++)
            if (u[f].morphTargets)
              for (let m = 0; m < u[f].morphTargets.length; m++)
                p[u[f].morphTargets[m]] = -1;
          for (const m in p) {
            const y = [], x = [];
            for (let v = 0; v !== u[f].morphTargets.length; ++v) {
              const g = u[f];
              y.push(g.time), x.push(g.morphTarget === m ? 1 : 0);
            }
            r.push(new Al(".morphTargetInfluence[" + m + "]", y, x));
          }
          l = p.length * o;
        } else {
          const p = ".bones[" + e[d].name + "]";
          n(
            Ll,
            p + ".position",
            u,
            "pos",
            r
          ), n(
            Hh,
            p + ".quaternion",
            u,
            "rot",
            r
          ), n(
            Ll,
            p + ".scale",
            u,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new ii(s, l, r, a);
  }
});
Object.assign(ii.prototype, {
  resetDuration: function() {
    const t = this.tracks;
    let e = 0;
    for (let n = 0, r = t.length; n !== r; ++n) {
      const s = this.tracks[n];
      e = Math.max(e, s.times[s.times.length - 1]);
    }
    return this.duration = e, this;
  },
  trim: function() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration);
    return this;
  },
  validate: function() {
    let t = !0;
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate();
    return t;
  },
  optimize: function() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].optimize();
    return this;
  },
  clone: function() {
    const t = [];
    for (let e = 0; e < this.tracks.length; e++)
      t.push(this.tracks[e].clone());
    return new ii(this.name, this.duration, t, this.blendMode);
  },
  toJSON: function() {
    return ii.toJSON(this);
  }
});
const Xo = {
  enabled: !1,
  files: {},
  add: function(t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function(t) {
    if (this.enabled !== !1)
      return this.files[t];
  },
  remove: function(t) {
    delete this.files[t];
  },
  clear: function() {
    this.files = {};
  }
};
function XR(t, e, n) {
  const r = this;
  let s = !1, o = 0, a = 0, l;
  const c = [];
  this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(h) {
    a++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, a), s = !0;
  }, this.itemEnd = function(h) {
    o++, r.onProgress !== void 0 && r.onProgress(h, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad());
  }, this.itemError = function(h) {
    r.onError !== void 0 && r.onError(h);
  }, this.resolveURL = function(h) {
    return l ? l(h) : h;
  }, this.setURLModifier = function(h) {
    return l = h, this;
  }, this.addHandler = function(h, d) {
    return c.push(h, d), this;
  }, this.removeHandler = function(h) {
    const d = c.indexOf(h);
    return d !== -1 && c.splice(d, 2), this;
  }, this.getHandler = function(h) {
    for (let d = 0, u = c.length; d < u; d += 2) {
      const p = c[d], f = c[d + 1];
      if (p.global && (p.lastIndex = 0), p.test(h))
        return f;
    }
    return null;
  };
}
const YR = new XR();
function pt(t) {
  this.manager = t !== void 0 ? t : YR, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
}
Object.assign(pt.prototype, {
  load: function() {
  },
  loadAsync: function(t, e) {
    const n = this;
    return new Promise(function(r, s) {
      n.load(t, r, e, s);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(t) {
    return this.crossOrigin = t, this;
  },
  setWithCredentials: function(t) {
    return this.withCredentials = t, this;
  },
  setPath: function(t) {
    return this.path = t, this;
  },
  setResourcePath: function(t) {
    return this.resourcePath = t, this;
  },
  setRequestHeader: function(t) {
    return this.requestHeader = t, this;
  }
});
const Qn = {};
function nr(t) {
  pt.call(this, t);
}
nr.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: nr,
  load: function(t, e, n, r) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const s = this, o = Xo.get(t);
    if (o !== void 0)
      return s.manager.itemStart(t), setTimeout(function() {
        e && e(o), s.manager.itemEnd(t);
      }, 0), o;
    if (Qn[t] !== void 0) {
      Qn[t].push({
        onLoad: e,
        onProgress: n,
        onError: r
      });
      return;
    }
    const a = /^data:(.*?)(;base64)?,(.*)$/, l = t.match(a);
    let c;
    if (l) {
      const h = l[1], d = !!l[2];
      let u = l[3];
      u = decodeURIComponent(u), d && (u = atob(u));
      try {
        let p;
        const f = (this.responseType || "").toLowerCase();
        switch (f) {
          case "arraybuffer":
          case "blob":
            const m = new Uint8Array(u.length);
            for (let x = 0; x < u.length; x++)
              m[x] = u.charCodeAt(x);
            f === "blob" ? p = new Blob([m.buffer], { type: h }) : p = m.buffer;
            break;
          case "document":
            p = new DOMParser().parseFromString(u, h);
            break;
          case "json":
            p = JSON.parse(u);
            break;
          default:
            p = u;
            break;
        }
        setTimeout(function() {
          e && e(p), s.manager.itemEnd(t);
        }, 0);
      } catch (p) {
        setTimeout(function() {
          r && r(p), s.manager.itemError(t), s.manager.itemEnd(t);
        }, 0);
      }
    } else {
      Qn[t] = [], Qn[t].push({
        onLoad: e,
        onProgress: n,
        onError: r
      }), c = new XMLHttpRequest(), c.open("GET", t, !0), c.addEventListener("load", function(h) {
        const d = this.response, u = Qn[t];
        if (delete Qn[t], this.status === 200 || this.status === 0) {
          this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), Xo.add(t, d);
          for (let p = 0, f = u.length; p < f; p++) {
            const m = u[p];
            m.onLoad && m.onLoad(d);
          }
          s.manager.itemEnd(t);
        } else {
          for (let p = 0, f = u.length; p < f; p++) {
            const m = u[p];
            m.onError && m.onError(h);
          }
          s.manager.itemError(t), s.manager.itemEnd(t);
        }
      }, !1), c.addEventListener("progress", function(h) {
        const d = Qn[t];
        for (let u = 0, p = d.length; u < p; u++) {
          const f = d[u];
          f.onProgress && f.onProgress(h);
        }
      }, !1), c.addEventListener("error", function(h) {
        const d = Qn[t];
        delete Qn[t];
        for (let u = 0, p = d.length; u < p; u++) {
          const f = d[u];
          f.onError && f.onError(h);
        }
        s.manager.itemError(t), s.manager.itemEnd(t);
      }, !1), c.addEventListener("abort", function(h) {
        const d = Qn[t];
        delete Qn[t];
        for (let u = 0, p = d.length; u < p; u++) {
          const f = d[u];
          f.onError && f.onError(h);
        }
        s.manager.itemError(t), s.manager.itemEnd(t);
      }, !1), this.responseType !== void 0 && (c.responseType = this.responseType), this.withCredentials !== void 0 && (c.withCredentials = this.withCredentials), c.overrideMimeType && c.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const h in this.requestHeader)
        c.setRequestHeader(h, this.requestHeader[h]);
      c.send(null);
    }
    return s.manager.itemStart(t), c;
  },
  setResponseType: function(t) {
    return this.responseType = t, this;
  },
  setMimeType: function(t) {
    return this.mimeType = t, this;
  }
});
function Ov(t) {
  pt.call(this, t);
}
Ov.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Ov,
  load: function(t, e, n, r) {
    const s = this, o = new nr(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      try {
        e(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  },
  parse: function(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const r = ii.parse(t[n]);
      e.push(r);
    }
    return e;
  }
});
function Fv(t) {
  pt.call(this, t);
}
Fv.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Fv,
  load: function(t, e, n, r) {
    const s = this, o = [], a = new wl(), l = new nr(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials);
    let c = 0;
    function h(d) {
      l.load(t[d], function(u) {
        const p = s.parse(u, !0);
        o[d] = {
          width: p.width,
          height: p.height,
          format: p.format,
          mipmaps: p.mipmaps
        }, c += 1, c === 6 && (p.mipmapCount === 1 && (a.minFilter = At), a.image = o, a.format = p.format, a.needsUpdate = !0, e && e(a));
      }, n, r);
    }
    if (Array.isArray(t))
      for (let d = 0, u = t.length; d < u; ++d)
        h(d);
    else
      l.load(t, function(d) {
        const u = s.parse(d, !0);
        if (u.isCubemap) {
          const p = u.mipmaps.length / u.mipmapCount;
          for (let f = 0; f < p; f++) {
            o[f] = { mipmaps: [] };
            for (let m = 0; m < u.mipmapCount; m++)
              o[f].mipmaps.push(u.mipmaps[f * u.mipmapCount + m]), o[f].format = u.format, o[f].width = u.width, o[f].height = u.height;
          }
          a.image = o;
        } else
          a.image.width = u.width, a.image.height = u.height, a.mipmaps = u.mipmaps;
        u.mipmapCount === 1 && (a.minFilter = At), a.format = u.format, a.needsUpdate = !0, e && e(a);
      }, n, r);
    return a;
  }
});
function Gh(t) {
  pt.call(this, t);
}
Gh.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Gh,
  load: function(t, e, n, r) {
    this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const s = this, o = Xo.get(t);
    if (o !== void 0)
      return s.manager.itemStart(t), setTimeout(function() {
        e && e(o), s.manager.itemEnd(t);
      }, 0), o;
    const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function l() {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1), Xo.add(t, this), e && e(this), s.manager.itemEnd(t);
    }
    function c(h) {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1), r && r(h), s.manager.itemError(t), s.manager.itemEnd(t);
    }
    return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), t.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(t), a.src = t, a;
  }
});
function Of(t) {
  pt.call(this, t);
}
Of.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Of,
  load: function(t, e, n, r) {
    const s = new Xr(), o = new Gh(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(c) {
      o.load(t[c], function(h) {
        s.images[c] = h, a++, a === 6 && (s.needsUpdate = !0, e && e(s));
      }, void 0, r);
    }
    for (let c = 0; c < t.length; ++c)
      l(c);
    return s;
  }
});
function Bv(t) {
  pt.call(this, t);
}
Bv.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Bv,
  load: function(t, e, n, r) {
    const s = this, o = new Yr(), a = new nr(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(t, function(l) {
      const c = s.parse(l);
      c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : yn, o.wrapT = c.wrapT !== void 0 ? c.wrapT : yn, o.magFilter = c.magFilter !== void 0 ? c.magFilter : At, o.minFilter = c.minFilter !== void 0 ? c.minFilter : At, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = au), c.mipmapCount === 1 && (o.minFilter = At), o.needsUpdate = !0, e && e(o, c));
    }, n, r), o;
  }
});
function Vh(t) {
  pt.call(this, t);
}
Vh.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Vh,
  load: function(t, e, n, r) {
    const s = new ut(), o = new Gh(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(a) {
      s.image = a;
      const l = t.search(/\.jpe?g($|\?)/i) > 0 || t.search(/^data\:image\/jpeg/) === 0;
      s.format = l ? Br : Nn, s.needsUpdate = !0, e !== void 0 && e(s);
    }, n, r), s;
  }
});
function Fe() {
  this.type = "Curve", this.arcLengthDivisions = 200;
}
Object.assign(Fe.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getPoint(n, e);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPoint(n / t));
    return e;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPointAt(n / t));
    return e;
  },
  // Get total curve arc length
  getLength: function() {
    const t = this.getLengths();
    return t[t.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function(t) {
    if (t === void 0 && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let n, r = this.getPoint(0), s = 0;
    e.push(0);
    for (let o = 1; o <= t; o++)
      n = this.getPoint(o / t), s += n.distanceTo(r), e.push(s), r = n;
    return this.cacheArcLengths = e, e;
  },
  updateArcLengths: function() {
    this.needsUpdate = !0, this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function(t, e) {
    const n = this.getLengths();
    let r = 0;
    const s = n.length;
    let o;
    e ? o = e : o = t * n[s - 1];
    let a = 0, l = s - 1, c;
    for (; a <= l; )
      if (r = Math.floor(a + (l - a) / 2), c = n[r] - o, c < 0)
        a = r + 1;
      else if (c > 0)
        l = r - 1;
      else {
        l = r;
        break;
      }
    if (r = l, n[r] === o)
      return r / (s - 1);
    const h = n[r], u = n[r + 1] - h, p = (o - h) / u;
    return (r + p) / (s - 1);
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function(t, e) {
    let r = t - 1e-4, s = t + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r), a = this.getPoint(s), l = e || (o.isVector2 ? new xe() : new F());
    return l.copy(a).sub(o).normalize(), l;
  },
  getTangentAt: function(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getTangent(n, e);
  },
  computeFrenetFrames: function(t, e) {
    const n = new F(), r = [], s = [], o = [], a = new F(), l = new Ye();
    for (let p = 0; p <= t; p++) {
      const f = p / t;
      r[p] = this.getTangentAt(f, new F()), r[p].normalize();
    }
    s[0] = new F(), o[0] = new F();
    let c = Number.MAX_VALUE;
    const h = Math.abs(r[0].x), d = Math.abs(r[0].y), u = Math.abs(r[0].z);
    h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), u <= c && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]);
    for (let p = 1; p <= t; p++) {
      if (s[p] = s[p - 1].clone(), o[p] = o[p - 1].clone(), a.crossVectors(r[p - 1], r[p]), a.length() > Number.EPSILON) {
        a.normalize();
        const f = Math.acos(Xe.clamp(r[p - 1].dot(r[p]), -1, 1));
        s[p].applyMatrix4(l.makeRotationAxis(a, f));
      }
      o[p].crossVectors(r[p], s[p]);
    }
    if (e === !0) {
      let p = Math.acos(Xe.clamp(s[0].dot(s[t]), -1, 1));
      p /= t, r[0].dot(a.crossVectors(s[0], s[t])) > 0 && (p = -p);
      for (let f = 1; f <= t; f++)
        s[f].applyMatrix4(l.makeRotationAxis(r[f], p * f)), o[f].crossVectors(r[f], s[f]);
    }
    return {
      tangents: r,
      normals: s,
      binormals: o
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  },
  toJSON: function() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
  },
  fromJSON: function(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
});
function Gn(t, e, n, r, s, o, a, l) {
  Fe.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = s || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = l || 0;
}
Gn.prototype = Object.create(Fe.prototype);
Gn.prototype.constructor = Gn;
Gn.prototype.isEllipseCurve = !0;
Gn.prototype.getPoint = function(t, e) {
  const n = e || new xe(), r = Math.PI * 2;
  let s = this.aEndAngle - this.aStartAngle;
  const o = Math.abs(s) < Number.EPSILON;
  for (; s < 0; ) s += r;
  for (; s > r; ) s -= r;
  s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
  const a = this.aStartAngle + t * s;
  let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
  if (this.aRotation !== 0) {
    const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), u = l - this.aX, p = c - this.aY;
    l = u * h - p * d + this.aX, c = u * d + p * h + this.aY;
  }
  return n.set(l, c);
};
Gn.prototype.copy = function(t) {
  return Fe.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
};
Gn.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
};
Gn.prototype.fromJSON = function(t) {
  return Fe.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
};
function Cl(t, e, n, r, s, o) {
  Gn.call(this, t, e, n, n, r, s, o), this.type = "ArcCurve";
}
Cl.prototype = Object.create(Gn.prototype);
Cl.prototype.constructor = Cl;
Cl.prototype.isArcCurve = !0;
function fp() {
  let t = 0, e = 0, n = 0, r = 0;
  function s(o, a, l, c) {
    t = o, e = l, n = -3 * o + 3 * a - 2 * l - c, r = 2 * o - 2 * a + l + c;
  }
  return {
    initCatmullRom: function(o, a, l, c, h) {
      s(a, l, h * (l - o), h * (c - a));
    },
    initNonuniformCatmullRom: function(o, a, l, c, h, d, u) {
      let p = (a - o) / h - (l - o) / (h + d) + (l - a) / d, f = (l - a) / d - (c - a) / (d + u) + (c - l) / u;
      p *= d, f *= d, s(a, l, p, f);
    },
    calc: function(o) {
      const a = o * o, l = a * o;
      return t + e * o + n * a + r * l;
    }
  };
}
const th = new F(), xd = new fp(), _d = new fp(), bd = new fp();
function Ln(t = [], e = !1, n = "centripetal", r = 0.5) {
  Fe.call(this), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r;
}
Ln.prototype = Object.create(Fe.prototype);
Ln.prototype.constructor = Ln;
Ln.prototype.isCatmullRomCurve3 = !0;
Ln.prototype.getPoint = function(t, e = new F()) {
  const n = e, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * t;
  let a = Math.floor(o), l = o - a;
  this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
  let c, h;
  this.closed || a > 0 ? c = r[(a - 1) % s] : (th.subVectors(r[0], r[1]).add(r[0]), c = th);
  const d = r[a % s], u = r[(a + 1) % s];
  if (this.closed || a + 2 < s ? h = r[(a + 2) % s] : (th.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), h = th), this.curveType === "centripetal" || this.curveType === "chordal") {
    const p = this.curveType === "chordal" ? 0.5 : 0.25;
    let f = Math.pow(c.distanceToSquared(d), p), m = Math.pow(d.distanceToSquared(u), p), y = Math.pow(u.distanceToSquared(h), p);
    m < 1e-4 && (m = 1), f < 1e-4 && (f = m), y < 1e-4 && (y = m), xd.initNonuniformCatmullRom(c.x, d.x, u.x, h.x, f, m, y), _d.initNonuniformCatmullRom(c.y, d.y, u.y, h.y, f, m, y), bd.initNonuniformCatmullRom(c.z, d.z, u.z, h.z, f, m, y);
  } else this.curveType === "catmullrom" && (xd.initCatmullRom(c.x, d.x, u.x, h.x, this.tension), _d.initCatmullRom(c.y, d.y, u.y, h.y, this.tension), bd.initCatmullRom(c.z, d.z, u.z, h.z, this.tension));
  return n.set(
    xd.calc(l),
    _d.calc(l),
    bd.calc(l)
  ), n;
};
Ln.prototype.copy = function(t) {
  Fe.prototype.copy.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const r = t.points[e];
    this.points.push(r.clone());
  }
  return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
};
Ln.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  t.points = [];
  for (let e = 0, n = this.points.length; e < n; e++) {
    const r = this.points[e];
    t.points.push(r.toArray());
  }
  return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
};
Ln.prototype.fromJSON = function(t) {
  Fe.prototype.fromJSON.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const r = t.points[e];
    this.points.push(new F().fromArray(r));
  }
  return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
};
function zv(t, e, n, r, s) {
  const o = (r - e) * 0.5, a = (s - n) * 0.5, l = t * t, c = t * l;
  return (2 * n - 2 * r + o + a) * c + (-3 * n + 3 * r - 2 * o - a) * l + o * t + n;
}
function ZR(t, e) {
  const n = 1 - t;
  return n * n * e;
}
function JR(t, e) {
  return 2 * (1 - t) * t * e;
}
function KR(t, e) {
  return t * t * e;
}
function qa(t, e, n, r) {
  return ZR(t, e) + JR(t, n) + KR(t, r);
}
function QR(t, e) {
  const n = 1 - t;
  return n * n * n * e;
}
function eP(t, e) {
  const n = 1 - t;
  return 3 * n * n * t * e;
}
function tP(t, e) {
  return 3 * (1 - t) * t * t * e;
}
function nP(t, e) {
  return t * t * t * e;
}
function Xa(t, e, n, r, s) {
  return QR(t, e) + eP(t, n) + tP(t, r) + nP(t, s);
}
function Pi(t = new xe(), e = new xe(), n = new xe(), r = new xe()) {
  Fe.call(this), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r;
}
Pi.prototype = Object.create(Fe.prototype);
Pi.prototype.constructor = Pi;
Pi.prototype.isCubicBezierCurve = !0;
Pi.prototype.getPoint = function(t, e = new xe()) {
  const n = e, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
  return n.set(
    Xa(t, r.x, s.x, o.x, a.x),
    Xa(t, r.y, s.y, o.y, a.y)
  ), n;
};
Pi.prototype.copy = function(t) {
  return Fe.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
};
Pi.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
};
Pi.prototype.fromJSON = function(t) {
  return Fe.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
};
function ir(t = new F(), e = new F(), n = new F(), r = new F()) {
  Fe.call(this), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r;
}
ir.prototype = Object.create(Fe.prototype);
ir.prototype.constructor = ir;
ir.prototype.isCubicBezierCurve3 = !0;
ir.prototype.getPoint = function(t, e = new F()) {
  const n = e, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
  return n.set(
    Xa(t, r.x, s.x, o.x, a.x),
    Xa(t, r.y, s.y, o.y, a.y),
    Xa(t, r.z, s.z, o.z, a.z)
  ), n;
};
ir.prototype.copy = function(t) {
  return Fe.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
};
ir.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
};
ir.prototype.fromJSON = function(t) {
  return Fe.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
};
function Cn(t = new xe(), e = new xe()) {
  Fe.call(this), this.type = "LineCurve", this.v1 = t, this.v2 = e;
}
Cn.prototype = Object.create(Fe.prototype);
Cn.prototype.constructor = Cn;
Cn.prototype.isLineCurve = !0;
Cn.prototype.getPoint = function(t, e = new xe()) {
  const n = e;
  return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
};
Cn.prototype.getPointAt = function(t, e) {
  return this.getPoint(t, e);
};
Cn.prototype.getTangent = function(t, e) {
  const n = e || new xe();
  return n.copy(this.v2).sub(this.v1).normalize(), n;
};
Cn.prototype.copy = function(t) {
  return Fe.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Cn.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Cn.prototype.fromJSON = function(t) {
  return Fe.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Ii(t = new F(), e = new F()) {
  Fe.call(this), this.type = "LineCurve3", this.v1 = t, this.v2 = e;
}
Ii.prototype = Object.create(Fe.prototype);
Ii.prototype.constructor = Ii;
Ii.prototype.isLineCurve3 = !0;
Ii.prototype.getPoint = function(t, e = new F()) {
  const n = e;
  return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
};
Ii.prototype.getPointAt = function(t, e) {
  return this.getPoint(t, e);
};
Ii.prototype.copy = function(t) {
  return Fe.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Ii.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Ii.prototype.fromJSON = function(t) {
  return Fe.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Di(t = new xe(), e = new xe(), n = new xe()) {
  Fe.call(this), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n;
}
Di.prototype = Object.create(Fe.prototype);
Di.prototype.constructor = Di;
Di.prototype.isQuadraticBezierCurve = !0;
Di.prototype.getPoint = function(t, e = new xe()) {
  const n = e, r = this.v0, s = this.v1, o = this.v2;
  return n.set(
    qa(t, r.x, s.x, o.x),
    qa(t, r.y, s.y, o.y)
  ), n;
};
Di.prototype.copy = function(t) {
  return Fe.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
Di.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
Di.prototype.fromJSON = function(t) {
  return Fe.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function rr(t = new F(), e = new F(), n = new F()) {
  Fe.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n;
}
rr.prototype = Object.create(Fe.prototype);
rr.prototype.constructor = rr;
rr.prototype.isQuadraticBezierCurve3 = !0;
rr.prototype.getPoint = function(t, e = new F()) {
  const n = e, r = this.v0, s = this.v1, o = this.v2;
  return n.set(
    qa(t, r.x, s.x, o.x),
    qa(t, r.y, s.y, o.y),
    qa(t, r.z, s.z, o.z)
  ), n;
};
rr.prototype.copy = function(t) {
  return Fe.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
};
rr.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
};
rr.prototype.fromJSON = function(t) {
  return Fe.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
};
function Ni(t = []) {
  Fe.call(this), this.type = "SplineCurve", this.points = t;
}
Ni.prototype = Object.create(Fe.prototype);
Ni.prototype.constructor = Ni;
Ni.prototype.isSplineCurve = !0;
Ni.prototype.getPoint = function(t, e = new xe()) {
  const n = e, r = this.points, s = (r.length - 1) * t, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], c = r[o], h = r[o > r.length - 2 ? r.length - 1 : o + 1], d = r[o > r.length - 3 ? r.length - 1 : o + 2];
  return n.set(
    zv(a, l.x, c.x, h.x, d.x),
    zv(a, l.y, c.y, h.y, d.y)
  ), n;
};
Ni.prototype.copy = function(t) {
  Fe.prototype.copy.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const r = t.points[e];
    this.points.push(r.clone());
  }
  return this;
};
Ni.prototype.toJSON = function() {
  const t = Fe.prototype.toJSON.call(this);
  t.points = [];
  for (let e = 0, n = this.points.length; e < n; e++) {
    const r = this.points[e];
    t.points.push(r.toArray());
  }
  return t;
};
Ni.prototype.fromJSON = function(t) {
  Fe.prototype.fromJSON.call(this, t), this.points = [];
  for (let e = 0, n = t.points.length; e < n; e++) {
    const r = t.points[e];
    this.points.push(new xe().fromArray(r));
  }
  return this;
};
var iP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: Cl,
  CatmullRomCurve3: Ln,
  CubicBezierCurve: Pi,
  CubicBezierCurve3: ir,
  EllipseCurve: Gn,
  LineCurve: Cn,
  LineCurve3: Ii,
  QuadraticBezierCurve: Di,
  QuadraticBezierCurve3: rr,
  SplineCurve: Ni
});
function Ir() {
  Fe.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
}
Ir.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: Ir,
  add: function(t) {
    this.curves.push(t);
  },
  closePath: function() {
    const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new Cn(e, t));
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function(t) {
    const e = t * this.getLength(), n = this.getCurveLengths();
    let r = 0;
    for (; r < n.length; ) {
      if (n[r] >= e) {
        const s = n[r] - e, o = this.curves[r], a = o.getLength(), l = a === 0 ? 0 : 1 - s / a;
        return o.getPointAt(l);
      }
      r++;
    }
    return null;
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      e += this.curves[n].getLength(), t.push(e);
    return this.cacheLengths = t, t;
  },
  getSpacedPoints: function(t = 40) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPoint(n / t));
    return this.autoClose && e.push(e[0]), e;
  },
  getPoints: function(t = 12) {
    const e = [];
    let n;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r], a = o && o.isEllipseCurve ? t * 2 : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        n && n.equals(h) || (e.push(h), n = h);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  },
  copy: function(t) {
    Fe.prototype.copy.call(this, t), this.curves = [];
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const r = t.curves[e];
      this.curves.push(r.clone());
    }
    return this.autoClose = t.autoClose, this;
  },
  toJSON: function() {
    const t = Fe.prototype.toJSON.call(this);
    t.autoClose = this.autoClose, t.curves = [];
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const r = this.curves[e];
      t.curves.push(r.toJSON());
    }
    return t;
  },
  fromJSON: function(t) {
    Fe.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const r = t.curves[e];
      this.curves.push(new iP[r.type]().fromJSON(r));
    }
    return this;
  }
});
function xi(t) {
  Ir.call(this), this.type = "Path", this.currentPoint = new xe(), t && this.setFromPoints(t);
}
xi.prototype = Object.assign(Object.create(Ir.prototype), {
  constructor: xi,
  setFromPoints: function(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, n = t.length; e < n; e++)
      this.lineTo(t[e].x, t[e].y);
    return this;
  },
  moveTo: function(t, e) {
    return this.currentPoint.set(t, e), this;
  },
  lineTo: function(t, e) {
    const n = new Cn(this.currentPoint.clone(), new xe(t, e));
    return this.curves.push(n), this.currentPoint.set(t, e), this;
  },
  quadraticCurveTo: function(t, e, n, r) {
    const s = new Di(
      this.currentPoint.clone(),
      new xe(t, e),
      new xe(n, r)
    );
    return this.curves.push(s), this.currentPoint.set(n, r), this;
  },
  bezierCurveTo: function(t, e, n, r, s, o) {
    const a = new Pi(
      this.currentPoint.clone(),
      new xe(t, e),
      new xe(n, r),
      new xe(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  },
  splineThru: function(t) {
    const e = [this.currentPoint.clone()].concat(t), n = new Ni(e);
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
  },
  arc: function(t, e, n, r, s, o) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      t + a,
      e + l,
      n,
      r,
      s,
      o
    ), this;
  },
  absarc: function(t, e, n, r, s, o) {
    return this.absellipse(t, e, n, n, r, s, o), this;
  },
  ellipse: function(t, e, n, r, s, o, a, l) {
    const c = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(t + c, e + h, n, r, s, o, a, l), this;
  },
  absellipse: function(t, e, n, r, s, o, a, l) {
    const c = new Gn(t, e, n, r, s, o, a, l);
    if (this.curves.length > 0) {
      const d = c.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  },
  copy: function(t) {
    return Ir.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
  },
  toJSON: function() {
    const t = Ir.prototype.toJSON.call(this);
    return t.currentPoint = this.currentPoint.toArray(), t;
  },
  fromJSON: function(t) {
    return Ir.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
  }
});
function To(t) {
  xi.call(this, t), this.uuid = Xe.generateUUID(), this.type = "Shape", this.holes = [];
}
To.prototype = Object.assign(Object.create(xi.prototype), {
  constructor: To,
  getPointsHoles: function(t) {
    const e = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      e[n] = this.holes[n].getPoints(t);
    return e;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function(t) {
    return {
      shape: this.getPoints(t),
      holes: this.getPointsHoles(t)
    };
  },
  copy: function(t) {
    xi.prototype.copy.call(this, t), this.holes = [];
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const r = t.holes[e];
      this.holes.push(r.clone());
    }
    return this;
  },
  toJSON: function() {
    const t = xi.prototype.toJSON.call(this);
    t.uuid = this.uuid, t.holes = [];
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const r = this.holes[e];
      t.holes.push(r.toJSON());
    }
    return t;
  },
  fromJSON: function(t) {
    xi.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const r = t.holes[e];
      this.holes.push(new xi().fromJSON(r));
    }
    return this;
  }
});
function xt(t, e = 1) {
  Ie.call(this), this.type = "Light", this.color = new De(t), this.intensity = e;
}
xt.prototype = Object.assign(Object.create(Ie.prototype), {
  constructor: xt,
  isLight: !0,
  copy: function(t) {
    return Ie.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
  },
  toJSON: function(t) {
    const e = Ie.prototype.toJSON.call(this, t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
  }
});
function Uv(t, e, n) {
  xt.call(this, t, n), this.type = "HemisphereLight", this.position.copy(Ie.DefaultUp), this.updateMatrix(), this.groundColor = new De(e);
}
Uv.prototype = Object.assign(Object.create(xt.prototype), {
  constructor: Uv,
  isHemisphereLight: !0,
  copy: function(t) {
    return xt.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
  }
});
function sr(t) {
  this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new xe(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ye(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new cu(), this._frameExtents = new xe(1, 1), this._viewportCount = 1, this._viewports = [
    new st(0, 0, 1, 1)
  ];
}
Object.assign(sr.prototype, {
  _projScreenMatrix: new Ye(),
  _lightPositionWorld: new F(),
  _lookTarget: new F(),
  getViewportCount: function() {
    return this._viewportCount;
  },
  getFrustum: function() {
    return this._frustum;
  },
  updateMatrices: function(t) {
    const e = this.camera, n = this.matrix, r = this._projScreenMatrix, s = this._lookTarget, o = this._lightPositionWorld;
    o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), s.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(s), e.updateMatrixWorld(), r.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse);
  },
  getViewport: function(t) {
    return this._viewports[t];
  },
  getFrameExtents: function() {
    return this._frameExtents;
  },
  copy: function(t) {
    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const t = {};
    return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
  }
});
function Ff() {
  sr.call(this, new Pt(50, 1, 0.5, 500)), this.focus = 1;
}
Ff.prototype = Object.assign(Object.create(sr.prototype), {
  constructor: Ff,
  isSpotLightShadow: !0,
  updateMatrices: function(t) {
    const e = this.camera, n = Xe.RAD2DEG * 2 * t.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = t.distance || e.far;
    (n !== e.fov || r !== e.aspect || s !== e.far) && (e.fov = n, e.aspect = r, e.far = s, e.updateProjectionMatrix()), sr.prototype.updateMatrices.call(this, t);
  }
});
function Hv(t, e, n, r, s, o) {
  xt.call(this, t, e), this.type = "SpotLight", this.position.copy(Ie.DefaultUp), this.updateMatrix(), this.target = new Ie(), Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(a) {
      this.intensity = a / Math.PI;
    }
  }), this.distance = n !== void 0 ? n : 0, this.angle = r !== void 0 ? r : Math.PI / 3, this.penumbra = s !== void 0 ? s : 0, this.decay = o !== void 0 ? o : 1, this.shadow = new Ff();
}
Hv.prototype = Object.assign(Object.create(xt.prototype), {
  constructor: Hv,
  isSpotLight: !0,
  copy: function(t) {
    return xt.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
});
function Bf() {
  sr.call(this, new Pt(90, 1, 0.5, 500)), this._frameExtents = new xe(4, 2), this._viewportCount = 6, this._viewports = [
    // These viewports map a cube-map onto a 2D texture with the
    // following orientation:
    //
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction
    // positive X
    new st(2, 1, 1, 1),
    // negative X
    new st(0, 1, 1, 1),
    // positive Z
    new st(3, 1, 1, 1),
    // negative Z
    new st(1, 1, 1, 1),
    // positive Y
    new st(3, 0, 1, 1),
    // negative Y
    new st(1, 0, 1, 1)
  ], this._cubeDirections = [
    new F(1, 0, 0),
    new F(-1, 0, 0),
    new F(0, 0, 1),
    new F(0, 0, -1),
    new F(0, 1, 0),
    new F(0, -1, 0)
  ], this._cubeUps = [
    new F(0, 1, 0),
    new F(0, 1, 0),
    new F(0, 1, 0),
    new F(0, 1, 0),
    new F(0, 0, 1),
    new F(0, 0, -1)
  ];
}
Bf.prototype = Object.assign(Object.create(sr.prototype), {
  constructor: Bf,
  isPointLightShadow: !0,
  updateMatrices: function(t, e = 0) {
    const n = this.camera, r = this.matrix, s = this._lightPositionWorld, o = this._lookTarget, a = this._projScreenMatrix;
    s.setFromMatrixPosition(t.matrixWorld), n.position.copy(s), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), r.makeTranslation(-s.x, -s.y, -s.z), a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(a);
  }
});
function Gv(t, e, n, r) {
  xt.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(s) {
      this.intensity = s / (4 * Math.PI);
    }
  }), this.distance = n !== void 0 ? n : 0, this.decay = r !== void 0 ? r : 1, this.shadow = new Bf();
}
Gv.prototype = Object.assign(Object.create(xt.prototype), {
  constructor: Gv,
  isPointLight: !0,
  copy: function(t) {
    return xt.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
  }
});
function kh(t = -1, e = 1, n = 1, r = -1, s = 0.1, o = 2e3) {
  er.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix();
}
kh.prototype = Object.assign(Object.create(er.prototype), {
  constructor: kh,
  isOrthographicCamera: !0,
  copy: function(t, e) {
    return er.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  },
  setViewOffset: function(t, e, n, r, s, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = n - t, o = n + t, a = r + e, l = r - e;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += c * this.view.offsetX, o = s + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(t) {
    const e = Ie.prototype.toJSON.call(this, t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
});
function zf() {
  sr.call(this, new kh(-5, 5, 5, -5, 0.5, 500));
}
zf.prototype = Object.assign(Object.create(sr.prototype), {
  constructor: zf,
  isDirectionalLightShadow: !0,
  updateMatrices: function(t) {
    sr.prototype.updateMatrices.call(this, t);
  }
});
function Vv(t, e) {
  xt.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Ie.DefaultUp), this.updateMatrix(), this.target = new Ie(), this.shadow = new zf();
}
Vv.prototype = Object.assign(Object.create(xt.prototype), {
  constructor: Vv,
  isDirectionalLight: !0,
  copy: function(t) {
    return xt.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
});
function kv(t, e) {
  xt.call(this, t, e), this.type = "AmbientLight";
}
kv.prototype = Object.assign(Object.create(xt.prototype), {
  constructor: kv,
  isAmbientLight: !0
});
function Wv(t, e, n, r) {
  xt.call(this, t, e), this.type = "RectAreaLight", this.width = n !== void 0 ? n : 10, this.height = r !== void 0 ? r : 10;
}
Wv.prototype = Object.assign(Object.create(xt.prototype), {
  constructor: Wv,
  isRectAreaLight: !0,
  copy: function(t) {
    return xt.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
  },
  toJSON: function(t) {
    const e = xt.prototype.toJSON.call(this, t);
    return e.object.width = this.width, e.object.height = this.height, e;
  }
});
class rP {
  constructor() {
    Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }), this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new F());
  }
  set(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].copy(e[n]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, n) {
    const r = e.x, s = e.y, o = e.z, a = this.coefficients;
    return n.copy(a[0]).multiplyScalar(0.282095), n.addScaledVector(a[1], 0.488603 * s), n.addScaledVector(a[2], 0.488603 * o), n.addScaledVector(a[3], 0.488603 * r), n.addScaledVector(a[4], 1.092548 * (r * s)), n.addScaledVector(a[5], 1.092548 * (s * o)), n.addScaledVector(a[6], 0.315392 * (3 * o * o - 1)), n.addScaledVector(a[7], 1.092548 * (r * o)), n.addScaledVector(a[8], 0.546274 * (r * r - s * s)), n;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, n) {
    const r = e.x, s = e.y, o = e.z, a = this.coefficients;
    return n.copy(a[0]).multiplyScalar(0.886227), n.addScaledVector(a[1], 2 * 0.511664 * s), n.addScaledVector(a[2], 2 * 0.511664 * o), n.addScaledVector(a[3], 2 * 0.511664 * r), n.addScaledVector(a[4], 2 * 0.429043 * r * s), n.addScaledVector(a[5], 2 * 0.429043 * s * o), n.addScaledVector(a[6], 0.743125 * o * o - 0.247708), n.addScaledVector(a[7], 2 * 0.429043 * r * o), n.addScaledVector(a[8], 0.429043 * (r * r - s * s)), n;
  }
  add(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].add(e.coefficients[n]);
    return this;
  }
  addScaledSH(e, n) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], n);
    return this;
  }
  scale(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].multiplyScalar(e);
    return this;
  }
  lerp(e, n) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].lerp(e.coefficients[r], n);
    return this;
  }
  equals(e) {
    for (let n = 0; n < 9; n++)
      if (!this.coefficients[n].equals(e.coefficients[n]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, n = 0) {
    const r = this.coefficients;
    for (let s = 0; s < 9; s++)
      r[s].fromArray(e, n + s * 3);
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.coefficients;
    for (let s = 0; s < 9; s++)
      r[s].toArray(e, n + s * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, n) {
    const r = e.x, s = e.y, o = e.z;
    n[0] = 0.282095, n[1] = 0.488603 * s, n[2] = 0.488603 * o, n[3] = 0.488603 * r, n[4] = 1.092548 * r * s, n[5] = 1.092548 * s * o, n[6] = 0.315392 * (3 * o * o - 1), n[7] = 1.092548 * r * o, n[8] = 0.546274 * (r * r - s * s);
  }
}
function bi(t, e) {
  xt.call(this, void 0, e), this.type = "LightProbe", this.sh = t !== void 0 ? t : new rP();
}
bi.prototype = Object.assign(Object.create(xt.prototype), {
  constructor: bi,
  isLightProbe: !0,
  copy: function(t) {
    return xt.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
  },
  fromJSON: function(t) {
    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
  },
  toJSON: function(t) {
    const e = xt.prototype.toJSON.call(this, t);
    return e.object.sh = this.sh.toArray(), e;
  }
});
function $v(t) {
  pt.call(this, t), this.textures = {};
}
$v.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: $v,
  load: function(t, e, n, r) {
    const s = this, o = new nr(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      try {
        e(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  },
  parse: function(t) {
    const e = this.textures;
    function n(s) {
      return e[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), e[s];
    }
    const r = new $R[t.type]();
    if (t.uuid !== void 0 && (r.uuid = t.uuid), t.name !== void 0 && (r.name = t.name), t.color !== void 0 && r.color !== void 0 && r.color.setHex(t.color), t.roughness !== void 0 && (r.roughness = t.roughness), t.metalness !== void 0 && (r.metalness = t.metalness), t.sheen !== void 0 && (r.sheen = new De().setHex(t.sheen)), t.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(t.emissive), t.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(t.specular), t.shininess !== void 0 && (r.shininess = t.shininess), t.clearcoat !== void 0 && (r.clearcoat = t.clearcoat), t.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = t.clearcoatRoughness), t.fog !== void 0 && (r.fog = t.fog), t.flatShading !== void 0 && (r.flatShading = t.flatShading), t.blending !== void 0 && (r.blending = t.blending), t.combine !== void 0 && (r.combine = t.combine), t.side !== void 0 && (r.side = t.side), t.opacity !== void 0 && (r.opacity = t.opacity), t.transparent !== void 0 && (r.transparent = t.transparent), t.alphaTest !== void 0 && (r.alphaTest = t.alphaTest), t.depthTest !== void 0 && (r.depthTest = t.depthTest), t.depthWrite !== void 0 && (r.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (r.colorWrite = t.colorWrite), t.stencilWrite !== void 0 && (r.stencilWrite = t.stencilWrite), t.stencilWriteMask !== void 0 && (r.stencilWriteMask = t.stencilWriteMask), t.stencilFunc !== void 0 && (r.stencilFunc = t.stencilFunc), t.stencilRef !== void 0 && (r.stencilRef = t.stencilRef), t.stencilFuncMask !== void 0 && (r.stencilFuncMask = t.stencilFuncMask), t.stencilFail !== void 0 && (r.stencilFail = t.stencilFail), t.stencilZFail !== void 0 && (r.stencilZFail = t.stencilZFail), t.stencilZPass !== void 0 && (r.stencilZPass = t.stencilZPass), t.wireframe !== void 0 && (r.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (r.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (r.rotation = t.rotation), t.linewidth !== 1 && (r.linewidth = t.linewidth), t.dashSize !== void 0 && (r.dashSize = t.dashSize), t.gapSize !== void 0 && (r.gapSize = t.gapSize), t.scale !== void 0 && (r.scale = t.scale), t.polygonOffset !== void 0 && (r.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = t.polygonOffsetUnits), t.skinning !== void 0 && (r.skinning = t.skinning), t.morphTargets !== void 0 && (r.morphTargets = t.morphTargets), t.morphNormals !== void 0 && (r.morphNormals = t.morphNormals), t.dithering !== void 0 && (r.dithering = t.dithering), t.vertexTangents !== void 0 && (r.vertexTangents = t.vertexTangents), t.visible !== void 0 && (r.visible = t.visible), t.toneMapped !== void 0 && (r.toneMapped = t.toneMapped), t.userData !== void 0 && (r.userData = t.userData), t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors), t.uniforms !== void 0)
      for (const s in t.uniforms) {
        const o = t.uniforms[s];
        switch (r.uniforms[s] = {}, o.type) {
          case "t":
            r.uniforms[s].value = n(o.value);
            break;
          case "c":
            r.uniforms[s].value = new De().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new xe().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new F().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new st().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new hn().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new Ye().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (t.defines !== void 0 && (r.defines = t.defines), t.vertexShader !== void 0 && (r.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (r.fragmentShader = t.fragmentShader), t.extensions !== void 0)
      for (const s in t.extensions)
        r.extensions[s] = t.extensions[s];
    if (t.shading !== void 0 && (r.flatShading = t.shading === 1), t.size !== void 0 && (r.size = t.size), t.sizeAttenuation !== void 0 && (r.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (r.map = n(t.map)), t.matcap !== void 0 && (r.matcap = n(t.matcap)), t.alphaMap !== void 0 && (r.alphaMap = n(t.alphaMap)), t.bumpMap !== void 0 && (r.bumpMap = n(t.bumpMap)), t.bumpScale !== void 0 && (r.bumpScale = t.bumpScale), t.normalMap !== void 0 && (r.normalMap = n(t.normalMap)), t.normalMapType !== void 0 && (r.normalMapType = t.normalMapType), t.normalScale !== void 0) {
      let s = t.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new xe().fromArray(s);
    }
    return t.displacementMap !== void 0 && (r.displacementMap = n(t.displacementMap)), t.displacementScale !== void 0 && (r.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (r.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (r.roughnessMap = n(t.roughnessMap)), t.metalnessMap !== void 0 && (r.metalnessMap = n(t.metalnessMap)), t.emissiveMap !== void 0 && (r.emissiveMap = n(t.emissiveMap)), t.emissiveIntensity !== void 0 && (r.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (r.specularMap = n(t.specularMap)), t.envMap !== void 0 && (r.envMap = n(t.envMap)), t.envMapIntensity !== void 0 && (r.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (r.reflectivity = t.reflectivity), t.refractionRatio !== void 0 && (r.refractionRatio = t.refractionRatio), t.lightMap !== void 0 && (r.lightMap = n(t.lightMap)), t.lightMapIntensity !== void 0 && (r.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (r.aoMap = n(t.aoMap)), t.aoMapIntensity !== void 0 && (r.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (r.gradientMap = n(t.gradientMap)), t.clearcoatMap !== void 0 && (r.clearcoatMap = n(t.clearcoatMap)), t.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), t.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(t.clearcoatNormalMap)), t.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new xe().fromArray(t.clearcoatNormalScale)), t.transmission !== void 0 && (r.transmission = t.transmission), t.transmissionMap !== void 0 && (r.transmissionMap = n(t.transmissionMap)), r;
  },
  setTextures: function(t) {
    return this.textures = t, this;
  }
});
const sP = {
  decodeText: function(t) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(t);
    let e = "";
    for (let n = 0, r = t.length; n < r; n++)
      e += String.fromCharCode(t[n]);
    try {
      return decodeURIComponent(escape(e));
    } catch {
      return e;
    }
  },
  extractUrlBase: function(t) {
    const e = t.lastIndexOf("/");
    return e === -1 ? "./" : t.substr(0, e + 1);
  }
};
function Yo() {
  ot.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
}
Yo.prototype = Object.assign(Object.create(ot.prototype), {
  constructor: Yo,
  isInstancedBufferGeometry: !0,
  copy: function(t) {
    return ot.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const t = ot.prototype.toJSON.call(this);
    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t;
  }
});
function Uf(t, e, n, r) {
  typeof n == "number" && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), qe.call(this, t, e, n), this.meshPerAttribute = r || 1;
}
Uf.prototype = Object.assign(Object.create(qe.prototype), {
  constructor: Uf,
  isInstancedBufferAttribute: !0,
  copy: function(t) {
    return qe.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
  },
  toJSON: function() {
    const t = qe.prototype.toJSON.call(this);
    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
  }
});
function jv(t) {
  pt.call(this, t);
}
jv.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: jv,
  load: function(t, e, n, r) {
    const s = this, o = new nr(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      try {
        e(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  },
  parse: function(t) {
    const e = {}, n = {};
    function r(p, f) {
      if (e[f] !== void 0) return e[f];
      const y = p.interleavedBuffers[f], x = s(p, y.buffer), v = Nc(y.type, x), g = new In(v, y.stride);
      return g.uuid = y.uuid, e[f] = g, g;
    }
    function s(p, f) {
      if (n[f] !== void 0) return n[f];
      const y = p.arrayBuffers[f], x = new Uint32Array(y).buffer;
      return n[f] = x, x;
    }
    const o = t.isInstancedBufferGeometry ? new Yo() : new ot(), a = t.data.index;
    if (a !== void 0) {
      const p = Nc(a.type, a.array);
      o.setIndex(new qe(p, 1));
    }
    const l = t.data.attributes;
    for (const p in l) {
      const f = l[p];
      let m;
      if (f.isInterleavedBufferAttribute) {
        const y = r(t.data, f.data);
        m = new _n(y, f.itemSize, f.offset, f.normalized);
      } else {
        const y = Nc(f.type, f.array), x = f.isInstancedBufferAttribute ? Uf : qe;
        m = new x(y, f.itemSize, f.normalized);
      }
      f.name !== void 0 && (m.name = f.name), o.setAttribute(p, m);
    }
    const c = t.data.morphAttributes;
    if (c)
      for (const p in c) {
        const f = c[p], m = [];
        for (let y = 0, x = f.length; y < x; y++) {
          const v = f[y];
          let g;
          if (v.isInterleavedBufferAttribute) {
            const S = r(t.data, v.data);
            g = new _n(S, v.itemSize, v.offset, v.normalized);
          } else {
            const S = Nc(v.type, v.array);
            g = new qe(S, v.itemSize, v.normalized);
          }
          v.name !== void 0 && (g.name = v.name), m.push(g);
        }
        o.morphAttributes[p] = m;
      }
    t.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = t.data.groups || t.data.drawcalls || t.data.offsets;
    if (d !== void 0)
      for (let p = 0, f = d.length; p !== f; ++p) {
        const m = d[p];
        o.addGroup(m.start, m.count, m.materialIndex);
      }
    const u = t.data.boundingSphere;
    if (u !== void 0) {
      const p = new F();
      u.center !== void 0 && p.fromArray(u.center), o.boundingSphere = new Oi(p, u.radius);
    }
    return t.name && (o.name = t.name), t.userData && (o.userData = t.userData), o;
  }
});
function qv(t) {
  typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), pt.call(this, t), this.options = { premultiplyAlpha: "none" };
}
qv.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: qv,
  isImageBitmapLoader: !0,
  setOptions: function(e) {
    return this.options = e, this;
  },
  load: function(t, e, n, r) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const s = this, o = Xo.get(t);
    if (o !== void 0)
      return s.manager.itemStart(t), setTimeout(function() {
        e && e(o), s.manager.itemEnd(t);
      }, 0), o;
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", fetch(t, a).then(function(l) {
      return l.blob();
    }).then(function(l) {
      return createImageBitmap(l, s.options);
    }).then(function(l) {
      Xo.add(t, l), e && e(l), s.manager.itemEnd(t);
    }).catch(function(l) {
      r && r(l), s.manager.itemError(t), s.manager.itemEnd(t);
    }), s.manager.itemStart(t);
  }
});
function Ax() {
  this.type = "ShapePath", this.color = new De(), this.subPaths = [], this.currentPath = null;
}
Object.assign(Ax.prototype, {
  moveTo: function(t, e) {
    return this.currentPath = new xi(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
  },
  lineTo: function(t, e) {
    return this.currentPath.lineTo(t, e), this;
  },
  quadraticCurveTo: function(t, e, n, r) {
    return this.currentPath.quadraticCurveTo(t, e, n, r), this;
  },
  bezierCurveTo: function(t, e, n, r, s, o) {
    return this.currentPath.bezierCurveTo(t, e, n, r, s, o), this;
  },
  splineThru: function(t) {
    return this.currentPath.splineThru(t), this;
  },
  toShapes: function(t, e) {
    function n(v) {
      const g = [];
      for (let S = 0, T = v.length; S < T; S++) {
        const E = v[S], w = new To();
        w.curves = E.curves, g.push(w);
      }
      return g;
    }
    function r(v, g) {
      const S = g.length;
      let T = !1;
      for (let E = S - 1, w = 0; w < S; E = w++) {
        let C = g[E], ee = g[w], Y = ee.x - C.x, le = ee.y - C.y;
        if (Math.abs(le) > Number.EPSILON) {
          if (le < 0 && (C = g[w], Y = -Y, ee = g[E], le = -le), v.y < C.y || v.y > ee.y) continue;
          if (v.y === C.y) {
            if (v.x === C.x) return !0;
          } else {
            const B = le * (v.x - C.x) - Y * (v.y - C.y);
            if (B === 0) return !0;
            if (B < 0) continue;
            T = !T;
          }
        } else {
          if (v.y !== C.y) continue;
          if (ee.x <= v.x && v.x <= C.x || C.x <= v.x && v.x <= ee.x) return !0;
        }
      }
      return T;
    }
    const s = Ur.isClockWise, o = this.subPaths;
    if (o.length === 0) return [];
    if (e === !0) return n(o);
    let a, l, c;
    const h = [];
    if (o.length === 1)
      return l = o[0], c = new To(), c.curves = l.curves, h.push(c), h;
    let d = !s(o[0].getPoints());
    d = t ? !d : d;
    const u = [], p = [];
    let f = [], m = 0, y;
    p[m] = void 0, f[m] = [];
    for (let v = 0, g = o.length; v < g; v++)
      l = o[v], y = l.getPoints(), a = s(y), a = t ? !a : a, a ? (!d && p[m] && m++, p[m] = { s: new To(), p: y }, p[m].s.curves = l.curves, d && m++, f[m] = []) : f[m].push({ h: l, p: y[0] });
    if (!p[0]) return n(o);
    if (p.length > 1) {
      let v = !1;
      const g = [];
      for (let S = 0, T = p.length; S < T; S++)
        u[S] = [];
      for (let S = 0, T = p.length; S < T; S++) {
        const E = f[S];
        for (let w = 0; w < E.length; w++) {
          const C = E[w];
          let ee = !0;
          for (let Y = 0; Y < p.length; Y++)
            r(C.p, p[Y].p) && (S !== Y && g.push({ froms: S, tos: Y, hole: w }), ee ? (ee = !1, u[Y].push(C)) : v = !0);
          ee && u[S].push(C);
        }
      }
      g.length > 0 && (v || (f = u));
    }
    let x;
    for (let v = 0, g = p.length; v < g; v++) {
      c = p[v].s, h.push(c), x = f[v];
      for (let S = 0, T = x.length; S < T; S++)
        c.holes.push(x[S].h);
    }
    return h;
  }
});
function Lx(t) {
  this.type = "Font", this.data = t;
}
Object.assign(Lx.prototype, {
  isFont: !0,
  generateShapes: function(t, e = 100) {
    const n = [], r = oP(t, e, this.data);
    for (let s = 0, o = r.length; s < o; s++)
      Array.prototype.push.apply(n, r[s].toShapes());
    return n;
  }
});
function oP(t, e, n) {
  const r = Array.from ? Array.from(t) : String(t).split(""), s = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * s, a = [];
  let l = 0, c = 0;
  for (let h = 0; h < r.length; h++) {
    const d = r[h];
    if (d === `
`)
      l = 0, c -= o;
    else {
      const u = aP(d, s, l, c, n);
      l += u.offsetX, a.push(u.path);
    }
  }
  return a;
}
function aP(t, e, n, r, s) {
  const o = s.glyphs[t] || s.glyphs["?"];
  if (!o) {
    console.error('THREE.Font: character "' + t + '" does not exists in font family ' + s.familyName + ".");
    return;
  }
  const a = new Ax();
  let l, c, h, d, u, p, f, m;
  if (o.o) {
    const y = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
    for (let x = 0, v = y.length; x < v; )
      switch (y[x++]) {
        case "m":
          l = y[x++] * e + n, c = y[x++] * e + r, a.moveTo(l, c);
          break;
        case "l":
          l = y[x++] * e + n, c = y[x++] * e + r, a.lineTo(l, c);
          break;
        case "q":
          h = y[x++] * e + n, d = y[x++] * e + r, u = y[x++] * e + n, p = y[x++] * e + r, a.quadraticCurveTo(u, p, h, d);
          break;
        case "b":
          h = y[x++] * e + n, d = y[x++] * e + r, u = y[x++] * e + n, p = y[x++] * e + r, f = y[x++] * e + n, m = y[x++] * e + r, a.bezierCurveTo(u, p, f, m, h, d);
          break;
      }
  }
  return { offsetX: o.ha * e, path: a };
}
function Xv(t) {
  pt.call(this, t);
}
Xv.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Xv,
  load: function(t, e, n, r) {
    const s = this, o = new nr(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      let l;
      try {
        l = JSON.parse(a);
      } catch {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), l = JSON.parse(a.substring(65, a.length - 2));
      }
      const c = s.parse(l);
      e && e(c);
    }, n, r);
  },
  parse: function(t) {
    return new Lx(t);
  }
});
let nh;
const lP = {
  getContext: function() {
    return nh === void 0 && (nh = new (window.AudioContext || window.webkitAudioContext)()), nh;
  },
  setContext: function(t) {
    nh = t;
  }
};
function Yv(t) {
  pt.call(this, t);
}
Yv.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Yv,
  load: function(t, e, n, r) {
    const s = this, o = new nr(s.manager);
    o.setResponseType("arraybuffer"), o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function(a) {
      try {
        const l = a.slice(0);
        lP.getContext().decodeAudioData(l, function(h) {
          e(h);
        });
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  }
});
function Zv(t, e, n) {
  bi.call(this, void 0, n);
  const r = new De().set(t), s = new De().set(e), o = new F(r.r, r.g, r.b), a = new F(s.r, s.g, s.b), l = Math.sqrt(Math.PI), c = l * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
}
Zv.prototype = Object.assign(Object.create(bi.prototype), {
  constructor: Zv,
  isHemisphereLightProbe: !0,
  copy: function(t) {
    return bi.prototype.copy.call(this, t), this;
  },
  toJSON: function(t) {
    return bi.prototype.toJSON.call(this, t);
  }
});
function Jv(t, e) {
  bi.call(this, void 0, e);
  const n = new De().set(t);
  this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
Jv.prototype = Object.assign(Object.create(bi.prototype), {
  constructor: Jv,
  isAmbientLightProbe: !0,
  copy: function(t) {
    return bi.prototype.copy.call(this, t), this;
  },
  toJSON: function(t) {
    return bi.prototype.toJSON.call(this, t);
  }
});
const Kv = new Ye(), Qv = new Ye();
function cP() {
  this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Pt(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Pt(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}
Object.assign(cP.prototype, {
  update: function(t) {
    const e = this._cache;
    if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
      e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
      const r = t.projectionMatrix.clone(), s = e.eyeSep / 2, o = s * e.near / e.focus, a = e.near * Math.tan(Xe.DEG2RAD * e.fov * 0.5) / e.zoom;
      let l, c;
      Qv.elements[12] = -s, Kv.elements[12] = s, l = -a * e.aspect + o, c = a * e.aspect + o, r.elements[0] = 2 * e.near / (c - l), r.elements[8] = (c + l) / (c - l), this.cameraL.projectionMatrix.copy(r), l = -a * e.aspect - o, c = a * e.aspect - o, r.elements[0] = 2 * e.near / (c - l), r.elements[8] = (c + l) / (c - l), this.cameraR.projectionMatrix.copy(r);
    }
    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Qv), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Kv);
  }
});
function Cx(t, e, n) {
  this.binding = t, this.valueSize = n;
  let r, s, o;
  switch (e) {
    case "quaternion":
      r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
      break;
    case "string":
    case "bool":
      r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
      break;
    default:
      r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
  }
  this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
}
Object.assign(Cx.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function(t, e) {
    const n = this.buffer, r = this.valueSize, s = t * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a)
        n[s + a] = n[a];
      o = e;
    } else {
      o += e;
      const a = e / o;
      this._mixBufferRegion(n, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  },
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive: function(t) {
    const e = this.buffer, n = this.valueSize, r = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function(t) {
    const e = this.valueSize, n = this.buffer, r = t * e + e, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = e * this._origIndex;
      this._mixBufferRegion(
        n,
        r,
        l,
        1 - s,
        e
      );
    }
    o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
    for (let l = e, c = e + e; l !== c; ++l)
      if (n[l] !== n[l + e]) {
        a.setValue(n, r);
        break;
      }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function() {
    const t = this.binding, e = this.buffer, n = this.valueSize, r = n * this._origIndex;
    t.getValue(e, r);
    for (let s = n, o = r; s !== o; ++s)
      e[s] = e[r + s % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function() {
    const t = this.valueSize * 3;
    this.binding.setValue(this.buffer, t);
  },
  _setAdditiveIdentityNumeric: function() {
    const t = this._addIndex * this.valueSize, e = t + this.valueSize;
    for (let n = t; n < e; n++)
      this.buffer[n] = 0;
  },
  _setAdditiveIdentityQuaternion: function() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  },
  _setAdditiveIdentityOther: function() {
    const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n];
  },
  // mix functions
  _select: function(t, e, n, r, s) {
    if (r >= 0.5)
      for (let o = 0; o !== s; ++o)
        t[e + o] = t[n + o];
  },
  _slerp: function(t, e, n, r) {
    Mn.slerpFlat(t, e, t, e, t, n, r);
  },
  _slerpAdditive: function(t, e, n, r, s) {
    const o = this._workIndex * s;
    Mn.multiplyQuaternionsFlat(t, o, t, e, t, n), Mn.slerpFlat(t, e, t, e, t, o, r);
  },
  _lerp: function(t, e, n, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = e + a;
      t[l] = t[l] * o + t[n + a] * r;
    }
  },
  _lerpAdditive: function(t, e, n, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = e + o;
      t[a] = t[a] + t[n + o] * r;
    }
  }
});
const pp = "\\[\\]\\.:\\/", hP = new RegExp("[" + pp + "]", "g"), mp = "[^" + pp + "]", uP = "[^" + pp.replace("\\.", "") + "]", dP = /((?:WC+[\/:])*)/.source.replace("WC", mp), fP = /(WCOD+)?/.source.replace("WCOD", uP), pP = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", mp), mP = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", mp), gP = new RegExp(
  "^" + dP + fP + pP + mP + "$"
), vP = ["material", "materials", "bones"];
function Rx(t, e, n) {
  const r = n || nn.parseTrackName(e);
  this._targetGroup = t, this._bindings = t.subscribe_(e, r);
}
Object.assign(Rx.prototype, {
  getValue: function(t, e) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, r = this._bindings[n];
    r !== void 0 && r.getValue(t, e);
  },
  setValue: function(t, e) {
    const n = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = n.length; r !== s; ++r)
      n[r].setValue(t, e);
  },
  bind: function() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind();
  },
  unbind: function() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind();
  }
});
function nn(t, e, n) {
  this.path = e, this.parsedPath = n || nn.parseTrackName(e), this.node = nn.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
}
Object.assign(nn, {
  Composite: Rx,
  create: function(t, e, n) {
    return t && t.isAnimationObjectGroup ? new nn.Composite(t, e, n) : new nn(t, e, n);
  },
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function(t) {
    return t.replace(/\s/g, "_").replace(hP, "");
  },
  parseTrackName: function(t) {
    const e = gP.exec(t);
    if (!e)
      throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: e[2],
      objectName: e[3],
      objectIndex: e[4],
      propertyName: e[5],
      // required
      propertyIndex: e[6]
    }, r = n.nodeName && n.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = n.nodeName.substring(r + 1);
      vP.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
    return n;
  },
  findNode: function(t, e) {
    if (!e || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid)
      return t;
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e);
      if (n !== void 0)
        return n;
    }
    if (t.children) {
      const n = function(s) {
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          if (a.name === e || a.uuid === e)
            return a;
          const l = n(a.children);
          if (l) return l;
        }
        return null;
      }, r = n(t.children);
      if (r)
        return r;
    }
    return null;
  }
});
Object.assign(nn.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function(e, n) {
      e[n] = this.node[this.propertyName];
    },
    function(e, n) {
      const r = this.resolvedProperty;
      for (let s = 0, o = r.length; s !== o; ++s)
        e[n++] = r[s];
    },
    function(e, n) {
      e[n] = this.resolvedProperty[this.propertyIndex];
    },
    function(e, n) {
      this.resolvedProperty.toArray(e, n);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      // Direct
      function(e, n) {
        this.targetObject[this.propertyName] = e[n];
      },
      function(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // EntireArray
      function(e, n) {
        const r = this.resolvedProperty;
        for (let s = 0, o = r.length; s !== o; ++s)
          r[s] = e[n++];
      },
      function(e, n) {
        const r = this.resolvedProperty;
        for (let s = 0, o = r.length; s !== o; ++s)
          r[s] = e[n++];
        this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        const r = this.resolvedProperty;
        for (let s = 0, o = r.length; s !== o; ++s)
          r[s] = e[n++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // ArrayElement
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n];
      },
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // HasToFromArray
      function(e, n) {
        this.resolvedProperty.fromArray(e, n);
      },
      function(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0;
      },
      function(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ]
  ],
  getValue: function(e, n) {
    this.bind(), this.getValue(e, n);
  },
  setValue: function(e, n) {
    this.bind(), this.setValue(e, n);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function() {
    let t = this.node;
    const e = this.parsedPath, n = e.objectName, r = e.propertyName;
    let s = e.propertyIndex;
    if (t || (t = nn.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (n) {
      let c = e.objectIndex;
      switch (n) {
        case "materials":
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          t = t.skeleton.bones;
          for (let h = 0; h < t.length; h++)
            if (t[h].name === c) {
              c = h;
              break;
            }
          break;
        default:
          if (t[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          t = t[n];
      }
      if (c !== void 0) {
        if (t[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          return;
        }
        t = t[c];
      }
    }
    const o = t[r];
    if (o === void 0) {
      const c = e.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", t);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = t, t.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (t.geometry.isBufferGeometry) {
          if (!t.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          t.morphTargetDictionary[s] !== void 0 && (s = t.morphTargetDictionary[s]);
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  },
  unbind: function() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
});
Object.assign(nn.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: nn.prototype.getValue,
  _setValue_unbound: nn.prototype.setValue
});
function yP() {
  this.uuid = Xe.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
  const t = {};
  this._indicesByUUID = t;
  for (let n = 0, r = arguments.length; n !== r; ++n)
    t[arguments[n].uuid] = n;
  this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
  const e = this;
  this.stats = {
    objects: {
      get total() {
        return e._objects.length;
      },
      get inUse() {
        return this.total - e.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return e._bindings.length;
    }
  };
}
Object.assign(yP.prototype, {
  isAnimationObjectGroup: !0,
  add: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length;
    let a, l = t.length, c = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const u = arguments[h], p = u.uuid;
      let f = e[p];
      if (f === void 0) {
        f = l++, e[p] = f, t.push(u);
        for (let m = 0, y = o; m !== y; ++m)
          s[m].push(new nn(u, n[m], r[m]));
      } else if (f < c) {
        a = t[f];
        const m = --c, y = t[m];
        e[y.uuid] = f, t[f] = y, e[p] = m, t[m] = u;
        for (let x = 0, v = o; x !== v; ++x) {
          const g = s[x], S = g[m];
          let T = g[f];
          g[f] = S, T === void 0 && (T = new nn(u, n[x], r[x])), g[m] = T;
        }
      } else t[f] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  },
  remove: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._bindings, r = n.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o], c = l.uuid, h = e[c];
      if (h !== void 0 && h >= s) {
        const d = s++, u = t[d];
        e[u.uuid] = h, t[h] = u, e[c] = d, t[d] = l;
        for (let p = 0, f = r; p !== f; ++p) {
          const m = n[p], y = m[d], x = m[h];
          m[h] = y, m[d] = x;
        }
      }
    }
    this.nCachedObjects_ = s;
  },
  // remove & forget
  uncache: function() {
    const t = this._objects, e = this._indicesByUUID, n = this._bindings, r = n.length;
    let s = this.nCachedObjects_, o = t.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a], h = c.uuid, d = e[h];
      if (d !== void 0)
        if (delete e[h], d < s) {
          const u = --s, p = t[u], f = --o, m = t[f];
          e[p.uuid] = d, t[d] = p, e[m.uuid] = u, t[u] = m, t.pop();
          for (let y = 0, x = r; y !== x; ++y) {
            const v = n[y], g = v[u], S = v[f];
            v[d] = g, v[u] = S, v.pop();
          }
        } else {
          const u = --o, p = t[u];
          u > 0 && (e[p.uuid] = d), t[d] = p, t.pop();
          for (let f = 0, m = r; f !== m; ++f) {
            const y = n[f];
            y[d] = y[u], y.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function(t, e) {
    const n = this._bindingsIndicesByPath;
    let r = n[t];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, h = this.nCachedObjects_, d = new Array(c);
    r = s.length, n[t] = r, o.push(t), a.push(e), s.push(d);
    for (let u = h, p = l.length; u !== p; ++u) {
      const f = l[u];
      d[u] = new nn(f, t, e);
    }
    return d;
  },
  unsubscribe_: function(t) {
    const e = this._bindingsIndicesByPath, n = e[t];
    if (n !== void 0) {
      const r = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], c = t[a];
      e[c] = n, o[n] = l, o.pop(), s[n] = s[a], s.pop(), r[n] = r[a], r.pop();
    }
  }
});
class xP {
  constructor(e, n, r = null, s = n.blendMode) {
    this._mixer = e, this._clip = n, this._localRoot = r, this.blendMode = s;
    const o = n.tracks, a = o.length, l = new Array(a), c = {
      endingStart: go,
      endingEnd: go
    };
    for (let h = 0; h !== a; ++h) {
      const d = o[h].createInterpolant(null);
      l[h] = d, d.settings = c;
    }
    this._interpolantSettings = c, this._interpolants = l, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = VA, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, n) {
    return this.loop = e, this.repetitions = n, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, n, r) {
    if (e.fadeOut(n), this.fadeIn(n), r) {
      const s = this._clip.duration, o = e._clip.duration, a = o / s, l = s / o;
      e.warp(1, a, n), this.warp(l, 1, n);
    }
    return this;
  }
  crossFadeTo(e, n, r) {
    return e.crossFadeFrom(this, n, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, n, r) {
    const s = this._mixer, o = s.time, a = this.timeScale;
    let l = this._timeScaleInterpolant;
    l === null && (l = s._lendControlInterpolant(), this._timeScaleInterpolant = l);
    const c = l.parameterPositions, h = l.sampleValues;
    return c[0] = o, c[1] = o + r, h[0] = e / a, h[1] = n / a, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, n, r, s) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const c = (e - o) * r;
      if (c < 0 || r === 0)
        return;
      this._startTime = null, n = r * c;
    }
    n *= this._updateTimeScale(e);
    const a = this._updateTime(n), l = this._updateWeight(e);
    if (l > 0) {
      const c = this._interpolants, h = this._propertyBindings;
      switch (this.blendMode) {
        case rx:
          for (let d = 0, u = c.length; d !== u; ++d)
            c[d].evaluate(a), h[d].accumulateAdditive(l);
          break;
        case hp:
        default:
          for (let d = 0, u = c.length; d !== u; ++d)
            c[d].evaluate(a), h[d].accumulate(s, l);
      }
    }
  }
  _updateWeight(e) {
    let n = 0;
    if (this.enabled) {
      n = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const s = r.evaluate(e)[0];
        n *= s, e > r.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = n, n;
  }
  _updateTimeScale(e) {
    let n = 0;
    if (!this.paused) {
      n = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const s = r.evaluate(e)[0];
        n *= s, e > r.parameterPositions[1] && (this.stopWarping(), n === 0 ? this.paused = !0 : this.timeScale = n);
      }
    }
    return this._effectiveTimeScale = n, n;
  }
  _updateTime(e) {
    const n = this._clip.duration, r = this.loop;
    let s = this.time + e, o = this._loopCount;
    const a = r === kA;
    if (e === 0)
      return o === -1 ? s : a && (o & 1) === 1 ? n - s : s;
    if (r === GA) {
      o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (s >= n)
          s = n;
        else if (s < 0)
          s = 0;
        else {
          this.time = s;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), s >= n || s < 0) {
        const l = Math.floor(s / n);
        s -= n * l, o += Math.abs(l);
        const c = this.repetitions - o;
        if (c <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = e > 0 ? n : 0, this.time = s, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (c === 1) {
            const h = e < 0;
            this._setEndings(h, !h, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = o, this.time = s, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: l
          });
        }
      } else
        this.time = s;
      if (a && (o & 1) === 1)
        return n - s;
    }
    return s;
  }
  _setEndings(e, n, r) {
    const s = this._interpolantSettings;
    r ? (s.endingStart = vo, s.endingEnd = vo) : (e ? s.endingStart = this.zeroSlopeAtStart ? vo : go : s.endingStart = Nh, n ? s.endingEnd = this.zeroSlopeAtEnd ? vo : go : s.endingEnd = Nh);
  }
  _scheduleFading(e, n, r) {
    const s = this._mixer, o = s.time;
    let a = this._weightInterpolant;
    a === null && (a = s._lendControlInterpolant(), this._weightInterpolant = a);
    const l = a.parameterPositions, c = a.sampleValues;
    return l[0] = o, c[0] = n, l[1] = o + e, c[1] = r, this;
  }
}
function ey(t) {
  this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
}
ey.prototype = Object.assign(Object.create(lr.prototype), {
  constructor: ey,
  _bindAction: function(t, e) {
    const n = t._localRoot || this._root, r = t._clip.tracks, s = r.length, o = t._propertyBindings, a = t._interpolants, l = n.uuid, c = this._bindingsByRootAndName;
    let h = c[l];
    h === void 0 && (h = {}, c[l] = h);
    for (let d = 0; d !== s; ++d) {
      const u = r[d], p = u.name;
      let f = h[p];
      if (f !== void 0)
        o[d] = f;
      else {
        if (f = o[d], f !== void 0) {
          f._cacheIndex === null && (++f.referenceCount, this._addInactiveBinding(f, l, p));
          continue;
        }
        const m = e && e._propertyBindings[d].binding.parsedPath;
        f = new Cx(
          nn.create(n, p, m),
          u.ValueTypeName,
          u.getValueSize()
        ), ++f.referenceCount, this._addInactiveBinding(f, l, p), o[d] = f;
      }
      a[d].resultBuffer = f.buffer;
    }
  },
  _activateAction: function(t) {
    if (!this._isActiveAction(t)) {
      if (t._cacheIndex === null) {
        const n = (t._localRoot || this._root).uuid, r = t._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(
          t,
          s && s.knownActions[0]
        ), this._addInactiveAction(t, r, n);
      }
      const e = t._propertyBindings;
      for (let n = 0, r = e.length; n !== r; ++n) {
        const s = e[n];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(t);
    }
  },
  _deactivateAction: function(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let n = 0, r = e.length; n !== r; ++n) {
        const s = e[n];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(t);
    }
  },
  // Memory manager
  _initMemoryManager: function() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },
        get inUse() {
          return t._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return t._bindings.length;
        },
        get inUse() {
          return t._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },
        get inUse() {
          return t._nActiveControlInterpolants;
        }
      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function(t) {
    const e = t._cacheIndex;
    return e !== null && e < this._nActiveActions;
  },
  _addInactiveAction: function(t, e, n) {
    const r = this._actions, s = this._actionsByClip;
    let o = s[e];
    if (o === void 0)
      o = {
        knownActions: [t],
        actionByRoot: {}
      }, t._byClipCacheIndex = 0, s[e] = o;
    else {
      const a = o.knownActions;
      t._byClipCacheIndex = a.length, a.push(t);
    }
    t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t;
  },
  _removeInactiveAction: function(t) {
    const e = this._actions, n = e[e.length - 1], r = t._cacheIndex;
    n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
    const s = t._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, c = l[l.length - 1], h = t._byClipCacheIndex;
    c._byClipCacheIndex = h, l[h] = c, l.pop(), t._byClipCacheIndex = null;
    const d = a.actionByRoot, u = (t._localRoot || this._root).uuid;
    delete d[u], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(t);
  },
  _removeInactiveBindingsForAction: function(t) {
    const e = t._propertyBindings;
    for (let n = 0, r = e.length; n !== r; ++n) {
      const s = e[n];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  },
  _lendAction: function(t) {
    const e = this._actions, n = t._cacheIndex, r = this._nActiveActions++, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  },
  _takeBackAction: function(t) {
    const e = this._actions, n = t._cacheIndex, r = --this._nActiveActions, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function(t, e, n) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let o = r[e];
    o === void 0 && (o = {}, r[e] = o), o[n] = t, t._cacheIndex = s.length, s.push(t);
  },
  _removeInactiveBinding: function(t) {
    const e = this._bindings, n = t.binding, r = n.rootNode.uuid, s = n.path, o = this._bindingsByRootAndName, a = o[r], l = e[e.length - 1], c = t._cacheIndex;
    l._cacheIndex = c, e[c] = l, e.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r];
  },
  _lendBinding: function(t) {
    const e = this._bindings, n = t._cacheIndex, r = this._nActiveBindings++, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  },
  _takeBackBinding: function(t) {
    const e = this._bindings, n = t._cacheIndex, r = --this._nActiveBindings, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function() {
    const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
    let n = t[e];
    return n === void 0 && (n = new Uh(
      new Float32Array(2),
      new Float32Array(2),
      1,
      this._controlInterpolantsResultBuffer
    ), n.__cacheIndex = e, t[e] = n), n;
  },
  _takeBackControlInterpolant: function(t) {
    const e = this._controlInterpolants, n = t.__cacheIndex, r = --this._nActiveControlInterpolants, s = e[r];
    t.__cacheIndex = r, e[r] = t, s.__cacheIndex = n, e[n] = s;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function(t, e, n) {
    const r = e || this._root, s = r.uuid;
    let o = typeof t == "string" ? ii.findByName(r, t) : t;
    const a = o !== null ? o.uuid : t, l = this._actionsByClip[a];
    let c = null;
    if (n === void 0 && (o !== null ? n = o.blendMode : n = hp), l !== void 0) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === n)
        return d;
      c = l.knownActions[0], o === null && (o = c._clip);
    }
    if (o === null) return null;
    const h = new xP(this, o, e, n);
    return this._bindAction(h, c), this._addInactiveAction(h, a, s), h;
  },
  // get an existing action
  existingAction: function(t, e) {
    const n = e || this._root, r = n.uuid, s = typeof t == "string" ? ii.findByName(n, t) : t, o = s ? s.uuid : t, a = this._actionsByClip[o];
    return a !== void 0 && a.actionByRoot[r] || null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function() {
    const t = this._actions, e = this._nActiveActions;
    for (let n = e - 1; n >= 0; --n)
      t[n].stop();
    return this;
  },
  // advance the time and update apply the animation
  update: function(t) {
    t *= this.timeScale;
    const e = this._actions, n = this._nActiveActions, r = this.time += t, s = Math.sign(t), o = this._accuIndex ^= 1;
    for (let c = 0; c !== n; ++c)
      e[c]._update(r, t, s, o);
    const a = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      a[c].apply(o);
    return this;
  },
  // Allows you to seek to a specific time in an animation.
  setTime: function(t) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++)
      this._actions[e].time = 0;
    return this.update(t);
  },
  // return this mixer's root target object
  getRoot: function() {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function(t) {
    const e = this._actions, n = t.uuid, r = this._actionsByClip, s = r[n];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const h = c._cacheIndex, d = e[e.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, d._cacheIndex = h, e[h] = d, e.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete r[n];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function(t) {
    const e = t.uuid, n = this._actionsByClip;
    for (const o in n) {
      const a = n[o].actionByRoot, l = a[e];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName, s = r[e];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  },
  // remove a targeted clip from the cache
  uncacheAction: function(t, e) {
    const n = this.existingAction(t, e);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
});
function Rl(t, e, n) {
  In.call(this, t, e), this.meshPerAttribute = n || 1;
}
Rl.prototype = Object.assign(Object.create(In.prototype), {
  constructor: Rl,
  isInstancedInterleavedBuffer: !0,
  copy: function(t) {
    return In.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
  },
  clone: function(t) {
    const e = In.prototype.clone.call(this, t);
    return e.meshPerAttribute = this.meshPerAttribute, e;
  },
  toJSON: function(t) {
    const e = In.prototype.toJSON.call(this, t);
    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e;
  }
});
function Px(t, e, n, r, s) {
  this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = s, this.version = 0;
}
Object.defineProperty(Px.prototype, "needsUpdate", {
  set: function(t) {
    t === !0 && this.version++;
  }
});
Object.assign(Px.prototype, {
  isGLBufferAttribute: !0,
  setBuffer: function(t) {
    return this.buffer = t, this;
  },
  setType: function(t, e) {
    return this.type = t, this.elementSize = e, this;
  },
  setItemSize: function(t) {
    return this.itemSize = t, this;
  },
  setCount: function(t) {
    return this.count = t, this;
  }
});
function gp(t, e, n, r) {
  this.ray = new ta(t, e), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.layers = new ox(), this.params = {
    Mesh: {},
    Line: { threshold: 1 },
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  }, Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
      }
    }
  });
}
function ty(t, e) {
  return t.distance - e.distance;
}
function Hf(t, e, n, r) {
  if (t.layers.test(e.layers) && t.raycast(e, n), r === !0) {
    const s = t.children;
    for (let o = 0, a = s.length; o < a; o++)
      Hf(s[o], e, n, !0);
  }
}
Object.assign(gp.prototype, {
  set: function(t, e) {
    this.ray.set(t, e);
  },
  setFromCamera: function(t, e) {
    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  },
  intersectObject: function(t, e, n) {
    const r = n || [];
    return Hf(t, this, r, e), r.sort(ty), r;
  },
  intersectObjects: function(t, e, n) {
    const r = n || [];
    if (Array.isArray(t) === !1)
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
    for (let s = 0, o = t.length; s < o; s++)
      Hf(t[s], this, r, e);
    return r.sort(ty), r;
  }
});
const ny = /* @__PURE__ */ new xe();
class _P {
  constructor(e, n) {
    Object.defineProperty(this, "isBox2", { value: !0 }), this.min = e !== void 0 ? e : new xe(1 / 0, 1 / 0), this.max = n !== void 0 ? n : new xe(-1 / 0, -1 / 0);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = ny.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new xe()), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), e = new xe()), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, n) {
    return n === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), n = new xe()), n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, n) {
    return n === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), n = new xe()), n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return ny.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const iy = /* @__PURE__ */ new F(), ih = /* @__PURE__ */ new F();
class Ix {
  constructor(e, n) {
    this.start = e !== void 0 ? e : new F(), this.end = n !== void 0 ? n : new F();
  }
  set(e, n) {
    return this.start.copy(e), this.end.copy(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new F()), e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), e = new F()), e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, n) {
    return n === void 0 && (console.warn("THREE.Line3: .at() target is now required"), n = new F()), this.delta(n).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, n) {
    iy.subVectors(e, this.start), ih.subVectors(this.end, this.start);
    const r = ih.dot(ih);
    let o = ih.dot(iy) / r;
    return n && (o = Xe.clamp(o, 0, 1)), o;
  }
  closestPointToPoint(e, n, r) {
    const s = this.closestPointToPointParameter(e, n);
    return r === void 0 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), r = new F()), this.delta(r).multiplyScalar(s).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
}
function Wh(t) {
  Ie.call(this), this.material = t, this.render = function() {
  }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
}
Wh.prototype = Object.create(Ie.prototype);
Wh.prototype.constructor = Wh;
Wh.prototype.isImmediateRenderObject = !0;
const Lr = /* @__PURE__ */ new F(), rh = /* @__PURE__ */ new Ye(), wd = /* @__PURE__ */ new Ye();
class bP extends bl {
  constructor(e) {
    const n = Dx(e), r = new ot(), s = [], o = [], a = new De(0, 0, 1), l = new De(0, 1, 0);
    for (let h = 0; h < n.length; h++) {
      const d = n[h];
      d.parent && d.parent.isBone && (s.push(0, 0, 0), s.push(0, 0, 0), o.push(a.r, a.g, a.b), o.push(l.r, l.g, l.b));
    }
    r.setAttribute("position", new Qe(s, 3)), r.setAttribute("color", new Qe(o, 3));
    const c = new Vt({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(r, c), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = n, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const n = this.bones, r = this.geometry, s = r.getAttribute("position");
    wd.copy(this.root.matrixWorld).invert();
    for (let o = 0, a = 0; o < n.length; o++) {
      const l = n[o];
      l.parent && l.parent.isBone && (rh.multiplyMatrices(wd, l.matrixWorld), Lr.setFromMatrixPosition(rh), s.setXYZ(a, Lr.x, Lr.y, Lr.z), rh.multiplyMatrices(wd, l.parent.matrixWorld), Lr.setFromMatrixPosition(rh), s.setXYZ(a + 1, Lr.x, Lr.y, Lr.z), a += 2);
    }
    r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
}
function Dx(t) {
  const e = [];
  t && t.isBone && e.push(t);
  for (let n = 0; n < t.children.length; n++)
    e.push.apply(e, Dx(t.children[n]));
  return e;
}
class wP extends bl {
  constructor(e = 10, n = 10, r = 4473924, s = 8947848) {
    r = new De(r), s = new De(s);
    const o = n / 2, a = e / n, l = e / 2, c = [], h = [];
    for (let p = 0, f = 0, m = -l; p <= n; p++, m += a) {
      c.push(-l, 0, m, l, 0, m), c.push(m, 0, -l, m, 0, l);
      const y = p === o ? r : s;
      y.toArray(h, f), f += 3, y.toArray(h, f), f += 3, y.toArray(h, f), f += 3, y.toArray(h, f), f += 3;
    }
    const d = new ot();
    d.setAttribute("position", new Qe(c, 3)), d.setAttribute("color", new Qe(h, 3));
    const u = new Vt({ vertexColors: !0, toneMapped: !1 });
    super(d, u), this.type = "GridHelper";
  }
}
class MP extends Ci {
  constructor(e, n = 1, r = 16776960) {
    const s = r, o = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], a = new ot();
    a.setAttribute("position", new Qe(o, 3)), a.computeBoundingSphere(), super(a, new Vt({ color: s, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = n;
    const l = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], c = new ot();
    c.setAttribute("position", new Qe(l, 3)), c.computeBoundingSphere(), this.add(new at(c, new ci({ color: s, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    let n = -this.plane.constant;
    Math.abs(n) < 1e-8 && (n = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, n), this.children[0].material.side = n < 0 ? Ct : Fl, this.lookAt(this.plane.normal), super.updateMatrixWorld(e);
  }
}
const SP = new Float32Array(1);
new Int32Array(SP.buffer);
const EP = 2;
Fe.create = function(t, e) {
  return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Fe.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
};
Object.assign(Ir.prototype, {
  createPointsGeometry: function(t) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = this.getPoints(t);
    return this.createGeometry(e);
  },
  createSpacedPointsGeometry: function(t) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = this.getSpacedPoints(t);
    return this.createGeometry(e);
  },
  createGeometry: function(t) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = new Gt();
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.vertices.push(new F(s.x, s.y, s.z || 0));
    }
    return e;
  }
});
Object.assign(xi.prototype, {
  fromPoints: function(t) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
  }
});
Object.create(Ln.prototype);
Object.create(Ln.prototype);
function Nx(t) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Ln.call(this, t), this.type = "catmullrom";
}
Nx.prototype = Object.create(Ln.prototype);
Object.assign(Nx.prototype, {
  initFromArray: function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
wP.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
bP.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Object.assign(pt.prototype, {
  extractUrlBase: function(t) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), sP.extractUrlBase(t);
  }
});
pt.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Object.assign(_P.prototype, {
  center: function(t) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
  },
  empty: function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(t) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  size: function(t) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
  }
});
Object.assign(Un.prototype, {
  center: function(t) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  },
  empty: function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(t) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  isIntersectionSphere: function(t) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
  },
  size: function(t) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
  }
});
Object.assign(Oi.prototype, {
  empty: function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }
});
cu.prototype.setFromMatrix = function(t) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
};
Ix.prototype.center = function(t) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
};
Object.assign(Xe, {
  random16: function() {
    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
  },
  nearestPowerOfTwo: function(t) {
    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Xe.floorPowerOfTwo(t);
  },
  nextPowerOfTwo: function(t) {
    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Xe.ceilPowerOfTwo(t);
  }
});
Object.assign(hn.prototype, {
  flattenToArrayOffset: function(t, e) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
  },
  multiplyVector3: function(t) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBufferAttribute: function(t) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  },
  getInverse: function(t) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
  }
});
Object.assign(Ye.prototype, {
  extractPosition: function(t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
  },
  flattenToArrayOffset: function(t, e) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
  },
  getPosition: function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new F().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function(t) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  multiplyVector4: function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(t) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
  },
  crossVector: function(t) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBufferAttribute: function(t) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(t, e, n, r, s, o) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, s, o);
  },
  getInverse: function(t) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
  }
});
vi.prototype.isIntersectionLine = function(t) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
};
Object.assign(Mn.prototype, {
  multiplyVector3: function(t) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
  },
  inverse: function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
  }
});
Object.assign(ta.prototype, {
  isIntersectionBox: function(t) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  isIntersectionPlane: function(t) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
  },
  isIntersectionSphere: function(t) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
  }
});
Object.assign(Yt.prototype, {
  area: function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  },
  barycoordFromPoint: function(t, e) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
  },
  midpoint: function(t) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
  },
  normal: function(t) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
  },
  plane: function(t) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
  }
});
Object.assign(Yt, {
  barycoordFromPoint: function(t, e, n, r, s) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Yt.getBarycoord(t, e, n, r, s);
  },
  normal: function(t, e, n, r) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Yt.getNormal(t, e, n, r);
  }
});
Object.assign(To.prototype, {
  extractAllPoints: function(t) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
  },
  extrude: function(t) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new BR(this, t);
  },
  makeGeometry: function(t) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new GR(this, t);
  }
});
Object.assign(xe.prototype, {
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  distanceToManhattan: function(t) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(F.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(t) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
  },
  getScaleFromMatrix: function(t) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
  },
  getColumnFromMatrix: function(t, e) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
  },
  applyProjection: function(t) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
  },
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  distanceToManhattan: function(t) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(st.prototype, {
  fromAttribute: function(t, e, n) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(Gt.prototype, {
  computeTangents: function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  },
  applyMatrix: function(t) {
    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.assign(Ie.prototype, {
  getChildByName: function(t) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(t, e) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
  },
  getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  },
  applyMatrix: function(t) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.defineProperties(Ie.prototype, {
  eulerOrder: {
    get: function() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function(t) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.assign(at.prototype, {
  setDrawMode: function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }
});
Object.defineProperties(at.prototype, {
  drawMode: {
    get: function() {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), WA;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
Object.defineProperties(bf.prototype, {
  objects: {
    get: function() {
      return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
    }
  }
});
Object.defineProperty(Sf.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
wf.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Fe.prototype, "__arcLengthDivisions", {
  get: function() {
    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
  },
  set: function(t) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t;
  }
});
Pt.prototype.setLens = function(t, e) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e !== void 0 && (this.filmGauge = e), this.setFocalLength(t);
};
Object.defineProperties(xt.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
    }
  },
  shadowCameraLeft: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
    }
  },
  shadowCameraRight: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
    }
  },
  shadowCameraTop: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
    }
  },
  shadowCameraBottom: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
    }
  },
  shadowCameraNear: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
    }
  },
  shadowCameraFar: {
    set: function(t) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(t) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(t) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
    }
  },
  shadowMapHeight: {
    set: function(t) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
    }
  }
});
Object.defineProperties(qe.prototype, {
  length: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  dynamic: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === gl;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(gl);
    }
  }
});
Object.assign(qe.prototype, {
  setDynamic: function(t) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t === !0 ? gl : lu), this;
  },
  copyIndicesArray: function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  },
  setArray: function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
});
Object.assign(ot.prototype, {
  addIndex: function(t) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
  },
  addAttribute: function(t, e) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new qe(arguments[1], arguments[2]))) : t === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e);
  },
  addDrawCall: function(t, e, n) {
    n !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  },
  removeAttribute: function(t) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
  },
  applyMatrix: function(t) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
});
Object.defineProperties(ot.prototype, {
  drawcalls: {
    get: function() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
});
Object.defineProperties(Yo.prototype, {
  maxInstancedCount: {
    get: function() {
      return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount;
    },
    set: function(t) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t;
    }
  }
});
Object.defineProperties(gp.prototype, {
  linePrecision: {
    get: function() {
      return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold;
    },
    set: function(t) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t;
    }
  }
});
Object.defineProperties(In.prototype, {
  dynamic: {
    get: function() {
      return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === gl;
    },
    set: function(t) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t);
    }
  }
});
Object.assign(In.prototype, {
  setDynamic: function(t) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t === !0 ? gl : lu), this;
  },
  setArray: function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
});
Object.assign(Tx.prototype, {
  getArrays: function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
});
Object.assign(uu.prototype, {
  dispose: function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  }
});
Object.defineProperties(ke.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new De();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(t) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === ex;
    }
  },
  stencilMask: {
    get: function() {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    },
    set: function(t) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
    }
  }
});
Object.defineProperties(Ts.prototype, {
  metal: {
    get: function() {
      return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(Es.prototype, {
  transparency: {
    get: function() {
      return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission;
    },
    set: function(t) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t;
    }
  }
});
Object.defineProperties(Kt.prototype, {
  derivatives: {
    get: function() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function(t) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
    }
  }
});
Object.assign(hu.prototype, {
  clearTarget: function(t, e, n, r) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r);
  },
  animate: function(t) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
  },
  getCurrentRenderTarget: function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  },
  getMaxAnisotropy: function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  },
  resetGLState: function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  },
  supportsFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(t) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  },
  allocTextureUnit: function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  },
  setTexture: function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  },
  setTexture2D: function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  },
  setTextureCube: function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  },
  getActiveMipMapLevel: function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }
});
Object.defineProperties(hu.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }
  },
  vr: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }
  },
  gammaInput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = t === !0 ? sx : Bl;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(xx.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(ai.prototype, {
  wrapS: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
    }
  },
  wrapT: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
    }
  },
  magFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
    }
  },
  minFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
    }
  },
  anisotropy: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
    }
  },
  offset: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
    }
  },
  repeat: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
    }
  },
  format: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
    }
  },
  type: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
    }
  },
  generateMipmaps: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function(t) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
    }
  }
});
ko.prototype.updateCubeMap = function(t, e) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
};
ko.prototype.clear = function(t, e, n, r) {
  return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r);
};
ea.crossOrigin = void 0;
ea.loadTexture = function(t, e, n, r) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const s = new Vh();
  s.setCrossOrigin(this.crossOrigin);
  const o = s.load(t, n, void 0, r);
  return e && (o.mapping = e), o;
};
ea.loadTextureCube = function(t, e, n, r) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const s = new Of();
  s.setCrossOrigin(this.crossOrigin);
  const o = s.load(t, n, void 0, r);
  return e && (o.mapping = e), o;
};
ea.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ea.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: xT
} }));
const ry = {
  LEFT: 1,
  RIGHT: 2
}, TP = {
  config: {
    withCredentials: !1,
    customHeaders: [
      { header: null, value: null }
    ]
  },
  createXMLHttpRequest: function() {
    let t = new XMLHttpRequest();
    if (this.config.customHeaders && Array.isArray(this.config.customHeaders) && this.config.customHeaders.length > 0) {
      let e = t.open, n = this.config.customHeaders;
      t.open = function() {
        e.apply(this, [].slice.call(arguments)), n.forEach(function(r) {
          r.header && r.value && t.setRequestHeader(r.header, r.value);
        });
      };
    }
    return t;
  }
};
class Hr extends Ie {
  constructor(e) {
    super();
    let n = new ut();
    n.minFilter = At, n.magFilter = At;
    let r = new Zr({
      map: n,
      depthTest: !1,
      depthWrite: !1
    });
    this.texture = n, this.material = r, this.sprite = new _f(this.material), this.add(this.sprite), this.borderThickness = 4, this.fontface = "Arial", this.fontsize = 28, this.borderColor = { r: 0, g: 0, b: 0, a: 1 }, this.backgroundColor = { r: 255, g: 255, b: 255, a: 1 }, this.textColor = { r: 255, g: 255, b: 255, a: 1 }, this.text = "", this.setText(e);
  }
  setText(e) {
    this.text !== e && (this.text = e, this.update());
  }
  setTextColor(e) {
    this.textColor = e, this.update();
  }
  setBorderColor(e) {
    this.borderColor = e, this.update();
  }
  setBackgroundColor(e) {
    this.backgroundColor = e, this.update();
  }
  update() {
    let e = document.createElement("canvas"), n = e.getContext("2d");
    n.font = "Bold " + this.fontsize + "px " + this.fontface;
    let s = n.measureText(this.text).width, o = 5, a = 2 * o + s + 2 * this.borderThickness, l = this.fontsize * 1.4 + 2 * this.borderThickness;
    n.canvas.width = a, n.canvas.height = l, n.font = "Bold " + this.fontsize + "px " + this.fontface, n.fillStyle = "rgba(" + this.backgroundColor.r + "," + this.backgroundColor.g + "," + this.backgroundColor.b + "," + this.backgroundColor.a + ")", n.strokeStyle = "rgba(" + this.borderColor.r + "," + this.borderColor.g + "," + this.borderColor.b + "," + this.borderColor.a + ")", n.lineWidth = this.borderThickness, this.roundRect(
      n,
      this.borderThickness / 2,
      this.borderThickness / 2,
      s + this.borderThickness + 2 * o,
      this.fontsize * 1.4 + this.borderThickness,
      6
    ), n.strokeStyle = "rgba(0, 0, 0, 1.0)", n.strokeText(this.text, this.borderThickness + o, this.fontsize + this.borderThickness), n.fillStyle = "rgba(" + this.textColor.r + "," + this.textColor.g + "," + this.textColor.b + "," + this.textColor.a + ")", n.fillText(this.text, this.borderThickness + o, this.fontsize + this.borderThickness);
    let c = new ut(e);
    c.minFilter = At, c.magFilter = At, c.needsUpdate = !0, this.sprite.material.map = c, this.texture = c, this.sprite.scale.set(a * 0.01, l * 0.01, 1);
  }
  roundRect(e, n, r, s, o, a) {
    e.beginPath(), e.moveTo(n + a, r), e.lineTo(n + s - a, r), e.quadraticCurveTo(n + s, r, n + s, r + a), e.lineTo(n + s, r + o - a), e.quadraticCurveTo(n + s, r + o, n + s - a, r + o), e.lineTo(n + a, r + o), e.quadraticCurveTo(n, r + o, n, r + o - a), e.lineTo(n, r + a), e.quadraticCurveTo(n, r, n + a, r), e.closePath(), e.fill(), e.stroke();
  }
}
class AP extends Ie {
  constructor(e = {}) {
    super(), this.constructor.name === "Volume" && console.warn("Can't create object of class Volume directly. Use classes BoxVolume or SphereVolume instead."), this._clip = e.clip || !1, this._visible = !0, this.showVolumeLabel = !0, this._modifiable = e.modifiable || !0, this.label = new Hr("0"), this.label.setBorderColor({ r: 0, g: 255, b: 0, a: 0 }), this.label.setBackgroundColor({ r: 0, g: 255, b: 0, a: 0 }), this.label.material.depthTest = !1, this.label.material.depthWrite = !1, this.label.material.transparent = !0, this.label.position.y -= 0.5, this.add(this.label), this.label.updateMatrixWorld = () => {
      let n = new F();
      n.setFromMatrixPosition(this.matrixWorld), this.label.position.copy(n), this.label.updateMatrix(), this.label.matrixWorld.copy(this.label.matrix), this.label.matrixWorldNeedsUpdate = !1;
      for (let r = 0, s = this.label.children.length; r < s; r++)
        this.label.children[r].updateMatrixWorld(!0);
    }, this.addEventListener("select", (n) => {
    }), this.addEventListener("deselect", (n) => {
    });
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    this._visible !== e && (this._visible = e, this.dispatchEvent({ type: "visibility_changed", object: this }));
  }
  getVolume() {
    console.warn("override this in subclass");
  }
  update() {
  }
  raycast(e, n) {
  }
  get clip() {
    return this._clip;
  }
  set clip(e) {
    this._clip !== e && (this._clip = e, this.update(), this.dispatchEvent({
      type: "clip_changed",
      object: this
    }));
  }
  get modifieable() {
    return this._modifiable;
  }
  set modifieable(e) {
    this._modifiable = e, this.update();
  }
}
class LP extends Ie {
  constructor() {
    super(), this.constructor.counter = this.constructor.counter === void 0 ? 0 : this.constructor.counter + 1, this.name = "Profile_" + this.constructor.counter, this.points = [], this.spheres = [], this.edges = [], this.boxes = [], this.width = 1, this.height = 20, this._modifiable = !0, this.sphereGeometry = new ia(0.4, 10, 10), this.color = new De(16711680), this.lineColor = new De(16711680);
  }
  createSphereMaterial() {
    return new Kr(
      {
        //shading: THREE.SmoothShading,
        color: 16711680,
        depthTest: !1,
        depthWrite: !1
      }
    );
  }
  getSegments() {
    let e = [];
    for (let n = 0; n < this.points.length - 1; n++) {
      let r = this.points[n].clone(), s = this.points[n + 1].clone();
      e.push({ start: r, end: s });
    }
    return e;
  }
  getSegmentMatrices() {
    let e = this.getSegments(), n = [];
    for (let r of e) {
      let { start: s, end: o } = r, a = new Ie(), l = s.clone().setZ(0).distanceTo(o.clone().setZ(0));
      a.scale.set(l, 1e4, this.width), a.up.set(0, 0, 1);
      let c = new F().addVectors(s, o).multiplyScalar(0.5), h = new F().subVectors(o, s), d = new F(h.y, -h.x, 0);
      a.position.set(0, 0, 0), a.lookAt(d), a.position.copy(c), a.updateMatrixWorld(), n.push(a.matrixWorld);
    }
    return n;
  }
  addMarker(e) {
    this.points.push(e);
    let n = new at(this.sphereGeometry, this.createSphereMaterial());
    if (this.add(n), this.spheres.push(n), this.points.length > 1) {
      let s = new Gt();
      s.vertices.push(new F(), new F()), s.colors.push(this.lineColor, this.lineColor, this.lineColor);
      let o = new Vt({
        vertexColors: EP,
        linewidth: 2,
        transparent: !0,
        opacity: 0.4
      });
      o.depthTest = !1;
      let a = new Ci(s, o);
      a.visible = !1, this.add(a), this.edges.push(a);
      let l = new wx(1, 1, 1), c = new ci({ color: 16711680, transparent: !0, opacity: 0.2 }), h = new at(l, c);
      h.visible = !1, this.add(h), this.boxes.push(h);
    }
    {
      let s = (c) => {
        let h = Et.getMousePointCloudIntersection(
          c.drag.end,
          c.viewer.scene.getActiveCamera(),
          c.viewer,
          c.viewer.scene.pointclouds
        );
        if (h) {
          let d = this.spheres.indexOf(c.drag.object);
          d !== -1 && this.setPosition(d, h.location);
        }
      }, o = (c) => {
        let h = this.spheres.indexOf(c.drag.object);
        h !== -1 && this.dispatchEvent({
          type: "marker_dropped",
          profile: this,
          index: h
        });
      }, a = (c) => c.object.material.emissive.setHex(8947848), l = (c) => c.object.material.emissive.setHex(0);
      n.addEventListener("drag", s), n.addEventListener("drop", o), n.addEventListener("mouseover", a), n.addEventListener("mouseleave", l);
    }
    let r = {
      type: "marker_added",
      profile: this,
      sphere: n
    };
    this.dispatchEvent(r), this.setPosition(this.points.length - 1, e);
  }
  removeMarker(e) {
    this.points.splice(e, 1), this.remove(this.spheres[e]);
    let n = e === 0 ? 0 : e - 1;
    this.remove(this.edges[n]), this.edges.splice(n, 1), this.remove(this.boxes[n]), this.boxes.splice(n, 1), this.spheres.splice(e, 1), this.update(), this.dispatchEvent({
      type: "marker_removed",
      profile: this
    });
  }
  setPosition(e, n) {
    let r = this.points[e];
    r.copy(n);
    let s = {
      type: "marker_moved",
      profile: this,
      index: e,
      position: r.clone()
    };
    this.dispatchEvent(s), this.update();
  }
  setWidth(e) {
    this.width = e;
    let n = {
      type: "width_changed",
      profile: this,
      width: e
    };
    this.dispatchEvent(n), this.update();
  }
  getWidth() {
    return this.width;
  }
  update() {
    if (this.points.length === 0)
      return;
    if (this.points.length === 1) {
      let o = this.points[0];
      this.spheres[0].position.copy(o);
      return;
    }
    let e = this.points[0].clone(), n = this.points[0].clone(), r = new F(), s = this.points.length - 1;
    for (let o = 0; o <= s; o++) {
      let a = this.points[o], l = this.spheres[o], c = o === 0 ? s : o - 1, h = this.points[c], d = this.edges[c], u = this.edges[o], p = this.boxes[c];
      if (l.position.copy(a), this._modifiable ? l.visible = !0 : l.visible = !1, d && (d.geometry.vertices[1].copy(a), d.geometry.verticesNeedUpdate = !0, d.geometry.computeBoundingSphere()), u && (u.geometry.vertices[0].copy(a), u.geometry.verticesNeedUpdate = !0, u.geometry.computeBoundingSphere()), p) {
        let f = h, m = a, y = f.clone().setZ(0).distanceTo(m.clone().setZ(0));
        p.scale.set(y, 1e6, this.width), p.up.set(0, 0, 1);
        let x = new F().addVectors(f, m).multiplyScalar(0.5), v = new F().subVectors(m, f), g = new F(v.y, -v.x, 0);
        p.position.set(0, 0, 0), p.lookAt(g), p.position.copy(x);
      }
      r.add(a), e.min(a), n.max(a);
    }
    r.multiplyScalar(1 / this.points.length);
    for (let o = 0; o < this.boxes.length; o++) {
      let a = this.boxes[o];
      a.position.z = e.z + (n.z - e.z) / 2;
    }
  }
  raycast(e, n) {
    for (let r = 0; r < this.points.length; r++)
      this.spheres[r].raycast(e, n);
    for (let r = 0; r < n.length; r++) {
      let s = n[r];
      s.distance = e.ray.origin.distanceTo(s.point);
    }
    n.sort(function(r, s) {
      return r.distance - s.distance;
    });
  }
  get modifiable() {
    return this._modifiable;
  }
  set modifiable(e) {
    this._modifiable = e, this.update();
  }
}
var ps = function() {
  Yo.call(this), this.type = "LineSegmentsGeometry";
  var t = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], e = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
  this.setIndex(n), this.setAttribute("position", new Qe(t, 3)), this.setAttribute("uv", new Qe(e, 2));
};
ps.prototype = Object.assign(Object.create(Yo.prototype), {
  constructor: ps,
  isLineSegmentsGeometry: !0,
  applyMatrix4: function(t) {
    var e = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return e !== void 0 && (e.applyMatrix4(t), n.applyMatrix4(t), e.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  },
  setPositions: function(t) {
    var e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    var n = new Rl(e, 6, 1);
    return this.setAttribute("instanceStart", new _n(n, 3, 0)), this.setAttribute("instanceEnd", new _n(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  },
  setColors: function(t) {
    var e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    var n = new Rl(e, 6, 1);
    return this.setAttribute("instanceColorStart", new _n(n, 3, 0)), this.setAttribute("instanceColorEnd", new _n(n, 3, 3)), this;
  },
  fromWireframeGeometry: function(t) {
    return this.setPositions(t.attributes.position.array), this;
  },
  fromEdgesGeometry: function(t) {
    return this.setPositions(t.attributes.position.array), this;
  },
  fromMesh: function(t) {
    return this.fromWireframeGeometry(new WR(t.geometry)), this;
  },
  fromLineSegments: function(t) {
    var e = t.geometry;
    return e.isGeometry ? this.setPositions(e.vertices) : e.isBufferGeometry && this.setPositions(e.attributes.position.array), this;
  },
  computeBoundingBox: function() {
    var t = new Un();
    return function() {
      this.boundingBox === null && (this.boundingBox = new Un());
      var n = this.attributes.instanceStart, r = this.attributes.instanceEnd;
      n !== void 0 && r !== void 0 && (this.boundingBox.setFromBufferAttribute(n), t.setFromBufferAttribute(r), this.boundingBox.union(t));
    };
  }(),
  computeBoundingSphere: function() {
    var t = new F();
    return function() {
      this.boundingSphere === null && (this.boundingSphere = new Oi()), this.boundingBox === null && this.computeBoundingBox();
      var n = this.attributes.instanceStart, r = this.attributes.instanceEnd;
      if (n !== void 0 && r !== void 0) {
        var s = this.boundingSphere.center;
        this.boundingBox.getCenter(s);
        for (var o = 0, a = 0, l = n.count; a < l; a++)
          t.fromBufferAttribute(n, a), o = Math.max(o, s.distanceToSquared(t)), t.fromBufferAttribute(r, a), o = Math.max(o, s.distanceToSquared(t));
        this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    };
  }(),
  toJSON: function() {
  },
  applyMatrix: function(t) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(t);
  }
});
Te.line = {
  linewidth: { value: 1 },
  resolution: { value: new xe(1, 1) },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  dashOffset: { value: 0 },
  gapSize: { value: 1 },
  // todo FIX - maybe change to totalSize
  opacity: { value: 1 }
};
on.line = {
  uniforms: dp.merge([
    Te.common,
    Te.fog,
    Te.line
  ]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float dashOffset;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			vec4 diffuseColor = vec4( diffuse, opacity );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
var Vn = function(t) {
  Kt.call(this, {
    type: "LineMaterial",
    uniforms: dp.clone(on.line.uniforms),
    vertexShader: on.line.vertexShader,
    fragmentShader: on.line.fragmentShader,
    clipping: !0
    // required for clipping support
  }), this.dashed = !1, Object.defineProperties(this, {
    color: {
      enumerable: !0,
      get: function() {
        return this.uniforms.diffuse.value;
      },
      set: function(e) {
        this.uniforms.diffuse.value = e;
      }
    },
    linewidth: {
      enumerable: !0,
      get: function() {
        return this.uniforms.linewidth.value;
      },
      set: function(e) {
        this.uniforms.linewidth.value = e;
      }
    },
    dashScale: {
      enumerable: !0,
      get: function() {
        return this.uniforms.dashScale.value;
      },
      set: function(e) {
        this.uniforms.dashScale.value = e;
      }
    },
    dashSize: {
      enumerable: !0,
      get: function() {
        return this.uniforms.dashSize.value;
      },
      set: function(e) {
        this.uniforms.dashSize.value = e;
      }
    },
    dashOffset: {
      enumerable: !0,
      get: function() {
        return this.uniforms.dashOffset.value;
      },
      set: function(e) {
        this.uniforms.dashOffset.value = e;
      }
    },
    gapSize: {
      enumerable: !0,
      get: function() {
        return this.uniforms.gapSize.value;
      },
      set: function(e) {
        this.uniforms.gapSize.value = e;
      }
    },
    opacity: {
      enumerable: !0,
      get: function() {
        return this.uniforms.opacity.value;
      },
      set: function(e) {
        this.uniforms.opacity.value = e;
      }
    },
    resolution: {
      enumerable: !0,
      get: function() {
        return this.uniforms.resolution.value;
      },
      set: function(e) {
        this.uniforms.resolution.value.copy(e);
      }
    }
  }), this.setValues(t);
};
Vn.prototype = Object.create(Kt.prototype);
Vn.prototype.constructor = Vn;
Vn.prototype.isLineMaterial = !0;
var $h = function(t, e) {
  t === void 0 && (t = new ps()), e === void 0 && (e = new Vn({ color: Math.random() * 16777215 })), at.call(this, t, e), this.type = "LineSegments2";
};
$h.prototype = Object.assign(Object.create(at.prototype), {
  constructor: $h,
  isLineSegments2: !0,
  computeLineDistances: function() {
    var t = new F(), e = new F();
    return function() {
      for (var r = this.geometry, s = r.attributes.instanceStart, o = r.attributes.instanceEnd, a = new Float32Array(2 * s.data.count), l = 0, c = 0, h = s.data.count; l < h; l++, c += 2)
        t.fromBufferAttribute(s, l), e.fromBufferAttribute(o, l), a[c] = c === 0 ? 0 : a[c - 1], a[c + 1] = a[c] + t.distanceTo(e);
      var d = new Rl(a, 2, 1);
      return r.setAttribute("instanceDistanceStart", new _n(d, 1, 0)), r.setAttribute("instanceDistanceEnd", new _n(d, 1, 1)), this;
    };
  }(),
  raycast: function() {
    var t = new st(), e = new st(), n = new st(), r = new F(), s = new Ye(), o = new Ix(), a = new F();
    return function(c, h) {
      c.camera === null && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
      var d = c.params.Line2 !== void 0 && c.params.Line2.threshold || 0, u = c.ray, p = c.camera, f = p.projectionMatrix, m = this.geometry, y = this.material, x = y.resolution, v = y.linewidth + d, g = m.attributes.instanceStart, S = m.attributes.instanceEnd;
      u.at(1, n), n.w = 1, n.applyMatrix4(p.matrixWorldInverse), n.applyMatrix4(f), n.multiplyScalar(1 / n.w), n.x *= x.x / 2, n.y *= x.y / 2, n.z = 0, r.copy(n);
      var T = this.matrixWorld;
      s.multiplyMatrices(p.matrixWorldInverse, T);
      for (var E = 0, w = g.count; E < w; E++) {
        t.fromBufferAttribute(g, E), e.fromBufferAttribute(S, E), t.w = 1, e.w = 1, t.applyMatrix4(s), e.applyMatrix4(s), t.applyMatrix4(f), e.applyMatrix4(f), t.multiplyScalar(1 / t.w), e.multiplyScalar(1 / e.w);
        var C = t.z < -1 && e.z < -1, ee = t.z > 1 && e.z > 1;
        if (!(C || ee)) {
          t.x *= x.x / 2, t.y *= x.y / 2, e.x *= x.x / 2, e.y *= x.y / 2, o.start.copy(t), o.start.z = 0, o.end.copy(e), o.end.z = 0;
          var Y = o.closestPointToPointParameter(r, !0);
          o.at(Y, a);
          var le = Xe.lerp(t.z, e.z, Y), B = le >= -1 && le <= 1, Z = r.distanceTo(a) < v * 0.5;
          if (B && Z) {
            o.start.fromBufferAttribute(g, E), o.end.fromBufferAttribute(S, E), o.start.applyMatrix4(T), o.end.applyMatrix4(T);
            var k = new F(), O = new F();
            u.distanceSqToSegment(o.start, o.end, O, k), h.push({
              point: O,
              pointOnLine: k,
              distance: u.origin.distanceTo(O),
              object: this,
              face: null,
              faceIndex: E,
              uv: null,
              uv2: null
            });
          }
        }
      }
    };
  }()
});
var or = function() {
  ps.call(this), this.type = "LineGeometry";
};
or.prototype = Object.assign(Object.create(ps.prototype), {
  constructor: or,
  isLineGeometry: !0,
  setPositions: function(t) {
    for (var e = t.length - 3, n = new Float32Array(2 * e), r = 0; r < e; r += 3)
      n[2 * r] = t[r], n[2 * r + 1] = t[r + 1], n[2 * r + 2] = t[r + 2], n[2 * r + 3] = t[r + 3], n[2 * r + 4] = t[r + 4], n[2 * r + 5] = t[r + 5];
    return ps.prototype.setPositions.call(this, n), this;
  },
  setColors: function(t) {
    for (var e = t.length - 3, n = new Float32Array(2 * e), r = 0; r < e; r += 3)
      n[2 * r] = t[r], n[2 * r + 1] = t[r + 1], n[2 * r + 2] = t[r + 2], n[2 * r + 3] = t[r + 3], n[2 * r + 4] = t[r + 4], n[2 * r + 5] = t[r + 5];
    return ps.prototype.setColors.call(this, n), this;
  },
  fromLine: function(t) {
    var e = t.geometry;
    return e.isGeometry ? this.setPositions(e.vertices) : e.isBufferGeometry && this.setPositions(e.attributes.position.array), this;
  },
  copy: function() {
    return this;
  }
});
var Qr = function(t, e) {
  t === void 0 && (t = new or()), e === void 0 && (e = new Vn({ color: Math.random() * 16777215 })), $h.call(this, t, e), this.type = "Line2";
};
Qr.prototype = Object.assign(Object.create($h.prototype), {
  constructor: Qr,
  isLine2: !0
});
function CP() {
  let t = new or();
  t.setPositions([
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  let e = new Vn({
    color: 65280,
    dashSize: 5,
    gapSize: 2,
    linewidth: 2,
    resolution: new xe(1e3, 1e3)
  });
  e.depthTest = !1;
  const n = new Qr(t, e);
  return n.visible = !1, n;
}
function RP() {
  const t = new Hr("");
  return t.setTextColor({ r: 140, g: 250, b: 140, a: 1 }), t.setBorderColor({ r: 0, g: 0, b: 0, a: 1 }), t.setBackgroundColor({ r: 0, g: 0, b: 0, a: 1 }), t.fontsize = 16, t.material.depthTest = !1, t.material.opacity = 1, t.visible = !1, t;
}
function PP() {
  const t = new Hr("");
  return t.setTextColor({ r: 140, g: 250, b: 140, a: 1 }), t.setBorderColor({ r: 0, g: 0, b: 0, a: 1 }), t.setBackgroundColor({ r: 0, g: 0, b: 0, a: 1 }), t.fontsize = 16, t.material.depthTest = !1, t.material.opacity = 1, t.visible = !1, t;
}
function IP() {
  const t = new Hr("");
  return t.setTextColor({ r: 140, g: 250, b: 140, a: 1 }), t.setBorderColor({ r: 0, g: 0, b: 0, a: 1 }), t.setBackgroundColor({ r: 0, g: 0, b: 0, a: 1 }), t.fontsize = 16, t.material.depthTest = !1, t.material.opacity = 1, t.visible = !1, t;
}
function DP() {
  const t = new or();
  t.setPositions([
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  const e = new Vn({
    color: 16711680,
    linewidth: 2,
    resolution: new xe(1e3, 1e3),
    gapSize: 1,
    dashed: !0
  });
  e.depthTest = !1;
  const n = new Qr(t, e);
  return n.visible = !1, n;
}
function NP() {
  const t = [];
  let e = 128;
  for (let o = 0; o <= e; o++) {
    let a = 2 * Math.PI * (o / e), l = 2 * Math.PI * (o + 1) / e, c = new F(
      Math.cos(a),
      Math.sin(a),
      0
    ), h = new F(
      Math.cos(l),
      Math.sin(l),
      0
    );
    t.push(
      ...c.toArray(),
      ...h.toArray()
    );
  }
  const n = new or();
  n.setPositions(t);
  const r = new Vn({
    color: 16711680,
    dashSize: 5,
    gapSize: 2,
    linewidth: 2,
    resolution: new xe(1e3, 1e3)
  });
  r.depthTest = !1;
  const s = new Qr(n, r);
  return s.visible = !1, s.computeLineDistances(), s;
}
function OP() {
  const t = new ia(1, 32, 32), e = new Ri(), n = new at(t, e);
  return n.visible = !1, n;
}
function sh() {
  const t = new or();
  t.setPositions([
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  const e = new Vn({
    color: 16711680,
    linewidth: 2,
    resolution: new xe(1e3, 1e3),
    gapSize: 1,
    dashed: !0
  });
  return e.depthTest = !1, new Qr(t, e);
}
function FP() {
  const t = [];
  let e = 128;
  for (let o = 0; o <= e; o++) {
    let a = 2 * Math.PI * (o / e), l = 2 * Math.PI * (o + 1) / e, c = new F(
      Math.cos(a),
      Math.sin(a),
      0
    ), h = new F(
      Math.cos(l),
      Math.sin(l),
      0
    );
    t.push(
      ...c.toArray(),
      ...h.toArray()
    );
  }
  const n = new or();
  n.setPositions(t);
  const r = new Vn({
    color: 16711680,
    dashSize: 5,
    gapSize: 2,
    linewidth: 2,
    resolution: new xe(1e3, 1e3)
  });
  r.depthTest = !1;
  const s = new Qr(n, r);
  return s.computeLineDistances(), s;
}
function BP() {
  const t = {
    label: null,
    center: null,
    target: null,
    north: null,
    centerToNorth: null,
    centerToTarget: null,
    centerToTargetground: null,
    targetgroundToTarget: null,
    circle: null,
    node: null
  }, e = new ia(1, 32, 32), n = new Ri();
  {
    const r = new Hr("");
    r.setTextColor({ r: 140, g: 250, b: 140, a: 1 }), r.setBorderColor({ r: 0, g: 0, b: 0, a: 1 }), r.setBackgroundColor({ r: 0, g: 0, b: 0, a: 1 }), r.fontsize = 16, r.material.depthTest = !1, r.material.opacity = 1, t.label = r;
  }
  return t.center = new at(e, n), t.target = new at(e, n), t.north = new at(e, n), t.centerToNorth = sh(), t.centerToTarget = sh(), t.centerToTargetground = sh(), t.targetgroundToTarget = sh(), t.circle = FP(), t.node = new Ie(), t.node.add(
    t.centerToNorth,
    t.centerToTarget,
    t.centerToTargetground,
    t.targetgroundToTarget,
    t.circle,
    t.label,
    t.center,
    t.target,
    t.north
  ), t;
}
class zP extends Ie {
  constructor() {
    super(), this.constructor.counter = this.constructor.counter === void 0 ? 0 : this.constructor.counter + 1, this.name = "Measure_" + this.constructor.counter, this.points = [], this._showDistances = !0, this._showCoordinates = !1, this._showArea = !1, this._closed = !0, this._showAngles = !1, this._showCircle = !1, this._showHeight = !1, this._showEdges = !0, this._showAzimuth = !1, this.maxMarkers = Number.MAX_SAFE_INTEGER, this.sphereGeometry = new ia(0.4, 10, 10), this.color = new De(16711680), this.spheres = [], this.edges = [], this.sphereLabels = [], this.edgeLabels = [], this.angleLabels = [], this.coordinateLabels = [], this.heightEdge = CP(), this.heightLabel = RP(), this.areaLabel = PP(), this.circleRadiusLabel = IP(), this.circleRadiusLine = DP(), this.circleLine = NP(), this.circleCenter = OP(), this.azimuth = BP(), this.add(this.heightEdge), this.add(this.heightLabel), this.add(this.areaLabel), this.add(this.circleRadiusLabel), this.add(this.circleRadiusLine), this.add(this.circleLine), this.add(this.circleCenter), this.add(this.azimuth.node);
  }
  createSphereMaterial() {
    return new Kr(
      {
        //shading: THREE.SmoothShading,
        color: this.color,
        depthTest: !1,
        depthWrite: !1
      }
    );
  }
  addMarker(e) {
    e.x != null ? e = { position: e } : e instanceof Array && (e = { position: new F(...e) }), this.points.push(e);
    let n = new at(this.sphereGeometry, this.createSphereMaterial());
    this.add(n), this.spheres.push(n);
    {
      let s = new or();
      s.setPositions([
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      let o = new Vn({
        color: 16711680,
        linewidth: 2,
        resolution: new xe(1e3, 1e3)
      });
      o.depthTest = !1;
      let a = new Qr(s, o);
      a.visible = !0, this.add(a), this.edges.push(a);
    }
    {
      let s = new Hr();
      s.setBorderColor({ r: 0, g: 0, b: 0, a: 1 }), s.setBackgroundColor({ r: 0, g: 0, b: 0, a: 1 }), s.material.depthTest = !1, s.visible = !1, s.fontsize = 16, this.edgeLabels.push(s), this.add(s);
    }
    {
      let s = new Hr();
      s.setBorderColor({ r: 0, g: 0, b: 0, a: 1 }), s.setBackgroundColor({ r: 0, g: 0, b: 0, a: 1 }), s.fontsize = 16, s.material.depthTest = !1, s.material.opacity = 1, s.visible = !1, this.angleLabels.push(s), this.add(s);
    }
    {
      let s = new Hr();
      s.setBorderColor({ r: 0, g: 0, b: 0, a: 1 }), s.setBackgroundColor({ r: 0, g: 0, b: 0, a: 1 }), s.fontsize = 16, s.material.depthTest = !1, s.material.opacity = 1, s.visible = !1, this.coordinateLabels.push(s), this.add(s);
    }
    n.drag = (s) => {
      let o = Et.getMousePointCloudIntersection(
        s.drag.end,
        s.viewer.scene.getActiveCamera(),
        s.viewer,
        s.viewer.scene.pointclouds,
        { pickClipped: !0 }
      );
      if (o) {
        let a = this.spheres.indexOf(s.drag.object);
        if (a !== -1) {
          let l = this.points[a];
          for (let c of Object.keys(l))
            o.point[c] || delete l[c];
          for (let c of Object.keys(o.point).filter((h) => h !== "position"))
            l[c] = o.point[c];
          this.setPosition(a, o.location);
        }
      }
    }, n.drop = (s) => {
      let o = this.spheres.indexOf(s.drag.object);
      o !== -1 && this.dispatchEvent({
        type: "marker_dropped",
        measurement: this,
        index: o
      });
    }, n.mouseover = (s) => s.object.material.emissive.setHex(8947848), n.mouseleave = (s) => s.object.material.emissive.setHex(0), n.addEventListener("drag", n.drag), n.addEventListener("drop", n.drop), n.addEventListener("mouseover", n.mouseover), n.addEventListener("mouseleave", n.mouseleave);
    let r = {
      type: "marker_added",
      measurement: this,
      sphere: n
    };
    this.dispatchEvent(r), this.setMarker(this.points.length - 1, e);
  }
  removeMarker(e) {
    this.points.splice(e, 1), this.remove(this.spheres[e]);
    let n = e === 0 ? 0 : e - 1;
    this.remove(this.edges[n]), this.edges.splice(n, 1), this.remove(this.edgeLabels[n]), this.edgeLabels.splice(n, 1), this.coordinateLabels.splice(e, 1), this.remove(this.angleLabels[e]), this.angleLabels.splice(e, 1), this.spheres.splice(e, 1), this.update(), this.dispatchEvent({ type: "marker_removed", measurement: this });
  }
  setMarker(e, n) {
    this.points[e] = n;
    let r = {
      type: "marker_moved",
      measure: this,
      index: e,
      position: n.position.clone()
    };
    this.dispatchEvent(r), this.update();
  }
  setPosition(e, n) {
    this.points[e].position.copy(n);
    let s = {
      type: "marker_moved",
      measure: this,
      index: e,
      position: n.clone()
    };
    this.dispatchEvent(s), this.update();
  }
  getArea() {
    let e = 0, n = this.points.length - 1;
    for (let r = 0; r < this.points.length; r++) {
      let s = this.points[r].position, o = this.points[n].position;
      e += (o.x + s.x) * (s.y - o.y), n = r;
    }
    return Math.abs(e / 2);
  }
  getTotalDistance() {
    if (this.points.length === 0)
      return 0;
    let e = 0;
    for (let n = 1; n < this.points.length; n++) {
      let r = this.points[n - 1].position, s = this.points[n].position, o = r.distanceTo(s);
      e += o;
    }
    if (this.closed && this.points.length > 1) {
      let n = this.points[0].position, s = this.points[this.points.length - 1].position.distanceTo(n);
      e += s;
    }
    return e;
  }
  getAngleBetweenLines(e, n, r) {
    let s = new F().subVectors(n.position, e.position), o = new F().subVectors(r.position, e.position);
    return Math.sqrt(s.lengthSq() * o.lengthSq()) === 0 ? 0 : s.angleTo(o);
  }
  getAngle(e) {
    if (this.points.length < 3 || e >= this.points.length)
      return 0;
    let n = e === 0 ? this.points[this.points.length - 1] : this.points[e - 1], r = this.points[e], s = this.points[(e + 1) % this.points.length];
    return this.getAngleBetweenLines(r, n, s);
  }
  // updateAzimuth(){
  // 	// if(this.points.length !== 2){
  // 	// 	return;
  // 	// }
  // 	// const azimuth = this.azimuth;
  // 	// const [p0, p1] = this.points;
  // 	// const r = p0.position.distanceTo(p1.position);
  // }
  update() {
    if (this.points.length === 0)
      return;
    if (this.points.length === 1) {
      let s = this.points[0].position;
      this.spheres[0].position.copy(s);
      {
        let o = this.coordinateLabels[0], a = s.toArray().map((l) => Et.addCommas(l.toFixed(2))).join(" / ");
        o.setText(a), o.visible = this.showCoordinates;
      }
      return;
    }
    let e = this.points.length - 1, n = new F();
    for (let r = 0; r <= e; r++) {
      let s = this.points[r];
      n.add(s.position);
    }
    n.divideScalar(this.points.length);
    for (let r = 0; r <= e; r++) {
      let s = r, o = r + 1 > e ? 0 : r + 1, a = r === 0 ? e : r - 1, l = this.points[s], c = this.points[o], h = this.points[a], d = this.spheres[s];
      d.position.copy(l.position), d.material.color = this.color;
      {
        let u = this.edges[s];
        u.material.color = this.color, u.position.copy(l.position), u.geometry.setPositions([
          0,
          0,
          0,
          ...c.position.clone().sub(l.position).toArray()
        ]), u.geometry.verticesNeedUpdate = !0, u.geometry.computeBoundingSphere(), u.computeLineDistances(), u.visible = s < e || this.closed, this.showEdges || (u.visible = !1);
      }
      {
        let u = this.edgeLabels[r], p = new F().add(l.position);
        p.add(c.position), p = p.multiplyScalar(0.5);
        let f = l.position.distanceTo(c.position);
        u.position.copy(p);
        let m = "";
        this.lengthUnit != null && this.lengthUnitDisplay != null && (f = f / this.lengthUnit.unitspermeter * this.lengthUnitDisplay.unitspermeter, m = this.lengthUnitDisplay.code);
        let y = Et.addCommas(f.toFixed(2));
        u.setText(`${y} ${m}`), u.visible = this.showDistances && (s < e || this.closed) && this.points.length >= 2 && f > 0;
      }
      {
        let u = this.angleLabels[r], p = this.getAngleBetweenLines(l, h, c), f = c.position.clone().sub(h.position);
        f.multiplyScalar(0.5), f = h.position.clone().add(f).sub(l.position).normalize();
        let m = Math.min(l.position.distanceTo(h.position), l.position.distanceTo(c.position));
        m = m / 9;
        let y = l.position.clone().add(f.multiplyScalar(m));
        u.position.copy(y);
        let x = Et.addCommas((p * (180 / Math.PI)).toFixed(1)) + "";
        u.setText(x), u.visible = this.showAngles && (s < e || this.closed) && this.points.length >= 3 && p > 0;
      }
    }
    {
      let r = this.heightEdge;
      if (r.visible = this.showHeight, this.heightLabel.visible = this.showHeight, this.showHeight) {
        let s = this.points.slice().sort((x, v) => x.position.z - v.position.z), o = s[0].position.clone(), a = s[s.length - 1].position.clone(), l = o.z, c = a.z, h = c - l, d = new F(a.x, a.y, l), u = new F(a.x, a.y, c);
        r.position.copy(o), r.geometry.setPositions([
          0,
          0,
          0,
          ...d.clone().sub(o).toArray(),
          ...d.clone().sub(o).toArray(),
          ...u.clone().sub(o).toArray()
        ]), r.geometry.verticesNeedUpdate = !0, r.geometry.computeBoundingSphere(), r.computeLineDistances();
        let p = d.clone().add(u).multiplyScalar(0.5);
        this.heightLabel.position.copy(p);
        let f = "";
        this.lengthUnit != null && this.lengthUnitDisplay != null && (h = h / this.lengthUnit.unitspermeter * this.lengthUnitDisplay.unitspermeter, f = this.lengthUnitDisplay.code);
        let y = `${Et.addCommas(h.toFixed(2))} ${f}`;
        this.heightLabel.setText(y);
      }
    }
    {
      const r = this.circleRadiusLabel, s = this.circleRadiusLine, o = this.circleLine, a = this.circleCenter, l = this.points.length === 3;
      if (r.visible = this.showCircle && l, s.visible = this.showCircle && l, o.visible = this.showCircle && l, a.visible = this.showCircle && l, this.showCircle && l) {
        const c = this.points[0].position, h = this.points[1].position, d = this.points[2].position, u = h.clone().sub(c), f = d.clone().sub(c).clone().cross(u).normalize(), m = Potree.Utils.computeCircleCenter(c, h, d), y = m.distanceTo(c), x = y / 20;
        a.position.copy(m), a.scale.set(x, x, x), s.geometry.setPositions([
          0,
          0,
          0,
          ...h.clone().sub(m).toArray()
        ]), s.geometry.verticesNeedUpdate = !0, s.geometry.computeBoundingSphere(), s.position.copy(m), s.computeLineDistances();
        const v = m.clone().add(f);
        o.position.copy(m), o.scale.set(y, y, y), o.lookAt(v), r.visible = !0, r.position.copy(m.clone().add(h).multiplyScalar(0.5)), r.setText(`${y.toFixed(3)}`);
      }
    }
    {
      this.areaLabel.position.copy(n), this.areaLabel.visible = this.showArea && this.points.length >= 3;
      let r = this.getArea(), s = "";
      this.lengthUnit != null && this.lengthUnitDisplay != null && (r = r / Math.pow(this.lengthUnit.unitspermeter, 2) * Math.pow(this.lengthUnitDisplay.unitspermeter, 2), s = this.lengthUnitDisplay.code);
      let a = `${Et.addCommas(r.toFixed(1))} ${s}`;
      this.areaLabel.setText(a);
    }
  }
  raycast(e, n) {
    for (let r = 0; r < this.points.length; r++)
      this.spheres[r].raycast(e, n);
    for (let r = 0; r < n.length; r++) {
      let s = n[r];
      s.distance = e.ray.origin.distanceTo(s.point);
    }
    n.sort(function(r, s) {
      return r.distance - s.distance;
    });
  }
  get showCoordinates() {
    return this._showCoordinates;
  }
  set showCoordinates(e) {
    this._showCoordinates = e, this.update();
  }
  get showAngles() {
    return this._showAngles;
  }
  set showAngles(e) {
    this._showAngles = e, this.update();
  }
  get showCircle() {
    return this._showCircle;
  }
  set showCircle(e) {
    this._showCircle = e, this.update();
  }
  get showAzimuth() {
    return this._showAzimuth;
  }
  set showAzimuth(e) {
    this._showAzimuth = e, this.update();
  }
  get showEdges() {
    return this._showEdges;
  }
  set showEdges(e) {
    this._showEdges = e, this.update();
  }
  get showHeight() {
    return this._showHeight;
  }
  set showHeight(e) {
    this._showHeight = e, this.update();
  }
  get showArea() {
    return this._showArea;
  }
  set showArea(e) {
    this._showArea = e, this.update();
  }
  get closed() {
    return this._closed;
  }
  set closed(e) {
    this._closed = e, this.update();
  }
  get showDistances() {
    return this._showDistances;
  }
  set showDistances(e) {
    this._showDistances = e, this.update();
  }
}
class UP extends Ie {
  constructor(e) {
    super(), this.constructor.counter = this.constructor.counter === void 0 ? 0 : this.constructor.counter + 1, this.name = "polygon_clip_volume_" + this.constructor.counter, this.camera = e.clone(), this.camera.rotation.set(...e.rotation.toArray()), this.camera.rotation.order = e.rotation.order, this.camera.updateMatrixWorld(), this.camera.updateProjectionMatrix(), this.camera.matrixWorldInverse.copy(this.camera.matrixWorld).invert(), this.viewMatrix = this.camera.matrixWorldInverse.clone(), this.projMatrix = this.camera.projectionMatrix.clone(), this.markers = [], this.initialized = !1;
  }
  addMarker() {
    let e = new at(), n, r = (o) => {
      let a = o.viewer.renderer.getSize(new xe()), l = new F(
        2 * (o.drag.end.x / a.width) - 1,
        -2 * (o.drag.end.y / a.height) + 1,
        0
      );
      e.position.copy(l);
    }, s = (o) => {
      n();
    };
    n = (o) => {
      e.removeEventListener("drag", r), e.removeEventListener("drop", s);
    }, e.addEventListener("drag", r), e.addEventListener("drop", s), this.markers.push(e);
  }
  removeLastMarker() {
    this.markers.length > 0 && this.markers.splice(this.markers.length - 1, 1);
  }
}
class Et {
  static async loadShapefileFeatures(e, n) {
    let r = [], s = () => {
      n(r);
    }, o = await shapefile.open(e);
    for (; ; ) {
      let a = await o.read();
      if (a.done) {
        s();
        break;
      }
      a.value && a.value.type === "Feature" && a.value.geometry !== void 0 && r.push(a.value);
    }
  }
  static toString(e) {
    return e.x != null ? e.x.toFixed(2) + ", " + e.y.toFixed(2) + ", " + e.z.toFixed(2) : "" + e;
  }
  static normalizeURL(e) {
    let n = new URL(e);
    return n.protocol + "//" + n.hostname + n.pathname.replace(/\/+/g, "/");
  }
  static pathExists(e) {
    let n = TP.createXMLHttpRequest();
    return n.open("GET", e, !1), n.send(null), n.status === 200;
  }
  static debugSphere(e, n, r, s) {
    let o = new ia(1, 8, 8), a;
    s !== void 0 ? a = new ci({ color: s }) : a = new Ri();
    let l = new at(o, a);
    return l.position.copy(n), l.scale.set(r, r, r), e.add(l), l;
  }
  static debugLine(e, n, r, s) {
    let o = new Vt({ color: s }), a = new Gt();
    const l = new F(0, 0, 0), c = r.clone().sub(n);
    a.vertices.push(l, c);
    let h = new Ci(a, o);
    return h.position.copy(n), e.add(h), {
      node: h,
      set: (u, p) => {
        a.vertices[0].copy(u), a.vertices[1].copy(p), a.verticesNeedUpdate = !0;
      }
    };
  }
  static debugCircle(e, n, r, s, o) {
    let a = new Vt({ color: o }), l = new Gt(), c = 32;
    for (let d = 0; d <= c; d++) {
      let u = 2 * Math.PI * (d / c), p = 2 * Math.PI * (d + 1) / c, f = new F(
        Math.cos(u),
        Math.sin(u),
        0
      ), m = new F(
        Math.cos(p),
        Math.sin(p),
        0
      );
      l.vertices.push(f, m);
    }
    let h = new Ci(l, a);
    h.position.copy(n), h.scale.set(r, r, r), e.add(h);
  }
  static debugBox(e, n, r = new Ye(), s = 16776960) {
    let o = [
      [n.min.x, n.min.y, n.min.z],
      [n.min.x, n.min.y, n.max.z],
      [n.min.x, n.max.y, n.min.z],
      [n.min.x, n.max.y, n.max.z],
      [n.max.x, n.min.y, n.min.z],
      [n.max.x, n.min.y, n.max.z],
      [n.max.x, n.max.y, n.min.z],
      [n.max.x, n.max.y, n.max.z]
    ].map((h) => new F(...h)), a = [
      [0, 4],
      [4, 5],
      [5, 1],
      [1, 0],
      [2, 6],
      [6, 7],
      [7, 3],
      [3, 2],
      [0, 2],
      [4, 6],
      [5, 7],
      [1, 3]
    ], l = n.getCenter(new F()), c = [
      { position: [n.min.x, l.y, l.z], color: 16711680 },
      { position: [n.max.x, l.y, l.z], color: 8912896 },
      { position: [l.x, n.min.y, l.z], color: 65280 },
      { position: [l.x, n.max.y, l.z], color: 34816 },
      { position: [l.x, l.y, n.min.z], color: 255 },
      { position: [l.x, l.y, n.max.z], color: 136 }
    ];
    for (let h of o) {
      let d = h.clone().applyMatrix4(r);
      Et.debugSphere(e, d, 0.1, 16711680);
    }
    for (let h of a) {
      let d = o[h[0]].clone().applyMatrix4(r), u = o[h[1]].clone().applyMatrix4(r);
      Et.debugLine(e, d, u, s);
    }
    for (let h of c) {
      let d = new F(...h.position).applyMatrix4(r);
      Et.debugSphere(e, d, 0.1, h.color);
    }
  }
  static debugPlane(e, n, r = 1, s = 255) {
    let o = new MP(n, r, s);
    e.add(o);
  }
  /**
   * adapted from mhluska at https://github.com/mrdoob/three.js/issues/1561
   */
  static computeTransformedBoundingBox(e, n) {
    let r = [
      new F(e.min.x, e.min.y, e.min.z).applyMatrix4(n),
      new F(e.max.x, e.min.y, e.min.z).applyMatrix4(n),
      new F(e.min.x, e.max.y, e.min.z).applyMatrix4(n),
      new F(e.max.x, e.max.y, e.min.z).applyMatrix4(n),
      new F(e.min.x, e.min.y, e.max.z).applyMatrix4(n),
      new F(e.max.x, e.min.y, e.max.z).applyMatrix4(n),
      new F(e.min.x, e.max.y, e.max.z).applyMatrix4(n),
      new F(e.max.x, e.max.y, e.max.z).applyMatrix4(n)
    ], s = new Un();
    return s.setFromPoints(r), s;
  }
  /**
   * add separators to large numbers
   *
   * @param nStr
   * @returns
   */
  static addCommas(e) {
    e += "";
    let n = e.split("."), r = n[0], s = n.length > 1 ? "." + n[1] : "", o = /(\d+)(\d{3})/;
    for (; o.test(r); )
      r = r.replace(o, "$1,$2");
    return r + s;
  }
  static removeCommas(e) {
    return e.replace(/,/g, "");
  }
  /**
   * create worker from a string
   *
   * code from http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
   */
  static createWorker(e) {
    let n = new Blob([e], { type: "application/javascript" });
    return new Worker(URL.createObjectURL(n));
  }
  static moveTo(e, n, r) {
    let s = e.view, o = e.getActiveCamera(), a = 500, l = TWEEN.Easing.Quartic.Out;
    {
      let c = new TWEEN.Tween(s.position).to(n, a);
      c.easing(l), c.start();
    }
    {
      let c = o.position.distanceTo(r), h = new F().addVectors(
        o.position,
        o.getWorldDirection(new F()).clone().multiplyScalar(c)
      ), d = new TWEEN.Tween(h).to(r, a);
      d.easing(l), d.onUpdate(() => {
        s.lookAt(h);
      }), d.onComplete(() => {
        s.lookAt(h);
      }), d.start();
    }
  }
  static loadSkybox(e) {
    let n = new Ie(), r = new Pt(75, window.innerWidth / window.innerHeight, 1, 1e5);
    r.up.set(0, 0, 1);
    let s = new uu(), o = ".jpg", a = [
      e + "px" + o,
      e + "nx" + o,
      e + "py" + o,
      e + "ny" + o,
      e + "pz" + o,
      e + "nz" + o
    ], l = [];
    for (let d = 0; d < 6; d++) {
      let u = new ci({
        map: null,
        side: Ct,
        depthTest: !1,
        depthWrite: !1,
        color: 4343126
      });
      l.push(u), new Vh().load(
        a[d],
        function(m) {
          u.map = m, u.needsUpdate = !0, u.color.setHex(16777215);
        },
        function(m) {
        },
        function(m) {
          console.log("An error happened", m);
        }
      );
    }
    let c = new wx(700, 700, 700), h = new at(c, l);
    return s.add(h), s.traverse((d) => d.frustumCulled = !1), s.rotation.x = Math.PI / 2, n.children.push(r), r.parent = n, { camera: r, scene: s, parent: n };
  }
  static createGrid(e, n, r, s) {
    let o = new Vt({
      color: s || 8947848
    }), a = new Gt();
    for (let c = 0; c <= n; c++)
      a.vertices.push(new F(-(r * e) / 2, c * r - r * n / 2, 0)), a.vertices.push(new F(+(r * e) / 2, c * r - r * n / 2, 0));
    for (let c = 0; c <= e; c++)
      a.vertices.push(new F(c * r - r * e / 2, -(r * n) / 2, 0)), a.vertices.push(new F(c * r - r * e / 2, +(r * n) / 2, 0));
    let l = new bl(a, o);
    return l.receiveShadow = !0, l;
  }
  static createBackgroundTexture(e, n) {
    function r(h, d) {
      return 1 / (2 * Math.PI) * Math.exp(-(h * h + d * d) / 2);
    }
    let s = e * n, o = new Uint8Array(3 * s), a = [1, 1.5, 1.7], l = r(0, 0);
    for (let h = 0; h < e; h++)
      for (let d = 0; d < n; d++) {
        let u = 2 * (h / e) - 1, p = 2 * (d / n) - 1, f = h + e * d, m = r(2 * u, 2 * p) / l, y = (Math.random() + Math.random() + Math.random()) / 3;
        y = (m * 0.5 + 0.5) * y * 0.03, y = y * 0.4, o[3 * f + 0] = 255 * (m / 15 + 0.05 + y) * a[0], o[3 * f + 1] = 255 * (m / 15 + 0.05 + y) * a[1], o[3 * f + 2] = 255 * (m / 15 + 0.05 + y) * a[2];
      }
    let c = new Yr(o, e, n, Br);
    return c.needsUpdate = !0, c;
  }
  static getMousePointCloudIntersection(e, n, r, s, o = {}) {
    let a = r.renderer, l = {
      x: e.x / a.domElement.clientWidth * 2 - 1,
      y: -(e.y / a.domElement.clientHeight) * 2 + 1
    }, c = {};
    o.pickClipped && (c.pickClipped = o.pickClipped), c.x = e.x, c.y = a.domElement.clientHeight - e.y;
    let h = new gp();
    h.setFromCamera(l, n);
    let d = h.ray, u = null, p = 1 / 0, f = null, m = null;
    for (let y of s) {
      let x = y.pick(r, n, d, c);
      if (!x)
        continue;
      let v = n.position.distanceTo(x.position);
      v < p && (p = v, u = y, f = x.position, m = x);
    }
    return u ? {
      location: f,
      distance: p,
      pointcloud: u,
      point: m
    } : null;
  }
  static pixelsArrayToImage(e, n, r) {
    let s = document.createElement("canvas");
    s.width = n, s.height = r;
    let o = s.getContext("2d");
    e = new e.constructor(e);
    for (let c = 0; c < e.length; c++)
      e[c * 4 + 3] = 255;
    let a = o.createImageData(n, r);
    a.data.set(e), o.putImageData(a, 0, 0);
    let l = new Image();
    return l.src = s.toDataURL(), l;
  }
  static pixelsArrayToDataUrl(e, n, r) {
    let s = document.createElement("canvas");
    s.width = n, s.height = r;
    let o = s.getContext("2d");
    e = new e.constructor(e);
    for (let c = 0; c < e.length; c++)
      e[c * 4 + 3] = 255;
    let a = o.createImageData(n, r);
    return a.data.set(e), o.putImageData(a, 0, 0), s.toDataURL();
  }
  static pixelsArrayToCanvas(e, n, r) {
    let s = document.createElement("canvas");
    s.width = n, s.height = r;
    let o = s.getContext("2d");
    e = new e.constructor(e);
    let a = n * 4;
    for (let c = 0; c < parseInt(r / 2); c++) {
      let h = r - c - 1, d = e.slice(c * a, c * a + a), u = e.slice(h * a, h * a + a);
      e.set(u, c * a), e.set(d, h * a);
    }
    let l = o.createImageData(n, r);
    return l.data.set(e), o.putImageData(l, 0, 0), s;
  }
  static removeListeners(e, n) {
    e._listeners !== void 0 && e._listeners[n] && delete e._listeners[n];
  }
  static mouseToRay(e, n, r, s) {
    let o = {
      x: e.x / r * 2 - 1,
      y: -(e.y / s) * 2 + 1
    }, a = new F(o.x, o.y, 0.5), l = n.position.clone();
    a.unproject(n);
    let c = new F().subVectors(a, l).normalize();
    return new ta(l, c);
  }
  static projectedRadius(e, n, r, s, o) {
    if (n instanceof kh)
      return Et.projectedRadiusOrtho(e, n.projectionMatrix, s, o);
    if (n instanceof Pt)
      return Et.projectedRadiusPerspective(e, n.fov * Math.PI / 180, r, o);
    throw new Error("invalid parameters");
  }
  static projectedRadiusPerspective(e, n, r, s) {
    let o = 1 / Math.tan(n / 2) / r;
    return o = o * s / 2, e * o;
  }
  static projectedRadiusOrtho(e, n, r, s) {
    let o = new st(0), a = new st(e);
    return o.applyMatrix4(n), a.applyMatrix4(n), o = new F(o.x, o.y, o.z), a = new F(a.x, a.y, a.z), o.x = (o.x + 1) * 0.5 * r, o.y = (o.y + 1) * 0.5 * s, a.x = (a.x + 1) * 0.5 * r, a.y = (a.y + 1) * 0.5 * s, o.distanceTo(a);
  }
  static topView(e, n) {
    e.position.set(0, 1, 0), e.rotation.set(-Math.PI / 2, 0, 0), e.zoomTo(n, 1);
  }
  static frontView(e, n) {
    e.position.set(0, 0, 1), e.rotation.set(0, 0, 0), e.zoomTo(n, 1);
  }
  static leftView(e, n) {
    e.position.set(-1, 0, 0), e.rotation.set(0, -Math.PI / 2, 0), e.zoomTo(n, 1);
  }
  static rightView(e, n) {
    e.position.set(1, 0, 0), e.rotation.set(0, Math.PI / 2, 0), e.zoomTo(n, 1);
  }
  static findClosestGpsTime(e, n) {
    const r = performance.now(), s = [];
    for (const p of n.scene.pointclouds) {
      s.push(p.root);
      for (const f of p.root.children)
        f && s.push(f);
    }
    let o = null, a = 1 / 0, l = 1 / 0;
    for (const p of s) {
      if (!(p.geometryNode != null && p.geometryNode.geometry != null && p.sceneNode != null))
        continue;
      let y = p.geometryNode.geometry.attributes["gps-time"], x = y.potree.range;
      for (let v = 0; v < y.array.length; v++) {
        let g = y.array[v];
        g = g * (x[1] - x[0]) + x[0];
        const S = Math.abs(e - g);
        S < l && (a = v, l = S, o = p);
      }
    }
    const c = o.geometryNode.geometry, h = new F(
      c.attributes.position.array[3 * a + 0],
      c.attributes.position.array[3 * a + 1],
      c.attributes.position.array[3 * a + 2]
    );
    h.applyMatrix4(o.sceneNode.matrixWorld);
    const u = performance.now() - r;
    return console.log(`duration: ${u.toFixed(3)}ms`), {
      node: o,
      index: a,
      position: h
    };
  }
  /**
   *
   * 0: no intersection
   * 1: intersection
   * 2: fully inside
   */
  static frustumSphereIntersection(e, n) {
    let r = e.planes, s = n.center, o = -n.radius, a = Number.MAX_VALUE;
    for (let l = 0; l < 6; l++) {
      let c = r[l].distanceToPoint(s);
      if (c < o)
        return 0;
      a = Math.min(a, c);
    }
    return a >= n.radius ? 2 : 1;
  }
  // code taken from three.js
  // ImageUtils - generateDataTexture()
  static generateDataTexture(e, n, r) {
    let s = e * n, o = new Uint8Array(4 * e * n), a = Math.floor(r.r * 255), l = Math.floor(r.g * 255), c = Math.floor(r.b * 255);
    for (let d = 0; d < s; d++)
      o[d * 3] = a, o[d * 3 + 1] = l, o[d * 3 + 2] = c;
    let h = new Yr(o, e, n, Nn);
    return h.needsUpdate = !0, h.magFilter = Xt, h;
  }
  // from http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
  static getParameterByName(e) {
    e = e.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
    let r = new RegExp("[\\?&]" + e + "=([^&#]*)").exec(document.location.search);
    return r === null ? null : decodeURIComponent(r[1].replace(/\+/g, " "));
  }
  static setParameter(e, n) {
    e = e.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
    let s = new RegExp("([\\?&])(" + e + "=([^&#]*))").exec(document.location.search), o = window.location.href;
    if (s === null)
      window.location.search.length === 0 ? o = o + "?" : o = o + "&", o = o + e + "=" + n;
    else {
      let a = e + "=" + n;
      o = o.replace(s[2], a);
    }
    window.history.replaceState({}, "", o);
  }
  static createChildAABB(e, n) {
    let r = e.min.clone(), s = e.max.clone(), o = new F().subVectors(s, r);
    return (n & 1) > 0 ? r.z += o.z / 2 : s.z -= o.z / 2, (n & 2) > 0 ? r.y += o.y / 2 : s.y -= o.y / 2, (n & 4) > 0 ? r.x += o.x / 2 : s.x -= o.x / 2, new Un(r, s);
  }
  // see https://stackoverflow.com/questions/400212/how-do-i-copy-to-the-clipboard-in-javascript
  static clipboardCopy(e) {
    let n = document.createElement("textarea");
    n.style.position = "fixed", n.style.top = 0, n.style.left = 0, n.style.width = "2em", n.style.height = "2em", n.style.padding = 0, n.style.border = "none", n.style.outline = "none", n.style.boxShadow = "none", n.style.background = "transparent", n.value = e, document.body.appendChild(n), n.select();
    try {
      let r = document.execCommand("copy");
      console.log(r ? "copied text to clipboard" : "copy to clipboard failed");
    } catch {
      console.log("error while trying to copy to clipboard");
    }
    document.body.removeChild(n);
  }
  static getMeasurementIcon(e) {
    if (e instanceof zP)
      return e.showDistances && !e.showArea && !e.showAngles ? `${Potree.resourcePath}/icons/distance.svg` : e.showDistances && e.showArea && !e.showAngles ? `${Potree.resourcePath}/icons/area.svg` : e.maxMarkers === 1 ? `${Potree.resourcePath}/icons/point.svg` : !e.showDistances && !e.showArea && e.showAngles ? `${Potree.resourcePath}/icons/angle.png` : e.showHeight ? `${Potree.resourcePath}/icons/height.svg` : `${Potree.resourcePath}/icons/distance.svg`;
    if (e instanceof LP)
      return `${Potree.resourcePath}/icons/profile.svg`;
    if (e instanceof AP)
      return `${Potree.resourcePath}/icons/volume.svg`;
    if (e instanceof UP)
      return `${Potree.resourcePath}/icons/clip-polygon.svg`;
  }
  static lineToLineIntersection(e, n, r, s) {
    const o = [e, n, r, s], a = (m, y, x, v) => (o[m].x - o[y].x) * (o[x].x - o[v].x) + (o[m].y - o[y].y) * (o[x].y - o[v].y) + (o[m].z - o[y].z) * (o[x].z - o[v].z), l = (a(0, 2, 3, 2) * a(3, 2, 1, 0) - a(0, 2, 1, 0) * a(3, 2, 3, 2)) / (a(1, 0, 1, 0) * a(3, 2, 3, 2) - a(3, 2, 1, 0) * a(3, 2, 1, 0)), c = (a(0, 2, 3, 2) + l * a(3, 2, 1, 0)) / a(3, 2, 3, 2), h = n.clone().sub(e), d = s.clone().sub(r), u = e.clone().add(h.multiplyScalar(l)), p = r.clone().add(d.multiplyScalar(c));
    return u.clone().add(p).multiplyScalar(0.5);
  }
  static computeCircleCenter(e, n, r) {
    const s = n.clone().sub(e), o = r.clone().sub(e), a = o.clone().cross(s).normalize(), l = s.clone().cross(a).normalize(), c = o.clone().cross(a).normalize(), h = e.clone().add(n).multiplyScalar(0.5), d = e.clone().add(r).multiplyScalar(0.5), u = h, p = h.clone().add(l), f = d, m = d.clone().add(c);
    return Et.lineToLineIntersection(u, p, f, m);
  }
  static getNorthVec(e, n, r) {
    if (r) {
      proj4.defs("pointcloud", r);
      const s = proj4("pointcloud", "WGS84"), o = s.forward(e.toArray());
      let a = s.forward([e.x, e.y + n]);
      const l = Math.sqrt((a[0] - o[0]) ** 2 + (a[1] - o[1]) ** 2);
      a = [o[0], o[1] + l];
      const c = s.inverse(a);
      return new F(...c, e.z).sub(e);
    } else
      return new F(0, 1, 0).multiplyScalar(n);
  }
  static computeAzimuth(e, n, r) {
    let s = 0;
    if (r) {
      let o;
      r.includes("EPSG") ? o = proj4(r, "WGS84") : (proj4.defs("pointcloud", r), o = proj4("pointcloud", "WGS84"));
      const a = o.forward(e.toArray()), l = o.forward(n.toArray()), c = [
        l[0] - a[0],
        l[1] - a[1]
      ];
      s = Math.atan2(c[1], c[0]) - Math.PI / 2;
    } else {
      const o = [n.x - e.x, n.y - e.y];
      s = Math.atan2(o[1], o[0]) - Math.PI / 2;
    }
    return s = -s, s;
  }
  static async loadScript(e) {
    return new Promise((n) => {
      if (document.getElementById(e))
        n();
      else {
        const s = document.createElement("script");
        s.id = e, s.onload = () => {
          n();
        }, s.src = e, document.body.appendChild(s);
      }
    });
  }
  static createSvgGradient(e) {
    const n = `${Math.random()}_${Date.now()}`, r = "http://www.w3.org/2000/svg", s = document.createElementNS(r, "svg");
    s.setAttributeNS(null, "width", "2em"), s.setAttributeNS(null, "height", "3em");
    {
      const a = document.createElementNS(r, "defs"), l = document.createElementNS(r, "linearGradient");
      l.setAttributeNS(null, "id", n), l.setAttributeNS(null, "gradientTransform", "rotate(90)");
      for (let c = e.length - 1; c >= 0; c--) {
        const h = e[c], d = parseInt(100 - h[0] * 100), [u, p, f] = h[1].toArray().map((y) => parseInt(y * 255)), m = document.createElementNS(r, "stop");
        m.setAttributeNS(null, "offset", `${d}%`), m.setAttributeNS(null, "stop-color", `rgb(${u}, ${p}, ${f})`), l.appendChild(m);
      }
      a.appendChild(l), s.appendChild(a);
    }
    const o = document.createElementNS(r, "rect");
    return o.setAttributeNS(null, "width", "100%"), o.setAttributeNS(null, "height", "100%"), o.setAttributeNS(null, "fill", `url("#${n}")`), o.setAttributeNS(null, "stroke", "black"), o.setAttributeNS(null, "stroke-width", "0.1em"), s.appendChild(o), s;
  }
  static async waitAny(e) {
    return new Promise((n) => {
      e.map((r) => {
        r.then(() => {
          n();
        });
      });
    });
  }
}
Et.screenPass = new function() {
  this.screenScene = new uu(), this.screenQuad = new at(new ux(2, 2, 1)), this.screenQuad.material.depthTest = !0, this.screenQuad.material.depthWrite = !0, this.screenQuad.material.transparent = !0, this.screenScene.add(this.screenQuad), this.camera = new er(), this.render = function(t, e, n) {
    this.screenQuad.material = e, typeof n > "u" ? t.render(this.screenScene, this.camera) : t.render(this.screenScene, this.camera, n);
  };
}();
class HP {
  constructor() {
    this._listeners = {};
  }
  addEventListener(e, n) {
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n);
  }
  hasEventListener(e, n) {
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    let s = this._listeners[e];
    if (s !== void 0) {
      let o = s.indexOf(n);
      o !== -1 && s.splice(o, 1);
    }
  }
  removeEventListeners(e) {
    this._listeners[e] !== void 0 && delete this._listeners[e];
  }
  dispatchEvent(e) {
    let r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      for (let s of r.slice(0))
        s.call(this, e);
    }
  }
}
class GP extends HP {
  constructor(e) {
    super(e), this.viewer = e, this.renderer = e.renderer, this.scene = null, this.sceneControls = new uu(), this.rotationSpeed = 10, this.fadeFactor = 20, this.wheelDelta = 0, this.zoomDelta = new F(), this.camStart = null, this.tweens = [];
    {
      let c = new ia(1, 16, 16), h = new Ri();
      this.pivotIndicator = new at(c, h), this.pivotIndicator.visible = !1, this.sceneControls.add(this.pivotIndicator);
    }
    let n = (c) => {
      if (c.drag.object !== null || !this.pivot)
        return;
      c.drag.startHandled === void 0 && (c.drag.startHandled = !0, this.dispatchEvent({ type: "start" }));
      let h = this.camStart, d = this.scene.getActiveCamera(), u = this.viewer.scene.view, p = c.drag.end, f = this.viewer.renderer.domElement;
      if (c.drag.mouse === ry.LEFT) {
        let m = Et.mouseToRay(p, d, f.clientWidth, f.clientHeight), y = new vi().setFromNormalAndCoplanarPoint(
          new F(0, 0, 1),
          this.pivot
        ), x = m.distanceToPlane(y);
        if (x > 0) {
          let v = new F().addVectors(
            h.position,
            m.direction.clone().multiplyScalar(x)
          ), g = new F().subVectors(
            v,
            this.pivot
          ), S = h.position.clone().sub(g);
          u.position.copy(S);
          {
            let T = S.distanceTo(this.pivot);
            u.radius = T;
            let E = u.radius / 2.5;
            this.viewer.setMoveSpeed(E);
          }
        }
      } else if (c.drag.mouse === ry.RIGHT) {
        let m = {
          x: c.drag.lastDrag.x / this.renderer.domElement.clientWidth,
          y: c.drag.lastDrag.y / this.renderer.domElement.clientHeight
        }, y = -m.x * this.rotationSpeed * 0.5, x = -m.y * this.rotationSpeed * 0.2, v = u.pitch, g = u.clone();
        g.pitch = g.pitch + x, x = g.pitch - v;
        let S = new F().subVectors(u.position, this.pivot), T = new F().subVectors(u.getPivot(), this.pivot), E = u.getSide();
        S.applyAxisAngle(E, x), T.applyAxisAngle(E, x), S.applyAxisAngle(new F(0, 0, 1), y), T.applyAxisAngle(new F(0, 0, 1), y);
        let w = new F().addVectors(this.pivot, S);
        u.position.copy(w), u.yaw += y, u.pitch += x;
      }
    }, r = (c) => {
      let h = Et.getMousePointCloudIntersection(
        c.mouse,
        this.scene.getActiveCamera(),
        this.viewer,
        this.scene.pointclouds,
        { pickClipped: !1 }
      );
      h && (this.pivot = h.location, this.camStart = this.scene.getActiveCamera().clone(), this.pivotIndicator.visible = !0, this.pivotIndicator.position.copy(h.location));
    }, s = (c) => {
      this.dispatchEvent({ type: "end" });
    }, o = (c) => {
      this.camStart = null, this.pivot = null, this.pivotIndicator.visible = !1;
    }, a = (c) => {
      this.wheelDelta += c.delta;
    }, l = (c) => {
      this.zoomToLocation(c.mouse);
    };
    this.addEventListener("drag", n), this.addEventListener("drop", s), this.addEventListener("mousewheel", a), this.addEventListener("mousedown", r), this.addEventListener("mouseup", o), this.addEventListener("dblclick", l);
  }
  setScene(e) {
    this.scene = e;
  }
  stop() {
    this.wheelDelta = 0, this.zoomDelta.set(0, 0, 0);
  }
  zoomToLocation(e) {
    let n = this.scene.getActiveCamera(), r = Et.getMousePointCloudIntersection(
      e,
      n,
      this.viewer,
      this.scene.pointclouds
    );
    if (r === null)
      return;
    let s = 0;
    {
      let h = 0.2, d = this.renderer.domElement, u = Et.mouseToRay(e, n, d.clientWidth, d.clientHeight), p = r.pointcloud.nodesOnRay(r.pointcloud.visibleNodes, u), m = p[p.length - 1].getBoundingSphere(new Oi()).radius;
      s = Math.min(this.scene.view.radius, m), s = Math.max(h, s);
    }
    let o = this.scene.view.direction.multiplyScalar(-1), a = new F().addVectors(r.location, o.multiplyScalar(s)), l = 600, c = TWEEN.Easing.Quartic.Out;
    {
      let h = { x: 0 }, d = new TWEEN.Tween(h).to({ x: 1 }, l);
      d.easing(c), this.tweens.push(d);
      let u = this.scene.view.position.clone(), p = a.clone(), f = this.scene.view.radius, m = a.distanceTo(r.location);
      d.onUpdate(() => {
        let y = h.x;
        this.scene.view.position.x = (1 - y) * u.x + y * p.x, this.scene.view.position.y = (1 - y) * u.y + y * p.y, this.scene.view.position.z = (1 - y) * u.z + y * p.z, this.scene.view.radius = (1 - y) * f + y * m, this.viewer.setMoveSpeed(this.scene.view.radius / 2.5);
      }), d.onComplete(() => {
        this.tweens = this.tweens.filter((y) => y !== d);
      }), d.start();
    }
  }
  update(e) {
    let n = this.scene.view, r = Math.pow(0.5, this.fadeFactor * e), s = 1 - r, o = this.scene.getActiveCamera();
    if (this.wheelDelta !== 0) {
      let a = Et.getMousePointCloudIntersection(
        this.viewer.inputHandler.mouse,
        this.scene.getActiveCamera(),
        this.viewer,
        this.scene.pointclouds
      );
      if (a) {
        let l = new F().addVectors(n.position, this.zoomDelta), h = a.location.distanceTo(l) * 0.2 * this.wheelDelta, d = new F().subVectors(a.location, n.position);
        d.normalize(), l.add(d.multiplyScalar(h)), this.zoomDelta.subVectors(l, n.position);
        {
          let u = l.distanceTo(a.location);
          n.radius = u;
          let p = n.radius / 2.5;
          this.viewer.setMoveSpeed(p);
        }
      }
    }
    if (this.zoomDelta.length() !== 0) {
      let a = this.zoomDelta.clone().multiplyScalar(s), l = new F().addVectors(n.position, a);
      n.position.copy(l);
    }
    if (this.pivotIndicator.visible) {
      let a = this.pivotIndicator.position.distanceTo(n.position), l = this.renderer.domElement.clientwidth, c = this.renderer.domElement.clientHeight, d = 10 / Et.projectedRadius(1, o, a, l, c);
      this.pivotIndicator.scale.set(d, d, d);
    }
    this.zoomDelta.multiplyScalar(r), this.wheelDelta = 0;
  }
}
class VP extends GP {
  constructor(e) {
    super(e), this.viewer = e, this.renderer = e.renderer, this.scene = null, this.sceneControls = new Zf(), this.rotationSpeed = 10, this.targetZ = 0, this.fadeFactor = 10, this.wheelDelta = 0, this.zoomDelta = new z(), this.camStart = null, this.tweens = [], this.raycaster = new tu();
    {
      let c = new u1(1, 16, 16), h = new xs();
      this.pivotIndicator = new Tt(c, h), this.pivotIndicator.visible = !1, this.sceneControls.add(this.pivotIndicator);
    }
    let n = (c) => {
      if (c.drag.object !== null || !this.pivot)
        return;
      c.drag.startHandled === void 0 && (c.drag.startHandled = !0, this.dispatchEvent({ type: "start" }));
      let h = this.camStart, d = this.scene.getActiveCamera(), u = this.viewer.scene.view, p = c.drag.end, f = this.viewer.renderer.domElement;
      if (c.drag.mouse === vp.LEFT) {
        let m = Potree.Utils.mouseToRay(p, d, f.clientWidth, f.clientHeight), y = new ti().setFromNormalAndCoplanarPoint(
          new z(0, 0, 1),
          this.pivot
        ), x = m.distanceToPlane(y);
        if (x > 0) {
          let v = new z().addVectors(
            h.position,
            m.direction.clone().multiplyScalar(x)
          ), g = new z().subVectors(
            v,
            this.pivot
          ), S = h.position.clone().sub(g);
          u.position.copy(S);
          {
            let T = S.distanceTo(this.pivot);
            u.radius = T;
            let E = u.radius / 2.5;
            this.viewer.setMoveSpeed(E);
          }
        }
      } else if (c.drag.mouse === vp.RIGHT) {
        let m = {
          x: c.drag.lastDrag.x / this.renderer.domElement.clientWidth,
          y: c.drag.lastDrag.y / this.renderer.domElement.clientHeight
        }, y = -m.x * this.rotationSpeed * 0.5, x = -m.y * this.rotationSpeed * 0.2, v = u.pitch, g = u.clone();
        g.pitch = g.pitch + x, x = g.pitch - v;
        let S = new z().subVectors(u.position, this.pivot), T = new z().subVectors(u.getPivot(), this.pivot), E = u.getSide();
        S.applyAxisAngle(E, x), T.applyAxisAngle(E, x), S.applyAxisAngle(new z(0, 0, 1), y), T.applyAxisAngle(new z(0, 0, 1), y);
        let w = new z().addVectors(this.pivot, S);
        u.position.copy(w), u.yaw += y, u.pitch += x;
      }
    }, r = (c) => {
      let h = Potree.Utils.getMousePointCloudIntersection(
        c.mouse,
        this.scene.getActiveCamera(),
        this.viewer,
        this.scene.pointclouds,
        { pickClipped: !1 }
      );
      if (h)
        this.pivot = h.location, this.camStart = this.scene.getActiveCamera().clone(), this.pivotIndicator.visible = !0, this.pivotIndicator.position.copy(h.location), this.targetZ = h.location.z;
      else {
        let d = new z(), u = new ye(
          c.mouse.x / this.renderer.domElement.clientWidth * 2 - 1,
          -(c.mouse.y / this.renderer.domElement.clientHeight) * 2 + 1
        );
        d.set(u.x, u.y, 0.5), d.unproject(this.scene.getActiveCamera().clone()), d.sub(this.scene.getActiveCamera().clone().position).normalize(), this.updateTargetZ(c);
        let p = (this.targetZ - this.scene.getActiveCamera().clone().position.z) / d.z, f = this.scene.getActiveCamera().clone().position.add(d.multiplyScalar(p));
        this.pivot = f, this.camStart = this.scene.getActiveCamera().clone(), this.pivotIndicator.visible = !0, this.pivotIndicator.position.copy(f);
      }
    }, s = (c) => {
      this.dispatchEvent({ type: "end" });
    }, o = (c) => {
      this.camStart = null, this.pivot = null, this.pivotIndicator.visible = !1;
    }, a = (c) => {
      this.wheelDelta += c.delta;
    }, l = (c) => {
      this.zoomToLocation(c.mouse);
    };
    this.addEventListener("drag", n), this.addEventListener("drop", s), this.addEventListener("mousewheel", a), this.addEventListener("mousedown", r), this.addEventListener("mouseup", o), this.addEventListener("dblclick", l);
  }
  update(e) {
    let n = this.scene.view, r = this.scene.getActiveCamera(), s = Math.pow(0.5, this.fadeFactor * e), o = 1 - s;
    if (this.wheelDelta !== 0) {
      let a = Potree.Utils.getMousePointCloudIntersection(
        this.viewer.inputHandler.mouse,
        this.scene.getActiveCamera(),
        this.viewer,
        this.scene.pointclouds
      );
      if (a) {
        let l = new z().addVectors(n.position, this.zoomDelta), h = a.location.distanceTo(l) * 0.2 * this.wheelDelta, d = new z().subVectors(a.location, n.position);
        d.normalize(), l.add(d.multiplyScalar(h)), this.zoomDelta.subVectors(l, n.position);
        {
          let u = l.distanceTo(a.location);
          n.radius = u;
          let p = n.radius / 2.5;
          this.viewer.setMoveSpeed(p);
        }
        this.targetZ = a.location.z;
      } else {
        let l = new z(), c = new z();
        l.set(
          this.viewer.inputHandler.mouse.x / this.renderer.domElement.clientWidth * 2 - 1,
          -(this.viewer.inputHandler.mouse.y / this.renderer.domElement.clientHeight) * 2 + 1,
          0.5
        ), l.unproject(this.scene.getActiveCamera().clone()), l.sub(this.scene.getActiveCamera().clone().position).normalize();
        let h = (this.targetZ - this.scene.getActiveCamera().clone().position.z) / l.z;
        c.copy(this.scene.getActiveCamera().clone().position).add(l.multiplyScalar(h));
        let d = new z().addVectors(n.position, this.zoomDelta), u = c.distanceTo(d);
        this.wheelDelta > 4 && (this.wheelDelta = 4), this.wheelDelta < -4 && (this.wheelDelta = -4);
        let p = u * 0.2 * this.wheelDelta, f = new z().subVectors(c, n.position);
        f.normalize(), d.add(f.multiplyScalar(p)), this.zoomDelta.subVectors(d, n.position);
        {
          let m = d.distanceTo(c);
          n.radius = m;
          let y = n.radius / 2.5;
          this.viewer.setMoveSpeed(y);
        }
      }
    }
    if (this.zoomDelta.length() !== 0) {
      let a = this.zoomDelta.clone().multiplyScalar(o), l = new z().addVectors(n.position, a);
      n.position.copy(l);
    }
    if (this.pivotIndicator.visible) {
      let a = this.pivotIndicator.position.distanceTo(n.position), l = this.renderer.domElement.clientwidth, c = this.renderer.domElement.clientHeight, d = 10 / Potree.Utils.projectedRadius(1, r, a, l, c);
      this.pivotIndicator.scale.set(d, d, d);
    }
    this.zoomDelta.multiplyScalar(s), this.wheelDelta = 0;
  }
  updateTargetZ(e) {
    let n = e.mouse.x / this.viewer.renderer.domElement.clientWidth * 2 - 1, r = -(e.mouse.y / this.viewer.renderer.domElement.clientHeight) * 2 + 1;
    this.raycaster.setFromCamera(new ye(n, r), this.scene.getActiveCamera());
    const s = [];
    this.viewer.scene.scene.traverse((l) => {
      l.visible == !0 && l.type != "AxesHelper" && l.type != "LineSegments" && l.userData.Type != "Cursor3D" && !l.userData.beingModified && s.push(l);
    });
    let a = this.raycaster.intersectObjects(s, !1).sort((l, c) => l.point.z < c.point.z);
    a.length && (this.targetZ = a[0].point.z);
  }
}
async function II(t) {
  $1(), t || (t = {}), t.viewer || (t.viewer = {}, t.viewer.FOV || (t.viewer.FOV = 60), t.viewer.pointBudget || (t.viewer.pointBudget = 1e6), t.viewer.background || (t.viewer.background = "black"), t.viewer.EDL || (t.viewer.EDL = !1)), kP(t);
}
async function DI(t) {
  t && await t.initialize();
}
async function kP(t) {
  return new Promise((e, n) => {
    Ce.setEDLEnabled(t.viewer.EDL ?? !1), Ce.setFOV(t.viewer.FOV ?? 60), Ce.setPointBudget(t.viewer.pointBudget ?? 1e6), Ce.setBackground(t.viewer.background ?? "black"), Ce.setControls(new VP(Ce)), Ce.loadSettingsFromURL(), Ce.setDescription(""), Ce.loadGUI(() => {
      Ce.setLanguage("en"), $("#menu_tools").next(), $("#menu_clipping").next(), Ce.fitToScreen(), e();
    });
  });
}
export {
  yT as Draw,
  gg as GLTFLayer,
  Go as GeometryLayer,
  Zi as Line,
  PI as Modify,
  RI as Overlay,
  TE as OverlayLayer,
  Fr as Point,
  qm as PointcloudLayer,
  Dn as Polygon,
  of as Snap,
  Rt as View,
  II as initialize,
  DI as setView
};
